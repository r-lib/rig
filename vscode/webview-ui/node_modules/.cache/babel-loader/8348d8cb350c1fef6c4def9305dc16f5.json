{"ast":null,"code":"import _slicedToArray from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { DOM } from \"../dom.js\";\nimport { PropertyChangeNotifier } from \"../observation/notifier.js\";\nimport { defaultExecutionContext, Observable } from \"../observation/observable.js\";\nimport { FASTElementDefinition } from \"./fast-definitions.js\";\nvar shadowRoots = new WeakMap();\nvar defaultEventOptions = {\n  bubbles: true,\n  composed: true,\n  cancelable: true\n};\n\nfunction getShadowRoot(element) {\n  return element.shadowRoot || shadowRoots.get(element) || null;\n}\n/**\n * Controls the lifecycle and rendering of a `FASTElement`.\n * @public\n */\n\n\nexport var Controller = /*#__PURE__*/function (_PropertyChangeNotifi) {\n  _inherits(Controller, _PropertyChangeNotifi);\n\n  var _super = _createSuper(Controller);\n\n  /**\n   * Creates a Controller to control the specified element.\n   * @param element - The element to be controlled by this controller.\n   * @param definition - The element definition metadata that instructs this\n   * controller in how to handle rendering and other platform integrations.\n   * @internal\n   */\n  function Controller(element, definition) {\n    var _this;\n\n    _classCallCheck(this, Controller);\n\n    _this = _super.call(this, element);\n    _this.boundObservables = null;\n    _this.behaviors = null;\n    _this.needsInitialization = true;\n    _this._template = null;\n    _this._styles = null;\n    _this._isConnected = false;\n    /**\n     * This allows Observable.getNotifier(...) to return the Controller\n     * when the notifier for the Controller itself is being requested. The\n     * result is that the Observable system does not need to create a separate\n     * instance of Notifier for observables on the Controller. The component and\n     * the controller will now share the same notifier, removing one-object construct\n     * per web component instance.\n     */\n\n    _this.$fastController = _assertThisInitialized(_this);\n    /**\n     * The view associated with the custom element.\n     * @remarks\n     * If `null` then the element is managing its own rendering.\n     */\n\n    _this.view = null;\n    _this.element = element;\n    _this.definition = definition;\n    var shadowOptions = definition.shadowOptions;\n\n    if (shadowOptions !== void 0) {\n      var shadowRoot = element.attachShadow(shadowOptions);\n\n      if (shadowOptions.mode === \"closed\") {\n        shadowRoots.set(element, shadowRoot);\n      }\n    } // Capture any observable values that were set by the binding engine before\n    // the browser upgraded the element. Then delete the property since it will\n    // shadow the getter/setter that is required to make the observable operate.\n    // Later, in the connect callback, we'll re-apply the values.\n\n\n    var accessors = Observable.getAccessors(element);\n\n    if (accessors.length > 0) {\n      var boundObservables = _this.boundObservables = Object.create(null);\n\n      for (var i = 0, ii = accessors.length; i < ii; ++i) {\n        var propertyName = accessors[i].name;\n        var value = element[propertyName];\n\n        if (value !== void 0) {\n          delete element[propertyName];\n          boundObservables[propertyName] = value;\n        }\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * Indicates whether or not the custom element has been\n   * connected to the document.\n   */\n\n\n  _createClass(Controller, [{\n    key: \"isConnected\",\n    get: function get() {\n      Observable.track(this, \"isConnected\");\n      return this._isConnected;\n    }\n  }, {\n    key: \"setIsConnected\",\n    value: function setIsConnected(value) {\n      this._isConnected = value;\n      Observable.notify(this, \"isConnected\");\n    }\n    /**\n     * Gets/sets the template used to render the component.\n     * @remarks\n     * This value can only be accurately read after connect but can be set at any time.\n     */\n\n  }, {\n    key: \"template\",\n    get: function get() {\n      return this._template;\n    },\n    set: function set(value) {\n      if (this._template === value) {\n        return;\n      }\n\n      this._template = value;\n\n      if (!this.needsInitialization) {\n        this.renderTemplate(value);\n      }\n    }\n    /**\n     * Gets/sets the primary styles used for the component.\n     * @remarks\n     * This value can only be accurately read after connect but can be set at any time.\n     */\n\n  }, {\n    key: \"styles\",\n    get: function get() {\n      return this._styles;\n    },\n    set: function set(value) {\n      if (this._styles === value) {\n        return;\n      }\n\n      if (this._styles !== null) {\n        this.removeStyles(this._styles);\n      }\n\n      this._styles = value;\n\n      if (!this.needsInitialization && value !== null) {\n        this.addStyles(value);\n      }\n    }\n    /**\n     * Adds styles to this element. Providing an HTMLStyleElement will attach the element instance to the shadowRoot.\n     * @param styles - The styles to add.\n     */\n\n  }, {\n    key: \"addStyles\",\n    value: function addStyles(styles) {\n      var target = getShadowRoot(this.element) || this.element.getRootNode();\n\n      if (styles instanceof HTMLStyleElement) {\n        target.append(styles);\n      } else if (!styles.isAttachedTo(target)) {\n        var sourceBehaviors = styles.behaviors;\n        styles.addStylesTo(target);\n\n        if (sourceBehaviors !== null) {\n          this.addBehaviors(sourceBehaviors);\n        }\n      }\n    }\n    /**\n     * Removes styles from this element. Providing an HTMLStyleElement will detach the element instance from the shadowRoot.\n     * @param styles - the styles to remove.\n     */\n\n  }, {\n    key: \"removeStyles\",\n    value: function removeStyles(styles) {\n      var target = getShadowRoot(this.element) || this.element.getRootNode();\n\n      if (styles instanceof HTMLStyleElement) {\n        target.removeChild(styles);\n      } else if (styles.isAttachedTo(target)) {\n        var sourceBehaviors = styles.behaviors;\n        styles.removeStylesFrom(target);\n\n        if (sourceBehaviors !== null) {\n          this.removeBehaviors(sourceBehaviors);\n        }\n      }\n    }\n    /**\n     * Adds behaviors to this element.\n     * @param behaviors - The behaviors to add.\n     */\n\n  }, {\n    key: \"addBehaviors\",\n    value: function addBehaviors(behaviors) {\n      var targetBehaviors = this.behaviors || (this.behaviors = new Map());\n      var length = behaviors.length;\n      var behaviorsToBind = [];\n\n      for (var i = 0; i < length; ++i) {\n        var behavior = behaviors[i];\n\n        if (targetBehaviors.has(behavior)) {\n          targetBehaviors.set(behavior, targetBehaviors.get(behavior) + 1);\n        } else {\n          targetBehaviors.set(behavior, 1);\n          behaviorsToBind.push(behavior);\n        }\n      }\n\n      if (this._isConnected) {\n        var element = this.element;\n\n        for (var _i = 0; _i < behaviorsToBind.length; ++_i) {\n          behaviorsToBind[_i].bind(element, defaultExecutionContext);\n        }\n      }\n    }\n    /**\n     * Removes behaviors from this element.\n     * @param behaviors - The behaviors to remove.\n     * @param force - Forces unbinding of behaviors.\n     */\n\n  }, {\n    key: \"removeBehaviors\",\n    value: function removeBehaviors(behaviors) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var targetBehaviors = this.behaviors;\n\n      if (targetBehaviors === null) {\n        return;\n      }\n\n      var length = behaviors.length;\n      var behaviorsToUnbind = [];\n\n      for (var i = 0; i < length; ++i) {\n        var behavior = behaviors[i];\n\n        if (targetBehaviors.has(behavior)) {\n          var count = targetBehaviors.get(behavior) - 1;\n          count === 0 || force ? targetBehaviors.delete(behavior) && behaviorsToUnbind.push(behavior) : targetBehaviors.set(behavior, count);\n        }\n      }\n\n      if (this._isConnected) {\n        var element = this.element;\n\n        for (var _i2 = 0; _i2 < behaviorsToUnbind.length; ++_i2) {\n          behaviorsToUnbind[_i2].unbind(element);\n        }\n      }\n    }\n    /**\n     * Runs connected lifecycle behavior on the associated element.\n     */\n\n  }, {\n    key: \"onConnectedCallback\",\n    value: function onConnectedCallback() {\n      if (this._isConnected) {\n        return;\n      }\n\n      var element = this.element;\n\n      if (this.needsInitialization) {\n        this.finishInitialization();\n      } else if (this.view !== null) {\n        this.view.bind(element, defaultExecutionContext);\n      }\n\n      var behaviors = this.behaviors;\n\n      if (behaviors !== null) {\n        var _iterator = _createForOfIteratorHelper(behaviors),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 1),\n                behavior = _step$value[0];\n\n            behavior.bind(element, defaultExecutionContext);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      this.setIsConnected(true);\n    }\n    /**\n     * Runs disconnected lifecycle behavior on the associated element.\n     */\n\n  }, {\n    key: \"onDisconnectedCallback\",\n    value: function onDisconnectedCallback() {\n      if (!this._isConnected) {\n        return;\n      }\n\n      this.setIsConnected(false);\n      var view = this.view;\n\n      if (view !== null) {\n        view.unbind();\n      }\n\n      var behaviors = this.behaviors;\n\n      if (behaviors !== null) {\n        var element = this.element;\n\n        var _iterator2 = _createForOfIteratorHelper(behaviors),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = _slicedToArray(_step2.value, 1),\n                behavior = _step2$value[0];\n\n            behavior.unbind(element);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n    /**\n     * Runs the attribute changed callback for the associated element.\n     * @param name - The name of the attribute that changed.\n     * @param oldValue - The previous value of the attribute.\n     * @param newValue - The new value of the attribute.\n     */\n\n  }, {\n    key: \"onAttributeChangedCallback\",\n    value: function onAttributeChangedCallback(name, oldValue, newValue) {\n      var attrDef = this.definition.attributeLookup[name];\n\n      if (attrDef !== void 0) {\n        attrDef.onAttributeChangedCallback(this.element, newValue);\n      }\n    }\n    /**\n     * Emits a custom HTML event.\n     * @param type - The type name of the event.\n     * @param detail - The event detail object to send with the event.\n     * @param options - The event options. By default bubbles and composed.\n     * @remarks\n     * Only emits events if connected.\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(type, detail, options) {\n      if (this._isConnected) {\n        return this.element.dispatchEvent(new CustomEvent(type, Object.assign(Object.assign({\n          detail: detail\n        }, defaultEventOptions), options)));\n      }\n\n      return false;\n    }\n  }, {\n    key: \"finishInitialization\",\n    value: function finishInitialization() {\n      var element = this.element;\n      var boundObservables = this.boundObservables; // If we have any observables that were bound, re-apply their values.\n\n      if (boundObservables !== null) {\n        var propertyNames = Object.keys(boundObservables);\n\n        for (var i = 0, ii = propertyNames.length; i < ii; ++i) {\n          var propertyName = propertyNames[i];\n          element[propertyName] = boundObservables[propertyName];\n        }\n\n        this.boundObservables = null;\n      }\n\n      var definition = this.definition; // 1. Template overrides take top precedence.\n\n      if (this._template === null) {\n        if (this.element.resolveTemplate) {\n          // 2. Allow for element instance overrides next.\n          this._template = this.element.resolveTemplate();\n        } else if (definition.template) {\n          // 3. Default to the static definition.\n          this._template = definition.template || null;\n        }\n      } // If we have a template after the above process, render it.\n      // If there's no template, then the element author has opted into\n      // custom rendering and they will managed the shadow root's content themselves.\n\n\n      if (this._template !== null) {\n        this.renderTemplate(this._template);\n      } // 1. Styles overrides take top precedence.\n\n\n      if (this._styles === null) {\n        if (this.element.resolveStyles) {\n          // 2. Allow for element instance overrides next.\n          this._styles = this.element.resolveStyles();\n        } else if (definition.styles) {\n          // 3. Default to the static definition.\n          this._styles = definition.styles || null;\n        }\n      } // If we have styles after the above process, add them.\n\n\n      if (this._styles !== null) {\n        this.addStyles(this._styles);\n      }\n\n      this.needsInitialization = false;\n    }\n  }, {\n    key: \"renderTemplate\",\n    value: function renderTemplate(template) {\n      var element = this.element; // When getting the host to render to, we start by looking\n      // up the shadow root. If there isn't one, then that means\n      // we're doing a Light DOM render to the element's direct children.\n\n      var host = getShadowRoot(element) || element;\n\n      if (this.view !== null) {\n        // If there's already a view, we need to unbind and remove through dispose.\n        this.view.dispose();\n        this.view = null;\n      } else if (!this.needsInitialization) {\n        // If there was previous custom rendering, we need to clear out the host.\n        DOM.removeChildNodes(host);\n      }\n\n      if (template) {\n        // If a new template was provided, render it.\n        this.view = template.render(element, host, element);\n      }\n    }\n    /**\n     * Locates or creates a controller for the specified element.\n     * @param element - The element to return the controller for.\n     * @remarks\n     * The specified element must have a {@link FASTElementDefinition}\n     * registered either through the use of the {@link customElement}\n     * decorator or a call to `FASTElement.define`.\n     */\n\n  }], [{\n    key: \"forCustomElement\",\n    value: function forCustomElement(element) {\n      var controller = element.$fastController;\n\n      if (controller !== void 0) {\n        return controller;\n      }\n\n      var definition = FASTElementDefinition.forType(element.constructor);\n\n      if (definition === void 0) {\n        throw new Error(\"Missing FASTElement definition.\");\n      }\n\n      return element.$fastController = new Controller(element, definition);\n    }\n  }]);\n\n  return Controller;\n}(PropertyChangeNotifier);","map":{"version":3,"names":["DOM","PropertyChangeNotifier","defaultExecutionContext","Observable","FASTElementDefinition","shadowRoots","WeakMap","defaultEventOptions","bubbles","composed","cancelable","getShadowRoot","element","shadowRoot","get","Controller","definition","boundObservables","behaviors","needsInitialization","_template","_styles","_isConnected","$fastController","view","shadowOptions","attachShadow","mode","set","accessors","getAccessors","length","Object","create","i","ii","propertyName","name","value","track","notify","renderTemplate","removeStyles","addStyles","styles","target","getRootNode","HTMLStyleElement","append","isAttachedTo","sourceBehaviors","addStylesTo","addBehaviors","removeChild","removeStylesFrom","removeBehaviors","targetBehaviors","Map","behaviorsToBind","behavior","has","push","bind","force","behaviorsToUnbind","count","delete","unbind","finishInitialization","setIsConnected","oldValue","newValue","attrDef","attributeLookup","onAttributeChangedCallback","type","detail","options","dispatchEvent","CustomEvent","assign","propertyNames","keys","resolveTemplate","template","resolveStyles","host","dispose","removeChildNodes","render","controller","forType","constructor","Error"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-element/dist/esm/components/controller.js"],"sourcesContent":["import { DOM } from \"../dom.js\";\nimport { PropertyChangeNotifier } from \"../observation/notifier.js\";\nimport { defaultExecutionContext, Observable } from \"../observation/observable.js\";\nimport { FASTElementDefinition } from \"./fast-definitions.js\";\nconst shadowRoots = new WeakMap();\nconst defaultEventOptions = {\n    bubbles: true,\n    composed: true,\n    cancelable: true,\n};\nfunction getShadowRoot(element) {\n    return element.shadowRoot || shadowRoots.get(element) || null;\n}\n/**\n * Controls the lifecycle and rendering of a `FASTElement`.\n * @public\n */\nexport class Controller extends PropertyChangeNotifier {\n    /**\n     * Creates a Controller to control the specified element.\n     * @param element - The element to be controlled by this controller.\n     * @param definition - The element definition metadata that instructs this\n     * controller in how to handle rendering and other platform integrations.\n     * @internal\n     */\n    constructor(element, definition) {\n        super(element);\n        this.boundObservables = null;\n        this.behaviors = null;\n        this.needsInitialization = true;\n        this._template = null;\n        this._styles = null;\n        this._isConnected = false;\n        /**\n         * This allows Observable.getNotifier(...) to return the Controller\n         * when the notifier for the Controller itself is being requested. The\n         * result is that the Observable system does not need to create a separate\n         * instance of Notifier for observables on the Controller. The component and\n         * the controller will now share the same notifier, removing one-object construct\n         * per web component instance.\n         */\n        this.$fastController = this;\n        /**\n         * The view associated with the custom element.\n         * @remarks\n         * If `null` then the element is managing its own rendering.\n         */\n        this.view = null;\n        this.element = element;\n        this.definition = definition;\n        const shadowOptions = definition.shadowOptions;\n        if (shadowOptions !== void 0) {\n            const shadowRoot = element.attachShadow(shadowOptions);\n            if (shadowOptions.mode === \"closed\") {\n                shadowRoots.set(element, shadowRoot);\n            }\n        }\n        // Capture any observable values that were set by the binding engine before\n        // the browser upgraded the element. Then delete the property since it will\n        // shadow the getter/setter that is required to make the observable operate.\n        // Later, in the connect callback, we'll re-apply the values.\n        const accessors = Observable.getAccessors(element);\n        if (accessors.length > 0) {\n            const boundObservables = (this.boundObservables = Object.create(null));\n            for (let i = 0, ii = accessors.length; i < ii; ++i) {\n                const propertyName = accessors[i].name;\n                const value = element[propertyName];\n                if (value !== void 0) {\n                    delete element[propertyName];\n                    boundObservables[propertyName] = value;\n                }\n            }\n        }\n    }\n    /**\n     * Indicates whether or not the custom element has been\n     * connected to the document.\n     */\n    get isConnected() {\n        Observable.track(this, \"isConnected\");\n        return this._isConnected;\n    }\n    setIsConnected(value) {\n        this._isConnected = value;\n        Observable.notify(this, \"isConnected\");\n    }\n    /**\n     * Gets/sets the template used to render the component.\n     * @remarks\n     * This value can only be accurately read after connect but can be set at any time.\n     */\n    get template() {\n        return this._template;\n    }\n    set template(value) {\n        if (this._template === value) {\n            return;\n        }\n        this._template = value;\n        if (!this.needsInitialization) {\n            this.renderTemplate(value);\n        }\n    }\n    /**\n     * Gets/sets the primary styles used for the component.\n     * @remarks\n     * This value can only be accurately read after connect but can be set at any time.\n     */\n    get styles() {\n        return this._styles;\n    }\n    set styles(value) {\n        if (this._styles === value) {\n            return;\n        }\n        if (this._styles !== null) {\n            this.removeStyles(this._styles);\n        }\n        this._styles = value;\n        if (!this.needsInitialization && value !== null) {\n            this.addStyles(value);\n        }\n    }\n    /**\n     * Adds styles to this element. Providing an HTMLStyleElement will attach the element instance to the shadowRoot.\n     * @param styles - The styles to add.\n     */\n    addStyles(styles) {\n        const target = getShadowRoot(this.element) ||\n            this.element.getRootNode();\n        if (styles instanceof HTMLStyleElement) {\n            target.append(styles);\n        }\n        else if (!styles.isAttachedTo(target)) {\n            const sourceBehaviors = styles.behaviors;\n            styles.addStylesTo(target);\n            if (sourceBehaviors !== null) {\n                this.addBehaviors(sourceBehaviors);\n            }\n        }\n    }\n    /**\n     * Removes styles from this element. Providing an HTMLStyleElement will detach the element instance from the shadowRoot.\n     * @param styles - the styles to remove.\n     */\n    removeStyles(styles) {\n        const target = getShadowRoot(this.element) ||\n            this.element.getRootNode();\n        if (styles instanceof HTMLStyleElement) {\n            target.removeChild(styles);\n        }\n        else if (styles.isAttachedTo(target)) {\n            const sourceBehaviors = styles.behaviors;\n            styles.removeStylesFrom(target);\n            if (sourceBehaviors !== null) {\n                this.removeBehaviors(sourceBehaviors);\n            }\n        }\n    }\n    /**\n     * Adds behaviors to this element.\n     * @param behaviors - The behaviors to add.\n     */\n    addBehaviors(behaviors) {\n        const targetBehaviors = this.behaviors || (this.behaviors = new Map());\n        const length = behaviors.length;\n        const behaviorsToBind = [];\n        for (let i = 0; i < length; ++i) {\n            const behavior = behaviors[i];\n            if (targetBehaviors.has(behavior)) {\n                targetBehaviors.set(behavior, targetBehaviors.get(behavior) + 1);\n            }\n            else {\n                targetBehaviors.set(behavior, 1);\n                behaviorsToBind.push(behavior);\n            }\n        }\n        if (this._isConnected) {\n            const element = this.element;\n            for (let i = 0; i < behaviorsToBind.length; ++i) {\n                behaviorsToBind[i].bind(element, defaultExecutionContext);\n            }\n        }\n    }\n    /**\n     * Removes behaviors from this element.\n     * @param behaviors - The behaviors to remove.\n     * @param force - Forces unbinding of behaviors.\n     */\n    removeBehaviors(behaviors, force = false) {\n        const targetBehaviors = this.behaviors;\n        if (targetBehaviors === null) {\n            return;\n        }\n        const length = behaviors.length;\n        const behaviorsToUnbind = [];\n        for (let i = 0; i < length; ++i) {\n            const behavior = behaviors[i];\n            if (targetBehaviors.has(behavior)) {\n                const count = targetBehaviors.get(behavior) - 1;\n                count === 0 || force\n                    ? targetBehaviors.delete(behavior) && behaviorsToUnbind.push(behavior)\n                    : targetBehaviors.set(behavior, count);\n            }\n        }\n        if (this._isConnected) {\n            const element = this.element;\n            for (let i = 0; i < behaviorsToUnbind.length; ++i) {\n                behaviorsToUnbind[i].unbind(element);\n            }\n        }\n    }\n    /**\n     * Runs connected lifecycle behavior on the associated element.\n     */\n    onConnectedCallback() {\n        if (this._isConnected) {\n            return;\n        }\n        const element = this.element;\n        if (this.needsInitialization) {\n            this.finishInitialization();\n        }\n        else if (this.view !== null) {\n            this.view.bind(element, defaultExecutionContext);\n        }\n        const behaviors = this.behaviors;\n        if (behaviors !== null) {\n            for (const [behavior] of behaviors) {\n                behavior.bind(element, defaultExecutionContext);\n            }\n        }\n        this.setIsConnected(true);\n    }\n    /**\n     * Runs disconnected lifecycle behavior on the associated element.\n     */\n    onDisconnectedCallback() {\n        if (!this._isConnected) {\n            return;\n        }\n        this.setIsConnected(false);\n        const view = this.view;\n        if (view !== null) {\n            view.unbind();\n        }\n        const behaviors = this.behaviors;\n        if (behaviors !== null) {\n            const element = this.element;\n            for (const [behavior] of behaviors) {\n                behavior.unbind(element);\n            }\n        }\n    }\n    /**\n     * Runs the attribute changed callback for the associated element.\n     * @param name - The name of the attribute that changed.\n     * @param oldValue - The previous value of the attribute.\n     * @param newValue - The new value of the attribute.\n     */\n    onAttributeChangedCallback(name, oldValue, newValue) {\n        const attrDef = this.definition.attributeLookup[name];\n        if (attrDef !== void 0) {\n            attrDef.onAttributeChangedCallback(this.element, newValue);\n        }\n    }\n    /**\n     * Emits a custom HTML event.\n     * @param type - The type name of the event.\n     * @param detail - The event detail object to send with the event.\n     * @param options - The event options. By default bubbles and composed.\n     * @remarks\n     * Only emits events if connected.\n     */\n    emit(type, detail, options) {\n        if (this._isConnected) {\n            return this.element.dispatchEvent(new CustomEvent(type, Object.assign(Object.assign({ detail }, defaultEventOptions), options)));\n        }\n        return false;\n    }\n    finishInitialization() {\n        const element = this.element;\n        const boundObservables = this.boundObservables;\n        // If we have any observables that were bound, re-apply their values.\n        if (boundObservables !== null) {\n            const propertyNames = Object.keys(boundObservables);\n            for (let i = 0, ii = propertyNames.length; i < ii; ++i) {\n                const propertyName = propertyNames[i];\n                element[propertyName] = boundObservables[propertyName];\n            }\n            this.boundObservables = null;\n        }\n        const definition = this.definition;\n        // 1. Template overrides take top precedence.\n        if (this._template === null) {\n            if (this.element.resolveTemplate) {\n                // 2. Allow for element instance overrides next.\n                this._template = this.element.resolveTemplate();\n            }\n            else if (definition.template) {\n                // 3. Default to the static definition.\n                this._template = definition.template || null;\n            }\n        }\n        // If we have a template after the above process, render it.\n        // If there's no template, then the element author has opted into\n        // custom rendering and they will managed the shadow root's content themselves.\n        if (this._template !== null) {\n            this.renderTemplate(this._template);\n        }\n        // 1. Styles overrides take top precedence.\n        if (this._styles === null) {\n            if (this.element.resolveStyles) {\n                // 2. Allow for element instance overrides next.\n                this._styles = this.element.resolveStyles();\n            }\n            else if (definition.styles) {\n                // 3. Default to the static definition.\n                this._styles = definition.styles || null;\n            }\n        }\n        // If we have styles after the above process, add them.\n        if (this._styles !== null) {\n            this.addStyles(this._styles);\n        }\n        this.needsInitialization = false;\n    }\n    renderTemplate(template) {\n        const element = this.element;\n        // When getting the host to render to, we start by looking\n        // up the shadow root. If there isn't one, then that means\n        // we're doing a Light DOM render to the element's direct children.\n        const host = getShadowRoot(element) || element;\n        if (this.view !== null) {\n            // If there's already a view, we need to unbind and remove through dispose.\n            this.view.dispose();\n            this.view = null;\n        }\n        else if (!this.needsInitialization) {\n            // If there was previous custom rendering, we need to clear out the host.\n            DOM.removeChildNodes(host);\n        }\n        if (template) {\n            // If a new template was provided, render it.\n            this.view = template.render(element, host, element);\n        }\n    }\n    /**\n     * Locates or creates a controller for the specified element.\n     * @param element - The element to return the controller for.\n     * @remarks\n     * The specified element must have a {@link FASTElementDefinition}\n     * registered either through the use of the {@link customElement}\n     * decorator or a call to `FASTElement.define`.\n     */\n    static forCustomElement(element) {\n        const controller = element.$fastController;\n        if (controller !== void 0) {\n            return controller;\n        }\n        const definition = FASTElementDefinition.forType(element.constructor);\n        if (definition === void 0) {\n            throw new Error(\"Missing FASTElement definition.\");\n        }\n        return (element.$fastController = new Controller(element, definition));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}