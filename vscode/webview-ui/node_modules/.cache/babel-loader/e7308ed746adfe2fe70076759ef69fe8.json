{"ast":null,"code":"import _classCallCheck from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { attr, booleanConverter, DOM, emptyArray, observable } from \"@microsoft/fast-element\";\nimport { keyEnter } from \"@microsoft/fast-web-utilities\";\nvar proxySlotName = \"form-associated-proxy\";\nvar ElementInternalsKey = \"ElementInternals\";\n/**\n * @alpha\n */\n\nexport var supportsElementInternals = ElementInternalsKey in window && \"setFormValue\" in window[ElementInternalsKey].prototype;\nvar InternalsMap = new WeakMap();\n/**\n * Base function for providing Custom Element Form Association.\n *\n * @alpha\n */\n\nexport function FormAssociated(BaseCtor) {\n  var C = /*#__PURE__*/function (_BaseCtor) {\n    _inherits(C, _BaseCtor);\n\n    var _super = _createSuper(C);\n\n    function C() {\n      var _this;\n\n      _classCallCheck(this, C);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _super.call.apply(_super, [this].concat(args));\n      /**\n       * Track whether the value has been changed from the initial value\n       */\n\n      _this.dirtyValue = false;\n      /**\n       * Sets the element's disabled state. A disabled element will not be included during form submission.\n       *\n       * @remarks\n       * HTML Attribute: disabled\n       */\n\n      _this.disabled = false;\n      /**\n       * These are events that are still fired by the proxy\n       * element based on user / programmatic interaction.\n       *\n       * The proxy implementation should be transparent to\n       * the app author, so block these events from emitting.\n       */\n\n      _this.proxyEventsToBlock = [\"change\", \"click\"];\n      _this.proxyInitialized = false;\n      _this.required = false;\n      _this.initialValue = _this.initialValue || \"\";\n\n      if (!_this.elementInternals) {\n        // When elementInternals is not supported, formResetCallback is\n        // bound to an event listener, so ensure the handler's `this`\n        // context is correct.\n        _this.formResetCallback = _this.formResetCallback.bind(_assertThisInitialized(_this));\n      }\n\n      return _this;\n    }\n    /**\n     * Must evaluate to true to enable elementInternals.\n     * Feature detects API support and resolve respectively\n     *\n     * @internal\n     */\n\n\n    _createClass(C, [{\n      key: \"validity\",\n      get:\n      /**\n       * Returns the validity state of the element\n       *\n       * @alpha\n       */\n      function get() {\n        return this.elementInternals ? this.elementInternals.validity : this.proxy.validity;\n      }\n      /**\n       * Retrieve a reference to the associated form.\n       * Returns null if not associated to any form.\n       *\n       * @alpha\n       */\n\n    }, {\n      key: \"form\",\n      get: function get() {\n        return this.elementInternals ? this.elementInternals.form : this.proxy.form;\n      }\n      /**\n       * Retrieve the localized validation message,\n       * or custom validation message if set.\n       *\n       * @alpha\n       */\n\n    }, {\n      key: \"validationMessage\",\n      get: function get() {\n        return this.elementInternals ? this.elementInternals.validationMessage : this.proxy.validationMessage;\n      }\n      /**\n       * Whether the element will be validated when the\n       * form is submitted\n       */\n\n    }, {\n      key: \"willValidate\",\n      get: function get() {\n        return this.elementInternals ? this.elementInternals.willValidate : this.proxy.willValidate;\n      }\n      /**\n       * A reference to all associated label elements\n       */\n\n    }, {\n      key: \"labels\",\n      get: function get() {\n        if (this.elementInternals) {\n          return Object.freeze(Array.from(this.elementInternals.labels));\n        } else if (this.proxy instanceof HTMLElement && this.proxy.ownerDocument && this.id) {\n          // Labels associated by wrapping the element: <label><custom-element></custom-element></label>\n          var parentLabels = this.proxy.labels; // Labels associated using the `for` attribute\n\n          var forLabels = Array.from(this.proxy.getRootNode().querySelectorAll(\"[for='\".concat(this.id, \"']\")));\n          var labels = parentLabels ? forLabels.concat(Array.from(parentLabels)) : forLabels;\n          return Object.freeze(labels);\n        } else {\n          return emptyArray;\n        }\n      }\n      /**\n       * Invoked when the `value` property changes\n       * @param previous - the previous value\n       * @param next - the new value\n       *\n       * @remarks\n       * If elements extending `FormAssociated` implement a `valueChanged` method\n       * They must be sure to invoke `super.valueChanged(previous, next)` to ensure\n       * proper functioning of `FormAssociated`\n       */\n\n    }, {\n      key: \"valueChanged\",\n      value: function valueChanged(previous, next) {\n        this.dirtyValue = true;\n\n        if (this.proxy instanceof HTMLElement) {\n          this.proxy.value = this.value;\n        }\n\n        this.currentValue = this.value;\n        this.setFormValue(this.value);\n        this.validate();\n      }\n    }, {\n      key: \"currentValueChanged\",\n      value: function currentValueChanged() {\n        this.value = this.currentValue;\n      }\n      /**\n       * Invoked when the `initialValue` property changes\n       *\n       * @param previous - the previous value\n       * @param next - the new value\n       *\n       * @remarks\n       * If elements extending `FormAssociated` implement a `initialValueChanged` method\n       * They must be sure to invoke `super.initialValueChanged(previous, next)` to ensure\n       * proper functioning of `FormAssociated`\n       */\n\n    }, {\n      key: \"initialValueChanged\",\n      value: function initialValueChanged(previous, next) {\n        // If the value is clean and the component is connected to the DOM\n        // then set value equal to the attribute value.\n        if (!this.dirtyValue) {\n          this.value = this.initialValue;\n          this.dirtyValue = false;\n        }\n      }\n      /**\n       * Invoked when the `disabled` property changes\n       *\n       * @param previous - the previous value\n       * @param next - the new value\n       *\n       * @remarks\n       * If elements extending `FormAssociated` implement a `disabledChanged` method\n       * They must be sure to invoke `super.disabledChanged(previous, next)` to ensure\n       * proper functioning of `FormAssociated`\n       */\n\n    }, {\n      key: \"disabledChanged\",\n      value: function disabledChanged(previous, next) {\n        var _this2 = this;\n\n        if (this.proxy instanceof HTMLElement) {\n          this.proxy.disabled = this.disabled;\n        }\n\n        DOM.queueUpdate(function () {\n          return _this2.classList.toggle(\"disabled\", _this2.disabled);\n        });\n      }\n      /**\n       * Invoked when the `name` property changes\n       *\n       * @param previous - the previous value\n       * @param next - the new value\n       *\n       * @remarks\n       * If elements extending `FormAssociated` implement a `nameChanged` method\n       * They must be sure to invoke `super.nameChanged(previous, next)` to ensure\n       * proper functioning of `FormAssociated`\n       */\n\n    }, {\n      key: \"nameChanged\",\n      value: function nameChanged(previous, next) {\n        if (this.proxy instanceof HTMLElement) {\n          this.proxy.name = this.name;\n        }\n      }\n      /**\n       * Invoked when the `required` property changes\n       *\n       * @param previous - the previous value\n       * @param next - the new value\n       *\n       * @remarks\n       * If elements extending `FormAssociated` implement a `requiredChanged` method\n       * They must be sure to invoke `super.requiredChanged(previous, next)` to ensure\n       * proper functioning of `FormAssociated`\n       */\n\n    }, {\n      key: \"requiredChanged\",\n      value: function requiredChanged(prev, next) {\n        var _this3 = this;\n\n        if (this.proxy instanceof HTMLElement) {\n          this.proxy.required = this.required;\n        }\n\n        DOM.queueUpdate(function () {\n          return _this3.classList.toggle(\"required\", _this3.required);\n        });\n        this.validate();\n      }\n      /**\n       * The element internals object. Will only exist\n       * in browsers supporting the attachInternals API\n       */\n\n    }, {\n      key: \"elementInternals\",\n      get: function get() {\n        if (!supportsElementInternals) {\n          return null;\n        }\n\n        var internals = InternalsMap.get(this);\n\n        if (!internals) {\n          internals = this.attachInternals();\n          InternalsMap.set(this, internals);\n        }\n\n        return internals;\n      }\n      /**\n       * @internal\n       */\n\n    }, {\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(C.prototype), \"connectedCallback\", this).call(this);\n\n        this.addEventListener(\"keypress\", this._keypressHandler);\n\n        if (!this.value) {\n          this.value = this.initialValue;\n          this.dirtyValue = false;\n        }\n\n        if (!this.elementInternals) {\n          this.attachProxy();\n\n          if (this.form) {\n            this.form.addEventListener(\"reset\", this.formResetCallback);\n          }\n        }\n      }\n      /**\n       * @internal\n       */\n\n    }, {\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        var _this4 = this;\n\n        this.proxyEventsToBlock.forEach(function (name) {\n          return _this4.proxy.removeEventListener(name, _this4.stopPropagation);\n        });\n\n        if (!this.elementInternals && this.form) {\n          this.form.removeEventListener(\"reset\", this.formResetCallback);\n        }\n      }\n      /**\n       * Return the current validity of the element.\n       */\n\n    }, {\n      key: \"checkValidity\",\n      value: function checkValidity() {\n        return this.elementInternals ? this.elementInternals.checkValidity() : this.proxy.checkValidity();\n      }\n      /**\n       * Return the current validity of the element.\n       * If false, fires an invalid event at the element.\n       */\n\n    }, {\n      key: \"reportValidity\",\n      value: function reportValidity() {\n        return this.elementInternals ? this.elementInternals.reportValidity() : this.proxy.reportValidity();\n      }\n      /**\n       * Set the validity of the control. In cases when the elementInternals object is not\n       * available (and the proxy element is used to report validity), this function will\n       * do nothing unless a message is provided, at which point the setCustomValidity method\n       * of the proxy element will be invoked with the provided message.\n       * @param flags - Validity flags\n       * @param message - Optional message to supply\n       * @param anchor - Optional element used by UA to display an interactive validation UI\n       */\n\n    }, {\n      key: \"setValidity\",\n      value: function setValidity(flags, message, anchor) {\n        if (this.elementInternals) {\n          this.elementInternals.setValidity(flags, message, anchor);\n        } else if (typeof message === \"string\") {\n          this.proxy.setCustomValidity(message);\n        }\n      }\n      /**\n       * Invoked when a connected component's form or fieldset has its disabled\n       * state changed.\n       * @param disabled - the disabled value of the form / fieldset\n       */\n\n    }, {\n      key: \"formDisabledCallback\",\n      value: function formDisabledCallback(disabled) {\n        this.disabled = disabled;\n      }\n    }, {\n      key: \"formResetCallback\",\n      value: function formResetCallback() {\n        this.value = this.initialValue;\n        this.dirtyValue = false;\n      }\n      /**\n       * Attach the proxy element to the DOM\n       */\n\n    }, {\n      key: \"attachProxy\",\n      value: function attachProxy() {\n        var _this5 = this;\n\n        var _a;\n\n        if (!this.proxyInitialized) {\n          this.proxyInitialized = true;\n          this.proxy.style.display = \"none\";\n          this.proxyEventsToBlock.forEach(function (name) {\n            return _this5.proxy.addEventListener(name, _this5.stopPropagation);\n          }); // These are typically mapped to the proxy during\n          // property change callbacks, but during initialization\n          // on the initial call of the callback, the proxy is\n          // still undefined. We should find a better way to address this.\n\n          this.proxy.disabled = this.disabled;\n          this.proxy.required = this.required;\n\n          if (typeof this.name === \"string\") {\n            this.proxy.name = this.name;\n          }\n\n          if (typeof this.value === \"string\") {\n            this.proxy.value = this.value;\n          }\n\n          this.proxy.setAttribute(\"slot\", proxySlotName);\n          this.proxySlot = document.createElement(\"slot\");\n          this.proxySlot.setAttribute(\"name\", proxySlotName);\n        }\n\n        (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.appendChild(this.proxySlot);\n        this.appendChild(this.proxy);\n      }\n      /**\n       * Detach the proxy element from the DOM\n       */\n\n    }, {\n      key: \"detachProxy\",\n      value: function detachProxy() {\n        var _a;\n\n        this.removeChild(this.proxy);\n        (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.removeChild(this.proxySlot);\n      }\n      /** {@inheritDoc (FormAssociated:interface).validate} */\n\n    }, {\n      key: \"validate\",\n      value: function validate(anchor) {\n        if (this.proxy instanceof HTMLElement) {\n          this.setValidity(this.proxy.validity, this.proxy.validationMessage, anchor);\n        }\n      }\n      /**\n       * Associates the provided value (and optional state) with the parent form.\n       * @param value - The value to set\n       * @param state - The state object provided to during session restores and when autofilling.\n       */\n\n    }, {\n      key: \"setFormValue\",\n      value: function setFormValue(value, state) {\n        if (this.elementInternals) {\n          this.elementInternals.setFormValue(value, state || value);\n        }\n      }\n    }, {\n      key: \"_keypressHandler\",\n      value: function _keypressHandler(e) {\n        switch (e.key) {\n          case keyEnter:\n            if (this.form instanceof HTMLFormElement) {\n              // Implicit submission\n              var defaultButton = this.form.querySelector(\"[type=submit]\");\n              defaultButton === null || defaultButton === void 0 ? void 0 : defaultButton.click();\n            }\n\n            break;\n        }\n      }\n      /**\n       * Used to stop propagation of proxy element events\n       * @param e - Event object\n       */\n\n    }, {\n      key: \"stopPropagation\",\n      value: function stopPropagation(e) {\n        e.stopPropagation();\n      }\n    }], [{\n      key: \"formAssociated\",\n      get: function get() {\n        return supportsElementInternals;\n      }\n    }]);\n\n    return C;\n  }(BaseCtor);\n\n  attr({\n    mode: \"boolean\"\n  })(C.prototype, \"disabled\");\n  attr({\n    mode: \"fromView\",\n    attribute: \"value\"\n  })(C.prototype, \"initialValue\");\n  attr({\n    attribute: \"current-value\"\n  })(C.prototype, \"currentValue\");\n  attr(C.prototype, \"name\");\n  attr({\n    mode: \"boolean\"\n  })(C.prototype, \"required\");\n  observable(C.prototype, \"value\");\n  return C;\n}\n/**\n * @alpha\n */\n\nexport function CheckableFormAssociated(BaseCtor) {\n  var C = /*#__PURE__*/function (_FormAssociated) {\n    _inherits(C, _FormAssociated);\n\n    var _super2 = _createSuper(C);\n\n    function C() {\n      _classCallCheck(this, C);\n\n      return _super2.apply(this, arguments);\n    }\n\n    return C;\n  }(FormAssociated(BaseCtor));\n\n  var D = /*#__PURE__*/function (_C) {\n    _inherits(D, _C);\n\n    var _super3 = _createSuper(D);\n\n    function D() {\n      var _this6;\n\n      _classCallCheck(this, D);\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this6 = _super3.call(this, args);\n      /**\n       * Tracks whether the \"checked\" property has been changed.\n       * This is necessary to provide consistent behavior with\n       * normal input checkboxes\n       */\n\n      _this6.dirtyChecked = false;\n      /**\n       * Provides the default checkedness of the input element\n       * Passed down to proxy\n       *\n       * @public\n       * @remarks\n       * HTML Attribute: checked\n       */\n\n      _this6.checkedAttribute = false;\n      /**\n       * The checked state of the control.\n       *\n       * @public\n       */\n\n      _this6.checked = false; // Re-initialize dirtyChecked because initialization of other values\n      // causes it to become true\n\n      _this6.dirtyChecked = false;\n      return _this6;\n    }\n\n    _createClass(D, [{\n      key: \"checkedAttributeChanged\",\n      value: function checkedAttributeChanged() {\n        this.defaultChecked = this.checkedAttribute;\n      }\n      /**\n       * @internal\n       */\n\n    }, {\n      key: \"defaultCheckedChanged\",\n      value: function defaultCheckedChanged() {\n        if (!this.dirtyChecked) {\n          // Setting this.checked will cause us to enter a dirty state,\n          // but if we are clean when defaultChecked is changed, we want to stay\n          // in a clean state, so reset this.dirtyChecked\n          this.checked = this.defaultChecked;\n          this.dirtyChecked = false;\n        }\n      }\n    }, {\n      key: \"checkedChanged\",\n      value: function checkedChanged(prev, next) {\n        if (!this.dirtyChecked) {\n          this.dirtyChecked = true;\n        }\n\n        this.currentChecked = this.checked;\n        this.updateForm();\n\n        if (this.proxy instanceof HTMLInputElement) {\n          this.proxy.checked = this.checked;\n        }\n\n        if (prev !== undefined) {\n          this.$emit(\"change\");\n        }\n\n        this.validate();\n      }\n    }, {\n      key: \"currentCheckedChanged\",\n      value: function currentCheckedChanged(prev, next) {\n        this.checked = this.currentChecked;\n      }\n    }, {\n      key: \"updateForm\",\n      value: function updateForm() {\n        var value = this.checked ? this.value : null;\n        this.setFormValue(value, value);\n      }\n    }, {\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(D.prototype), \"connectedCallback\", this).call(this);\n\n        this.updateForm();\n      }\n    }, {\n      key: \"formResetCallback\",\n      value: function formResetCallback() {\n        _get(_getPrototypeOf(D.prototype), \"formResetCallback\", this).call(this);\n\n        this.checked = !!this.checkedAttribute;\n        this.dirtyChecked = false;\n      }\n    }]);\n\n    return D;\n  }(C);\n\n  attr({\n    attribute: \"checked\",\n    mode: \"boolean\"\n  })(D.prototype, \"checkedAttribute\");\n  attr({\n    attribute: \"current-checked\",\n    converter: booleanConverter\n  })(D.prototype, \"currentChecked\");\n  observable(D.prototype, \"defaultChecked\");\n  observable(D.prototype, \"checked\");\n  return D;\n}","map":{"version":3,"names":["attr","booleanConverter","DOM","emptyArray","observable","keyEnter","proxySlotName","ElementInternalsKey","supportsElementInternals","window","prototype","InternalsMap","WeakMap","FormAssociated","BaseCtor","C","args","dirtyValue","disabled","proxyEventsToBlock","proxyInitialized","required","initialValue","elementInternals","formResetCallback","bind","validity","proxy","form","validationMessage","willValidate","Object","freeze","Array","from","labels","HTMLElement","ownerDocument","id","parentLabels","forLabels","getRootNode","querySelectorAll","concat","previous","next","value","currentValue","setFormValue","validate","queueUpdate","classList","toggle","name","prev","internals","get","attachInternals","set","addEventListener","_keypressHandler","attachProxy","forEach","removeEventListener","stopPropagation","checkValidity","reportValidity","flags","message","anchor","setValidity","setCustomValidity","_a","style","display","setAttribute","proxySlot","document","createElement","shadowRoot","appendChild","removeChild","state","e","key","HTMLFormElement","defaultButton","querySelector","click","mode","attribute","CheckableFormAssociated","D","dirtyChecked","checkedAttribute","checked","defaultChecked","currentChecked","updateForm","HTMLInputElement","undefined","$emit","converter"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/form-associated/form-associated.js"],"sourcesContent":["import { attr, booleanConverter, DOM, emptyArray, observable, } from \"@microsoft/fast-element\";\nimport { keyEnter } from \"@microsoft/fast-web-utilities\";\nconst proxySlotName = \"form-associated-proxy\";\nconst ElementInternalsKey = \"ElementInternals\";\n/**\n * @alpha\n */\nexport const supportsElementInternals = ElementInternalsKey in window &&\n    \"setFormValue\" in window[ElementInternalsKey].prototype;\nconst InternalsMap = new WeakMap();\n/**\n * Base function for providing Custom Element Form Association.\n *\n * @alpha\n */\nexport function FormAssociated(BaseCtor) {\n    const C = class extends BaseCtor {\n        constructor(...args) {\n            super(...args);\n            /**\n             * Track whether the value has been changed from the initial value\n             */\n            this.dirtyValue = false;\n            /**\n             * Sets the element's disabled state. A disabled element will not be included during form submission.\n             *\n             * @remarks\n             * HTML Attribute: disabled\n             */\n            this.disabled = false;\n            /**\n             * These are events that are still fired by the proxy\n             * element based on user / programmatic interaction.\n             *\n             * The proxy implementation should be transparent to\n             * the app author, so block these events from emitting.\n             */\n            this.proxyEventsToBlock = [\"change\", \"click\"];\n            this.proxyInitialized = false;\n            this.required = false;\n            this.initialValue = this.initialValue || \"\";\n            if (!this.elementInternals) {\n                // When elementInternals is not supported, formResetCallback is\n                // bound to an event listener, so ensure the handler's `this`\n                // context is correct.\n                this.formResetCallback = this.formResetCallback.bind(this);\n            }\n        }\n        /**\n         * Must evaluate to true to enable elementInternals.\n         * Feature detects API support and resolve respectively\n         *\n         * @internal\n         */\n        static get formAssociated() {\n            return supportsElementInternals;\n        }\n        /**\n         * Returns the validity state of the element\n         *\n         * @alpha\n         */\n        get validity() {\n            return this.elementInternals\n                ? this.elementInternals.validity\n                : this.proxy.validity;\n        }\n        /**\n         * Retrieve a reference to the associated form.\n         * Returns null if not associated to any form.\n         *\n         * @alpha\n         */\n        get form() {\n            return this.elementInternals ? this.elementInternals.form : this.proxy.form;\n        }\n        /**\n         * Retrieve the localized validation message,\n         * or custom validation message if set.\n         *\n         * @alpha\n         */\n        get validationMessage() {\n            return this.elementInternals\n                ? this.elementInternals.validationMessage\n                : this.proxy.validationMessage;\n        }\n        /**\n         * Whether the element will be validated when the\n         * form is submitted\n         */\n        get willValidate() {\n            return this.elementInternals\n                ? this.elementInternals.willValidate\n                : this.proxy.willValidate;\n        }\n        /**\n         * A reference to all associated label elements\n         */\n        get labels() {\n            if (this.elementInternals) {\n                return Object.freeze(Array.from(this.elementInternals.labels));\n            }\n            else if (this.proxy instanceof HTMLElement &&\n                this.proxy.ownerDocument &&\n                this.id) {\n                // Labels associated by wrapping the element: <label><custom-element></custom-element></label>\n                const parentLabels = this.proxy.labels;\n                // Labels associated using the `for` attribute\n                const forLabels = Array.from(this.proxy.getRootNode().querySelectorAll(`[for='${this.id}']`));\n                const labels = parentLabels\n                    ? forLabels.concat(Array.from(parentLabels))\n                    : forLabels;\n                return Object.freeze(labels);\n            }\n            else {\n                return emptyArray;\n            }\n        }\n        /**\n         * Invoked when the `value` property changes\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `valueChanged` method\n         * They must be sure to invoke `super.valueChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        valueChanged(previous, next) {\n            this.dirtyValue = true;\n            if (this.proxy instanceof HTMLElement) {\n                this.proxy.value = this.value;\n            }\n            this.currentValue = this.value;\n            this.setFormValue(this.value);\n            this.validate();\n        }\n        currentValueChanged() {\n            this.value = this.currentValue;\n        }\n        /**\n         * Invoked when the `initialValue` property changes\n         *\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `initialValueChanged` method\n         * They must be sure to invoke `super.initialValueChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        initialValueChanged(previous, next) {\n            // If the value is clean and the component is connected to the DOM\n            // then set value equal to the attribute value.\n            if (!this.dirtyValue) {\n                this.value = this.initialValue;\n                this.dirtyValue = false;\n            }\n        }\n        /**\n         * Invoked when the `disabled` property changes\n         *\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `disabledChanged` method\n         * They must be sure to invoke `super.disabledChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        disabledChanged(previous, next) {\n            if (this.proxy instanceof HTMLElement) {\n                this.proxy.disabled = this.disabled;\n            }\n            DOM.queueUpdate(() => this.classList.toggle(\"disabled\", this.disabled));\n        }\n        /**\n         * Invoked when the `name` property changes\n         *\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `nameChanged` method\n         * They must be sure to invoke `super.nameChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        nameChanged(previous, next) {\n            if (this.proxy instanceof HTMLElement) {\n                this.proxy.name = this.name;\n            }\n        }\n        /**\n         * Invoked when the `required` property changes\n         *\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `requiredChanged` method\n         * They must be sure to invoke `super.requiredChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        requiredChanged(prev, next) {\n            if (this.proxy instanceof HTMLElement) {\n                this.proxy.required = this.required;\n            }\n            DOM.queueUpdate(() => this.classList.toggle(\"required\", this.required));\n            this.validate();\n        }\n        /**\n         * The element internals object. Will only exist\n         * in browsers supporting the attachInternals API\n         */\n        get elementInternals() {\n            if (!supportsElementInternals) {\n                return null;\n            }\n            let internals = InternalsMap.get(this);\n            if (!internals) {\n                internals = this.attachInternals();\n                InternalsMap.set(this, internals);\n            }\n            return internals;\n        }\n        /**\n         * @internal\n         */\n        connectedCallback() {\n            super.connectedCallback();\n            this.addEventListener(\"keypress\", this._keypressHandler);\n            if (!this.value) {\n                this.value = this.initialValue;\n                this.dirtyValue = false;\n            }\n            if (!this.elementInternals) {\n                this.attachProxy();\n                if (this.form) {\n                    this.form.addEventListener(\"reset\", this.formResetCallback);\n                }\n            }\n        }\n        /**\n         * @internal\n         */\n        disconnectedCallback() {\n            this.proxyEventsToBlock.forEach(name => this.proxy.removeEventListener(name, this.stopPropagation));\n            if (!this.elementInternals && this.form) {\n                this.form.removeEventListener(\"reset\", this.formResetCallback);\n            }\n        }\n        /**\n         * Return the current validity of the element.\n         */\n        checkValidity() {\n            return this.elementInternals\n                ? this.elementInternals.checkValidity()\n                : this.proxy.checkValidity();\n        }\n        /**\n         * Return the current validity of the element.\n         * If false, fires an invalid event at the element.\n         */\n        reportValidity() {\n            return this.elementInternals\n                ? this.elementInternals.reportValidity()\n                : this.proxy.reportValidity();\n        }\n        /**\n         * Set the validity of the control. In cases when the elementInternals object is not\n         * available (and the proxy element is used to report validity), this function will\n         * do nothing unless a message is provided, at which point the setCustomValidity method\n         * of the proxy element will be invoked with the provided message.\n         * @param flags - Validity flags\n         * @param message - Optional message to supply\n         * @param anchor - Optional element used by UA to display an interactive validation UI\n         */\n        setValidity(flags, message, anchor) {\n            if (this.elementInternals) {\n                this.elementInternals.setValidity(flags, message, anchor);\n            }\n            else if (typeof message === \"string\") {\n                this.proxy.setCustomValidity(message);\n            }\n        }\n        /**\n         * Invoked when a connected component's form or fieldset has its disabled\n         * state changed.\n         * @param disabled - the disabled value of the form / fieldset\n         */\n        formDisabledCallback(disabled) {\n            this.disabled = disabled;\n        }\n        formResetCallback() {\n            this.value = this.initialValue;\n            this.dirtyValue = false;\n        }\n        /**\n         * Attach the proxy element to the DOM\n         */\n        attachProxy() {\n            var _a;\n            if (!this.proxyInitialized) {\n                this.proxyInitialized = true;\n                this.proxy.style.display = \"none\";\n                this.proxyEventsToBlock.forEach(name => this.proxy.addEventListener(name, this.stopPropagation));\n                // These are typically mapped to the proxy during\n                // property change callbacks, but during initialization\n                // on the initial call of the callback, the proxy is\n                // still undefined. We should find a better way to address this.\n                this.proxy.disabled = this.disabled;\n                this.proxy.required = this.required;\n                if (typeof this.name === \"string\") {\n                    this.proxy.name = this.name;\n                }\n                if (typeof this.value === \"string\") {\n                    this.proxy.value = this.value;\n                }\n                this.proxy.setAttribute(\"slot\", proxySlotName);\n                this.proxySlot = document.createElement(\"slot\");\n                this.proxySlot.setAttribute(\"name\", proxySlotName);\n            }\n            (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.appendChild(this.proxySlot);\n            this.appendChild(this.proxy);\n        }\n        /**\n         * Detach the proxy element from the DOM\n         */\n        detachProxy() {\n            var _a;\n            this.removeChild(this.proxy);\n            (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.removeChild(this.proxySlot);\n        }\n        /** {@inheritDoc (FormAssociated:interface).validate} */\n        validate(anchor) {\n            if (this.proxy instanceof HTMLElement) {\n                this.setValidity(this.proxy.validity, this.proxy.validationMessage, anchor);\n            }\n        }\n        /**\n         * Associates the provided value (and optional state) with the parent form.\n         * @param value - The value to set\n         * @param state - The state object provided to during session restores and when autofilling.\n         */\n        setFormValue(value, state) {\n            if (this.elementInternals) {\n                this.elementInternals.setFormValue(value, state || value);\n            }\n        }\n        _keypressHandler(e) {\n            switch (e.key) {\n                case keyEnter:\n                    if (this.form instanceof HTMLFormElement) {\n                        // Implicit submission\n                        const defaultButton = this.form.querySelector(\"[type=submit]\");\n                        defaultButton === null || defaultButton === void 0 ? void 0 : defaultButton.click();\n                    }\n                    break;\n            }\n        }\n        /**\n         * Used to stop propagation of proxy element events\n         * @param e - Event object\n         */\n        stopPropagation(e) {\n            e.stopPropagation();\n        }\n    };\n    attr({ mode: \"boolean\" })(C.prototype, \"disabled\");\n    attr({ mode: \"fromView\", attribute: \"value\" })(C.prototype, \"initialValue\");\n    attr({ attribute: \"current-value\" })(C.prototype, \"currentValue\");\n    attr(C.prototype, \"name\");\n    attr({ mode: \"boolean\" })(C.prototype, \"required\");\n    observable(C.prototype, \"value\");\n    return C;\n}\n/**\n * @alpha\n */\nexport function CheckableFormAssociated(BaseCtor) {\n    class C extends FormAssociated(BaseCtor) {\n    }\n    class D extends C {\n        constructor(...args) {\n            super(args);\n            /**\n             * Tracks whether the \"checked\" property has been changed.\n             * This is necessary to provide consistent behavior with\n             * normal input checkboxes\n             */\n            this.dirtyChecked = false;\n            /**\n             * Provides the default checkedness of the input element\n             * Passed down to proxy\n             *\n             * @public\n             * @remarks\n             * HTML Attribute: checked\n             */\n            this.checkedAttribute = false;\n            /**\n             * The checked state of the control.\n             *\n             * @public\n             */\n            this.checked = false;\n            // Re-initialize dirtyChecked because initialization of other values\n            // causes it to become true\n            this.dirtyChecked = false;\n        }\n        checkedAttributeChanged() {\n            this.defaultChecked = this.checkedAttribute;\n        }\n        /**\n         * @internal\n         */\n        defaultCheckedChanged() {\n            if (!this.dirtyChecked) {\n                // Setting this.checked will cause us to enter a dirty state,\n                // but if we are clean when defaultChecked is changed, we want to stay\n                // in a clean state, so reset this.dirtyChecked\n                this.checked = this.defaultChecked;\n                this.dirtyChecked = false;\n            }\n        }\n        checkedChanged(prev, next) {\n            if (!this.dirtyChecked) {\n                this.dirtyChecked = true;\n            }\n            this.currentChecked = this.checked;\n            this.updateForm();\n            if (this.proxy instanceof HTMLInputElement) {\n                this.proxy.checked = this.checked;\n            }\n            if (prev !== undefined) {\n                this.$emit(\"change\");\n            }\n            this.validate();\n        }\n        currentCheckedChanged(prev, next) {\n            this.checked = this.currentChecked;\n        }\n        updateForm() {\n            const value = this.checked ? this.value : null;\n            this.setFormValue(value, value);\n        }\n        connectedCallback() {\n            super.connectedCallback();\n            this.updateForm();\n        }\n        formResetCallback() {\n            super.formResetCallback();\n            this.checked = !!this.checkedAttribute;\n            this.dirtyChecked = false;\n        }\n    }\n    attr({ attribute: \"checked\", mode: \"boolean\" })(D.prototype, \"checkedAttribute\");\n    attr({ attribute: \"current-checked\", converter: booleanConverter })(D.prototype, \"currentChecked\");\n    observable(D.prototype, \"defaultChecked\");\n    observable(D.prototype, \"checked\");\n    return D;\n}\n"],"mappings":";;;;;;;AAAA,SAASA,IAAT,EAAeC,gBAAf,EAAiCC,GAAjC,EAAsCC,UAAtC,EAAkDC,UAAlD,QAAqE,yBAArE;AACA,SAASC,QAAT,QAAyB,+BAAzB;AACA,IAAMC,aAAa,GAAG,uBAAtB;AACA,IAAMC,mBAAmB,GAAG,kBAA5B;AACA;AACA;AACA;;AACA,OAAO,IAAMC,wBAAwB,GAAGD,mBAAmB,IAAIE,MAAvB,IACpC,kBAAkBA,MAAM,CAACF,mBAAD,CAAN,CAA4BG,SAD3C;AAEP,IAAMC,YAAY,GAAG,IAAIC,OAAJ,EAArB;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,cAAT,CAAwBC,QAAxB,EAAkC;EACrC,IAAMC,CAAC;IAAA;;IAAA;;IACH,aAAqB;MAAA;;MAAA;;MAAA,kCAANC,IAAM;QAANA,IAAM;MAAA;;MACjB,gDAASA,IAAT;MACA;AACZ;AACA;;MACY,MAAKC,UAAL,GAAkB,KAAlB;MACA;AACZ;AACA;AACA;AACA;AACA;;MACY,MAAKC,QAAL,GAAgB,KAAhB;MACA;AACZ;AACA;AACA;AACA;AACA;AACA;;MACY,MAAKC,kBAAL,GAA0B,CAAC,QAAD,EAAW,OAAX,CAA1B;MACA,MAAKC,gBAAL,GAAwB,KAAxB;MACA,MAAKC,QAAL,GAAgB,KAAhB;MACA,MAAKC,YAAL,GAAoB,MAAKA,YAAL,IAAqB,EAAzC;;MACA,IAAI,CAAC,MAAKC,gBAAV,EAA4B;QACxB;QACA;QACA;QACA,MAAKC,iBAAL,GAAyB,MAAKA,iBAAL,CAAuBC,IAAvB,+BAAzB;MACH;;MA7BgB;IA8BpB;IACD;AACR;AACA;AACA;AACA;AACA;;;IArCW;MAAA;MAAA;MAyCH;AACR;AACA;AACA;AACA;MACQ,eAAe;QACX,OAAO,KAAKF,gBAAL,GACD,KAAKA,gBAAL,CAAsBG,QADrB,GAED,KAAKC,KAAL,CAAWD,QAFjB;MAGH;MACD;AACR;AACA;AACA;AACA;AACA;;IAxDW;MAAA;MAAA,KAyDH,eAAW;QACP,OAAO,KAAKH,gBAAL,GAAwB,KAAKA,gBAAL,CAAsBK,IAA9C,GAAqD,KAAKD,KAAL,CAAWC,IAAvE;MACH;MACD;AACR;AACA;AACA;AACA;AACA;;IAjEW;MAAA;MAAA,KAkEH,eAAwB;QACpB,OAAO,KAAKL,gBAAL,GACD,KAAKA,gBAAL,CAAsBM,iBADrB,GAED,KAAKF,KAAL,CAAWE,iBAFjB;MAGH;MACD;AACR;AACA;AACA;;IA1EW;MAAA;MAAA,KA2EH,eAAmB;QACf,OAAO,KAAKN,gBAAL,GACD,KAAKA,gBAAL,CAAsBO,YADrB,GAED,KAAKH,KAAL,CAAWG,YAFjB;MAGH;MACD;AACR;AACA;;IAlFW;MAAA;MAAA,KAmFH,eAAa;QACT,IAAI,KAAKP,gBAAT,EAA2B;UACvB,OAAOQ,MAAM,CAACC,MAAP,CAAcC,KAAK,CAACC,IAAN,CAAW,KAAKX,gBAAL,CAAsBY,MAAjC,CAAd,CAAP;QACH,CAFD,MAGK,IAAI,KAAKR,KAAL,YAAsBS,WAAtB,IACL,KAAKT,KAAL,CAAWU,aADN,IAEL,KAAKC,EAFJ,EAEQ;UACT;UACA,IAAMC,YAAY,GAAG,KAAKZ,KAAL,CAAWQ,MAAhC,CAFS,CAGT;;UACA,IAAMK,SAAS,GAAGP,KAAK,CAACC,IAAN,CAAW,KAAKP,KAAL,CAAWc,WAAX,GAAyBC,gBAAzB,iBAAmD,KAAKJ,EAAxD,QAAX,CAAlB;UACA,IAAMH,MAAM,GAAGI,YAAY,GACrBC,SAAS,CAACG,MAAV,CAAiBV,KAAK,CAACC,IAAN,CAAWK,YAAX,CAAjB,CADqB,GAErBC,SAFN;UAGA,OAAOT,MAAM,CAACC,MAAP,CAAcG,MAAd,CAAP;QACH,CAXI,MAYA;UACD,OAAOhC,UAAP;QACH;MACJ;MACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAhHW;MAAA;MAAA,OAiHH,sBAAayC,QAAb,EAAuBC,IAAvB,EAA6B;QACzB,KAAK5B,UAAL,GAAkB,IAAlB;;QACA,IAAI,KAAKU,KAAL,YAAsBS,WAA1B,EAAuC;UACnC,KAAKT,KAAL,CAAWmB,KAAX,GAAmB,KAAKA,KAAxB;QACH;;QACD,KAAKC,YAAL,GAAoB,KAAKD,KAAzB;QACA,KAAKE,YAAL,CAAkB,KAAKF,KAAvB;QACA,KAAKG,QAAL;MACH;IAzHE;MAAA;MAAA,OA0HH,+BAAsB;QAClB,KAAKH,KAAL,GAAa,KAAKC,YAAlB;MACH;MACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAvIW;MAAA;MAAA,OAwIH,6BAAoBH,QAApB,EAA8BC,IAA9B,EAAoC;QAChC;QACA;QACA,IAAI,CAAC,KAAK5B,UAAV,EAAsB;UAClB,KAAK6B,KAAL,GAAa,KAAKxB,YAAlB;UACA,KAAKL,UAAL,GAAkB,KAAlB;QACH;MACJ;MACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IA1JW;MAAA;MAAA,OA2JH,yBAAgB2B,QAAhB,EAA0BC,IAA1B,EAAgC;QAAA;;QAC5B,IAAI,KAAKlB,KAAL,YAAsBS,WAA1B,EAAuC;UACnC,KAAKT,KAAL,CAAWT,QAAX,GAAsB,KAAKA,QAA3B;QACH;;QACDhB,GAAG,CAACgD,WAAJ,CAAgB;UAAA,OAAM,MAAI,CAACC,SAAL,CAAeC,MAAf,CAAsB,UAAtB,EAAkC,MAAI,CAAClC,QAAvC,CAAN;QAAA,CAAhB;MACH;MACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IA3KW;MAAA;MAAA,OA4KH,qBAAY0B,QAAZ,EAAsBC,IAAtB,EAA4B;QACxB,IAAI,KAAKlB,KAAL,YAAsBS,WAA1B,EAAuC;UACnC,KAAKT,KAAL,CAAW0B,IAAX,GAAkB,KAAKA,IAAvB;QACH;MACJ;MACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IA3LW;MAAA;MAAA,OA4LH,yBAAgBC,IAAhB,EAAsBT,IAAtB,EAA4B;QAAA;;QACxB,IAAI,KAAKlB,KAAL,YAAsBS,WAA1B,EAAuC;UACnC,KAAKT,KAAL,CAAWN,QAAX,GAAsB,KAAKA,QAA3B;QACH;;QACDnB,GAAG,CAACgD,WAAJ,CAAgB;UAAA,OAAM,MAAI,CAACC,SAAL,CAAeC,MAAf,CAAsB,UAAtB,EAAkC,MAAI,CAAC/B,QAAvC,CAAN;QAAA,CAAhB;QACA,KAAK4B,QAAL;MACH;MACD;AACR;AACA;AACA;;IAtMW;MAAA;MAAA,KAuMH,eAAuB;QACnB,IAAI,CAACzC,wBAAL,EAA+B;UAC3B,OAAO,IAAP;QACH;;QACD,IAAI+C,SAAS,GAAG5C,YAAY,CAAC6C,GAAb,CAAiB,IAAjB,CAAhB;;QACA,IAAI,CAACD,SAAL,EAAgB;UACZA,SAAS,GAAG,KAAKE,eAAL,EAAZ;UACA9C,YAAY,CAAC+C,GAAb,CAAiB,IAAjB,EAAuBH,SAAvB;QACH;;QACD,OAAOA,SAAP;MACH;MACD;AACR;AACA;;IApNW;MAAA;MAAA,OAqNH,6BAAoB;QAChB;;QACA,KAAKI,gBAAL,CAAsB,UAAtB,EAAkC,KAAKC,gBAAvC;;QACA,IAAI,CAAC,KAAKd,KAAV,EAAiB;UACb,KAAKA,KAAL,GAAa,KAAKxB,YAAlB;UACA,KAAKL,UAAL,GAAkB,KAAlB;QACH;;QACD,IAAI,CAAC,KAAKM,gBAAV,EAA4B;UACxB,KAAKsC,WAAL;;UACA,IAAI,KAAKjC,IAAT,EAAe;YACX,KAAKA,IAAL,CAAU+B,gBAAV,CAA2B,OAA3B,EAAoC,KAAKnC,iBAAzC;UACH;QACJ;MACJ;MACD;AACR;AACA;;IArOW;MAAA;MAAA,OAsOH,gCAAuB;QAAA;;QACnB,KAAKL,kBAAL,CAAwB2C,OAAxB,CAAgC,UAAAT,IAAI;UAAA,OAAI,MAAI,CAAC1B,KAAL,CAAWoC,mBAAX,CAA+BV,IAA/B,EAAqC,MAAI,CAACW,eAA1C,CAAJ;QAAA,CAApC;;QACA,IAAI,CAAC,KAAKzC,gBAAN,IAA0B,KAAKK,IAAnC,EAAyC;UACrC,KAAKA,IAAL,CAAUmC,mBAAV,CAA8B,OAA9B,EAAuC,KAAKvC,iBAA5C;QACH;MACJ;MACD;AACR;AACA;;IA9OW;MAAA;MAAA,OA+OH,yBAAgB;QACZ,OAAO,KAAKD,gBAAL,GACD,KAAKA,gBAAL,CAAsB0C,aAAtB,EADC,GAED,KAAKtC,KAAL,CAAWsC,aAAX,EAFN;MAGH;MACD;AACR;AACA;AACA;;IAvPW;MAAA;MAAA,OAwPH,0BAAiB;QACb,OAAO,KAAK1C,gBAAL,GACD,KAAKA,gBAAL,CAAsB2C,cAAtB,EADC,GAED,KAAKvC,KAAL,CAAWuC,cAAX,EAFN;MAGH;MACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IArQW;MAAA;MAAA,OAsQH,qBAAYC,KAAZ,EAAmBC,OAAnB,EAA4BC,MAA5B,EAAoC;QAChC,IAAI,KAAK9C,gBAAT,EAA2B;UACvB,KAAKA,gBAAL,CAAsB+C,WAAtB,CAAkCH,KAAlC,EAAyCC,OAAzC,EAAkDC,MAAlD;QACH,CAFD,MAGK,IAAI,OAAOD,OAAP,KAAmB,QAAvB,EAAiC;UAClC,KAAKzC,KAAL,CAAW4C,iBAAX,CAA6BH,OAA7B;QACH;MACJ;MACD;AACR;AACA;AACA;AACA;;IAlRW;MAAA;MAAA,OAmRH,8BAAqBlD,QAArB,EAA+B;QAC3B,KAAKA,QAAL,GAAgBA,QAAhB;MACH;IArRE;MAAA;MAAA,OAsRH,6BAAoB;QAChB,KAAK4B,KAAL,GAAa,KAAKxB,YAAlB;QACA,KAAKL,UAAL,GAAkB,KAAlB;MACH;MACD;AACR;AACA;;IA5RW;MAAA;MAAA,OA6RH,uBAAc;QAAA;;QACV,IAAIuD,EAAJ;;QACA,IAAI,CAAC,KAAKpD,gBAAV,EAA4B;UACxB,KAAKA,gBAAL,GAAwB,IAAxB;UACA,KAAKO,KAAL,CAAW8C,KAAX,CAAiBC,OAAjB,GAA2B,MAA3B;UACA,KAAKvD,kBAAL,CAAwB2C,OAAxB,CAAgC,UAAAT,IAAI;YAAA,OAAI,MAAI,CAAC1B,KAAL,CAAWgC,gBAAX,CAA4BN,IAA5B,EAAkC,MAAI,CAACW,eAAvC,CAAJ;UAAA,CAApC,EAHwB,CAIxB;UACA;UACA;UACA;;UACA,KAAKrC,KAAL,CAAWT,QAAX,GAAsB,KAAKA,QAA3B;UACA,KAAKS,KAAL,CAAWN,QAAX,GAAsB,KAAKA,QAA3B;;UACA,IAAI,OAAO,KAAKgC,IAAZ,KAAqB,QAAzB,EAAmC;YAC/B,KAAK1B,KAAL,CAAW0B,IAAX,GAAkB,KAAKA,IAAvB;UACH;;UACD,IAAI,OAAO,KAAKP,KAAZ,KAAsB,QAA1B,EAAoC;YAChC,KAAKnB,KAAL,CAAWmB,KAAX,GAAmB,KAAKA,KAAxB;UACH;;UACD,KAAKnB,KAAL,CAAWgD,YAAX,CAAwB,MAAxB,EAAgCrE,aAAhC;UACA,KAAKsE,SAAL,GAAiBC,QAAQ,CAACC,aAAT,CAAuB,MAAvB,CAAjB;UACA,KAAKF,SAAL,CAAeD,YAAf,CAA4B,MAA5B,EAAoCrE,aAApC;QACH;;QACD,CAACkE,EAAE,GAAG,KAAKO,UAAX,MAA2B,IAA3B,IAAmCP,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACQ,WAAH,CAAe,KAAKJ,SAApB,CAA5D;QACA,KAAKI,WAAL,CAAiB,KAAKrD,KAAtB;MACH;MACD;AACR;AACA;;IAxTW;MAAA;MAAA,OAyTH,uBAAc;QACV,IAAI6C,EAAJ;;QACA,KAAKS,WAAL,CAAiB,KAAKtD,KAAtB;QACA,CAAC6C,EAAE,GAAG,KAAKO,UAAX,MAA2B,IAA3B,IAAmCP,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACS,WAAH,CAAe,KAAKL,SAApB,CAA5D;MACH;MACD;;IA9TG;MAAA;MAAA,OA+TH,kBAASP,MAAT,EAAiB;QACb,IAAI,KAAK1C,KAAL,YAAsBS,WAA1B,EAAuC;UACnC,KAAKkC,WAAL,CAAiB,KAAK3C,KAAL,CAAWD,QAA5B,EAAsC,KAAKC,KAAL,CAAWE,iBAAjD,EAAoEwC,MAApE;QACH;MACJ;MACD;AACR;AACA;AACA;AACA;;IAxUW;MAAA;MAAA,OAyUH,sBAAavB,KAAb,EAAoBoC,KAApB,EAA2B;QACvB,IAAI,KAAK3D,gBAAT,EAA2B;UACvB,KAAKA,gBAAL,CAAsByB,YAAtB,CAAmCF,KAAnC,EAA0CoC,KAAK,IAAIpC,KAAnD;QACH;MACJ;IA7UE;MAAA;MAAA,OA8UH,0BAAiBqC,CAAjB,EAAoB;QAChB,QAAQA,CAAC,CAACC,GAAV;UACI,KAAK/E,QAAL;YACI,IAAI,KAAKuB,IAAL,YAAqByD,eAAzB,EAA0C;cACtC;cACA,IAAMC,aAAa,GAAG,KAAK1D,IAAL,CAAU2D,aAAV,CAAwB,eAAxB,CAAtB;cACAD,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,GAAqD,KAAK,CAA1D,GAA8DA,aAAa,CAACE,KAAd,EAA9D;YACH;;YACD;QAPR;MASH;MACD;AACR;AACA;AACA;;IA5VW;MAAA;MAAA,OA6VH,yBAAgBL,CAAhB,EAAmB;QACfA,CAAC,CAACnB,eAAF;MACH;IA/VE;MAAA;MAAA,KAsCH,eAA4B;QACxB,OAAOxD,wBAAP;MACH;IAxCE;;IAAA;EAAA,EAAiBM,QAAjB,CAAP;;EAiWAd,IAAI,CAAC;IAAEyF,IAAI,EAAE;EAAR,CAAD,CAAJ,CAA0B1E,CAAC,CAACL,SAA5B,EAAuC,UAAvC;EACAV,IAAI,CAAC;IAAEyF,IAAI,EAAE,UAAR;IAAoBC,SAAS,EAAE;EAA/B,CAAD,CAAJ,CAA+C3E,CAAC,CAACL,SAAjD,EAA4D,cAA5D;EACAV,IAAI,CAAC;IAAE0F,SAAS,EAAE;EAAb,CAAD,CAAJ,CAAqC3E,CAAC,CAACL,SAAvC,EAAkD,cAAlD;EACAV,IAAI,CAACe,CAAC,CAACL,SAAH,EAAc,MAAd,CAAJ;EACAV,IAAI,CAAC;IAAEyF,IAAI,EAAE;EAAR,CAAD,CAAJ,CAA0B1E,CAAC,CAACL,SAA5B,EAAuC,UAAvC;EACAN,UAAU,CAACW,CAAC,CAACL,SAAH,EAAc,OAAd,CAAV;EACA,OAAOK,CAAP;AACH;AACD;AACA;AACA;;AACA,OAAO,SAAS4E,uBAAT,CAAiC7E,QAAjC,EAA2C;EAAA,IACxCC,CADwC;IAAA;;IAAA;;IAAA;MAAA;;MAAA;IAAA;;IAAA;EAAA,EAC9BF,cAAc,CAACC,QAAD,CADgB;;EAAA,IAGxC8E,CAHwC;IAAA;;IAAA;;IAI1C,aAAqB;MAAA;;MAAA;;MAAA,mCAAN5E,IAAM;QAANA,IAAM;MAAA;;MACjB,4BAAMA,IAAN;MACA;AACZ;AACA;AACA;AACA;;MACY,OAAK6E,YAAL,GAAoB,KAApB;MACA;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;MACY,OAAKC,gBAAL,GAAwB,KAAxB;MACA;AACZ;AACA;AACA;AACA;;MACY,OAAKC,OAAL,GAAe,KAAf,CAtBiB,CAuBjB;MACA;;MACA,OAAKF,YAAL,GAAoB,KAApB;MAzBiB;IA0BpB;;IA9ByC;MAAA;MAAA,OA+B1C,mCAA0B;QACtB,KAAKG,cAAL,GAAsB,KAAKF,gBAA3B;MACH;MACD;AACR;AACA;;IApCkD;MAAA;MAAA,OAqC1C,iCAAwB;QACpB,IAAI,CAAC,KAAKD,YAAV,EAAwB;UACpB;UACA;UACA;UACA,KAAKE,OAAL,GAAe,KAAKC,cAApB;UACA,KAAKH,YAAL,GAAoB,KAApB;QACH;MACJ;IA7CyC;MAAA;MAAA,OA8C1C,wBAAevC,IAAf,EAAqBT,IAArB,EAA2B;QACvB,IAAI,CAAC,KAAKgD,YAAV,EAAwB;UACpB,KAAKA,YAAL,GAAoB,IAApB;QACH;;QACD,KAAKI,cAAL,GAAsB,KAAKF,OAA3B;QACA,KAAKG,UAAL;;QACA,IAAI,KAAKvE,KAAL,YAAsBwE,gBAA1B,EAA4C;UACxC,KAAKxE,KAAL,CAAWoE,OAAX,GAAqB,KAAKA,OAA1B;QACH;;QACD,IAAIzC,IAAI,KAAK8C,SAAb,EAAwB;UACpB,KAAKC,KAAL,CAAW,QAAX;QACH;;QACD,KAAKpD,QAAL;MACH;IA3DyC;MAAA;MAAA,OA4D1C,+BAAsBK,IAAtB,EAA4BT,IAA5B,EAAkC;QAC9B,KAAKkD,OAAL,GAAe,KAAKE,cAApB;MACH;IA9DyC;MAAA;MAAA,OA+D1C,sBAAa;QACT,IAAMnD,KAAK,GAAG,KAAKiD,OAAL,GAAe,KAAKjD,KAApB,GAA4B,IAA1C;QACA,KAAKE,YAAL,CAAkBF,KAAlB,EAAyBA,KAAzB;MACH;IAlEyC;MAAA;MAAA,OAmE1C,6BAAoB;QAChB;;QACA,KAAKoD,UAAL;MACH;IAtEyC;MAAA;MAAA,OAuE1C,6BAAoB;QAChB;;QACA,KAAKH,OAAL,GAAe,CAAC,CAAC,KAAKD,gBAAtB;QACA,KAAKD,YAAL,GAAoB,KAApB;MACH;IA3EyC;;IAAA;EAAA,EAG9B9E,CAH8B;;EA6E9Cf,IAAI,CAAC;IAAE0F,SAAS,EAAE,SAAb;IAAwBD,IAAI,EAAE;EAA9B,CAAD,CAAJ,CAAgDG,CAAC,CAAClF,SAAlD,EAA6D,kBAA7D;EACAV,IAAI,CAAC;IAAE0F,SAAS,EAAE,iBAAb;IAAgCY,SAAS,EAAErG;EAA3C,CAAD,CAAJ,CAAoE2F,CAAC,CAAClF,SAAtE,EAAiF,gBAAjF;EACAN,UAAU,CAACwF,CAAC,CAAClF,SAAH,EAAc,gBAAd,CAAV;EACAN,UAAU,CAACwF,CAAC,CAAClF,SAAH,EAAc,SAAd,CAAV;EACA,OAAOkF,CAAP;AACH"},"metadata":{},"sourceType":"module"}