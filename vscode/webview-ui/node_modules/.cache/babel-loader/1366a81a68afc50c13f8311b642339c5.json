{"ast":null,"code":"import { _interpolationEnd, _interpolationStart, DOM } from \"../dom.js\";\nimport { HTMLBindingDirective } from \"./binding.js\";\nlet sharedContext = null;\n\nclass CompilationContext {\n  addFactory(factory) {\n    factory.targetIndex = this.targetIndex;\n    this.behaviorFactories.push(factory);\n  }\n\n  captureContentBinding(directive) {\n    directive.targetAtContent();\n    this.addFactory(directive);\n  }\n\n  reset() {\n    this.behaviorFactories = [];\n    this.targetIndex = -1;\n  }\n\n  release() {\n    /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n    sharedContext = this;\n  }\n\n  static borrow(directives) {\n    const shareable = sharedContext || new CompilationContext();\n    shareable.directives = directives;\n    shareable.reset();\n    sharedContext = null;\n    return shareable;\n  }\n\n}\n\nfunction createAggregateBinding(parts) {\n  if (parts.length === 1) {\n    return parts[0];\n  }\n\n  let targetName;\n  const partCount = parts.length;\n  const finalParts = parts.map(x => {\n    if (typeof x === \"string\") {\n      return () => x;\n    }\n\n    targetName = x.targetName || targetName;\n    return x.binding;\n  });\n\n  const binding = (scope, context) => {\n    let output = \"\";\n\n    for (let i = 0; i < partCount; ++i) {\n      output += finalParts[i](scope, context);\n    }\n\n    return output;\n  };\n\n  const directive = new HTMLBindingDirective(binding);\n  directive.targetName = targetName;\n  return directive;\n}\n\nconst interpolationEndLength = _interpolationEnd.length;\n\nfunction parseContent(context, value) {\n  const valueParts = value.split(_interpolationStart);\n\n  if (valueParts.length === 1) {\n    return null;\n  }\n\n  const bindingParts = [];\n\n  for (let i = 0, ii = valueParts.length; i < ii; ++i) {\n    const current = valueParts[i];\n    const index = current.indexOf(_interpolationEnd);\n    let literal;\n\n    if (index === -1) {\n      literal = current;\n    } else {\n      const directiveIndex = parseInt(current.substring(0, index));\n      bindingParts.push(context.directives[directiveIndex]);\n      literal = current.substring(index + interpolationEndLength);\n    }\n\n    if (literal !== \"\") {\n      bindingParts.push(literal);\n    }\n  }\n\n  return bindingParts;\n}\n\nfunction compileAttributes(context, node) {\n  let includeBasicValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const attributes = node.attributes;\n\n  for (let i = 0, ii = attributes.length; i < ii; ++i) {\n    const attr = attributes[i];\n    const attrValue = attr.value;\n    const parseResult = parseContent(context, attrValue);\n    let result = null;\n\n    if (parseResult === null) {\n      if (includeBasicValues) {\n        result = new HTMLBindingDirective(() => attrValue);\n        result.targetName = attr.name;\n      }\n    } else {\n      result = createAggregateBinding(parseResult);\n    }\n\n    if (result !== null) {\n      node.removeAttributeNode(attr);\n      i--;\n      ii--;\n      context.addFactory(result);\n    }\n  }\n}\n\nfunction compileContent(context, node, walker) {\n  const parseResult = parseContent(context, node.textContent);\n\n  if (parseResult !== null) {\n    let lastNode = node;\n\n    for (let i = 0, ii = parseResult.length; i < ii; ++i) {\n      const currentPart = parseResult[i];\n      const currentNode = i === 0 ? node : lastNode.parentNode.insertBefore(document.createTextNode(\"\"), lastNode.nextSibling);\n\n      if (typeof currentPart === \"string\") {\n        currentNode.textContent = currentPart;\n      } else {\n        currentNode.textContent = \" \";\n        context.captureContentBinding(currentPart);\n      }\n\n      lastNode = currentNode;\n      context.targetIndex++;\n\n      if (currentNode !== node) {\n        walker.nextNode();\n      }\n    }\n\n    context.targetIndex--;\n  }\n}\n/**\n * Compiles a template and associated directives into a raw compilation\n * result which include a cloneable DocumentFragment and factories capable\n * of attaching runtime behavior to nodes within the fragment.\n * @param template - The template to compile.\n * @param directives - The directives referenced by the template.\n * @remarks\n * The template that is provided for compilation is altered in-place\n * and cannot be compiled again. If the original template must be preserved,\n * it is recommended that you clone the original and pass the clone to this API.\n * @public\n */\n\n\nexport function compileTemplate(template, directives) {\n  const fragment = template.content; // https://bugs.chromium.org/p/chromium/issues/detail?id=1111864\n\n  document.adoptNode(fragment);\n  const context = CompilationContext.borrow(directives);\n  compileAttributes(context, template, true);\n  const hostBehaviorFactories = context.behaviorFactories;\n  context.reset();\n  const walker = DOM.createTemplateWalker(fragment);\n  let node;\n\n  while (node = walker.nextNode()) {\n    context.targetIndex++;\n\n    switch (node.nodeType) {\n      case 1:\n        // element node\n        compileAttributes(context, node);\n        break;\n\n      case 3:\n        // text node\n        compileContent(context, node, walker);\n        break;\n\n      case 8:\n        // comment\n        if (DOM.isMarker(node)) {\n          context.addFactory(directives[DOM.extractDirectiveIndexFromMarker(node)]);\n        }\n\n    }\n  }\n\n  let targetOffset = 0;\n\n  if ( // If the first node in a fragment is a marker, that means it's an unstable first node,\n  // because something like a when, repeat, etc. could add nodes before the marker.\n  // To mitigate this, we insert a stable first node. However, if we insert a node,\n  // that will alter the result of the TreeWalker. So, we also need to offset the target index.\n  DOM.isMarker(fragment.firstChild) || // Or if there is only one node and a directive, it means the template's content\n  // is *only* the directive. In that case, HTMLView.dispose() misses any nodes inserted by\n  // the directive. Inserting a new node ensures proper disposal of nodes added by the directive.\n  fragment.childNodes.length === 1 && directives.length) {\n    fragment.insertBefore(document.createComment(\"\"), fragment.firstChild);\n    targetOffset = -1;\n  }\n\n  const viewBehaviorFactories = context.behaviorFactories;\n  context.release();\n  return {\n    fragment,\n    viewBehaviorFactories,\n    hostBehaviorFactories,\n    targetOffset\n  };\n}","map":{"version":3,"names":["_interpolationEnd","_interpolationStart","DOM","HTMLBindingDirective","sharedContext","CompilationContext","addFactory","factory","targetIndex","behaviorFactories","push","captureContentBinding","directive","targetAtContent","reset","release","borrow","directives","shareable","createAggregateBinding","parts","length","targetName","partCount","finalParts","map","x","binding","scope","context","output","i","interpolationEndLength","parseContent","value","valueParts","split","bindingParts","ii","current","index","indexOf","literal","directiveIndex","parseInt","substring","compileAttributes","node","includeBasicValues","attributes","attr","attrValue","parseResult","result","name","removeAttributeNode","compileContent","walker","textContent","lastNode","currentPart","currentNode","parentNode","insertBefore","document","createTextNode","nextSibling","nextNode","compileTemplate","template","fragment","content","adoptNode","hostBehaviorFactories","createTemplateWalker","nodeType","isMarker","extractDirectiveIndexFromMarker","targetOffset","firstChild","childNodes","createComment","viewBehaviorFactories"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-element/dist/esm/templating/compiler.js"],"sourcesContent":["import { _interpolationEnd, _interpolationStart, DOM } from \"../dom.js\";\nimport { HTMLBindingDirective } from \"./binding.js\";\nlet sharedContext = null;\nclass CompilationContext {\n    addFactory(factory) {\n        factory.targetIndex = this.targetIndex;\n        this.behaviorFactories.push(factory);\n    }\n    captureContentBinding(directive) {\n        directive.targetAtContent();\n        this.addFactory(directive);\n    }\n    reset() {\n        this.behaviorFactories = [];\n        this.targetIndex = -1;\n    }\n    release() {\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n        sharedContext = this;\n    }\n    static borrow(directives) {\n        const shareable = sharedContext || new CompilationContext();\n        shareable.directives = directives;\n        shareable.reset();\n        sharedContext = null;\n        return shareable;\n    }\n}\nfunction createAggregateBinding(parts) {\n    if (parts.length === 1) {\n        return parts[0];\n    }\n    let targetName;\n    const partCount = parts.length;\n    const finalParts = parts.map((x) => {\n        if (typeof x === \"string\") {\n            return () => x;\n        }\n        targetName = x.targetName || targetName;\n        return x.binding;\n    });\n    const binding = (scope, context) => {\n        let output = \"\";\n        for (let i = 0; i < partCount; ++i) {\n            output += finalParts[i](scope, context);\n        }\n        return output;\n    };\n    const directive = new HTMLBindingDirective(binding);\n    directive.targetName = targetName;\n    return directive;\n}\nconst interpolationEndLength = _interpolationEnd.length;\nfunction parseContent(context, value) {\n    const valueParts = value.split(_interpolationStart);\n    if (valueParts.length === 1) {\n        return null;\n    }\n    const bindingParts = [];\n    for (let i = 0, ii = valueParts.length; i < ii; ++i) {\n        const current = valueParts[i];\n        const index = current.indexOf(_interpolationEnd);\n        let literal;\n        if (index === -1) {\n            literal = current;\n        }\n        else {\n            const directiveIndex = parseInt(current.substring(0, index));\n            bindingParts.push(context.directives[directiveIndex]);\n            literal = current.substring(index + interpolationEndLength);\n        }\n        if (literal !== \"\") {\n            bindingParts.push(literal);\n        }\n    }\n    return bindingParts;\n}\nfunction compileAttributes(context, node, includeBasicValues = false) {\n    const attributes = node.attributes;\n    for (let i = 0, ii = attributes.length; i < ii; ++i) {\n        const attr = attributes[i];\n        const attrValue = attr.value;\n        const parseResult = parseContent(context, attrValue);\n        let result = null;\n        if (parseResult === null) {\n            if (includeBasicValues) {\n                result = new HTMLBindingDirective(() => attrValue);\n                result.targetName = attr.name;\n            }\n        }\n        else {\n            result = createAggregateBinding(parseResult);\n        }\n        if (result !== null) {\n            node.removeAttributeNode(attr);\n            i--;\n            ii--;\n            context.addFactory(result);\n        }\n    }\n}\nfunction compileContent(context, node, walker) {\n    const parseResult = parseContent(context, node.textContent);\n    if (parseResult !== null) {\n        let lastNode = node;\n        for (let i = 0, ii = parseResult.length; i < ii; ++i) {\n            const currentPart = parseResult[i];\n            const currentNode = i === 0\n                ? node\n                : lastNode.parentNode.insertBefore(document.createTextNode(\"\"), lastNode.nextSibling);\n            if (typeof currentPart === \"string\") {\n                currentNode.textContent = currentPart;\n            }\n            else {\n                currentNode.textContent = \" \";\n                context.captureContentBinding(currentPart);\n            }\n            lastNode = currentNode;\n            context.targetIndex++;\n            if (currentNode !== node) {\n                walker.nextNode();\n            }\n        }\n        context.targetIndex--;\n    }\n}\n/**\n * Compiles a template and associated directives into a raw compilation\n * result which include a cloneable DocumentFragment and factories capable\n * of attaching runtime behavior to nodes within the fragment.\n * @param template - The template to compile.\n * @param directives - The directives referenced by the template.\n * @remarks\n * The template that is provided for compilation is altered in-place\n * and cannot be compiled again. If the original template must be preserved,\n * it is recommended that you clone the original and pass the clone to this API.\n * @public\n */\nexport function compileTemplate(template, directives) {\n    const fragment = template.content;\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1111864\n    document.adoptNode(fragment);\n    const context = CompilationContext.borrow(directives);\n    compileAttributes(context, template, true);\n    const hostBehaviorFactories = context.behaviorFactories;\n    context.reset();\n    const walker = DOM.createTemplateWalker(fragment);\n    let node;\n    while ((node = walker.nextNode())) {\n        context.targetIndex++;\n        switch (node.nodeType) {\n            case 1: // element node\n                compileAttributes(context, node);\n                break;\n            case 3: // text node\n                compileContent(context, node, walker);\n                break;\n            case 8: // comment\n                if (DOM.isMarker(node)) {\n                    context.addFactory(directives[DOM.extractDirectiveIndexFromMarker(node)]);\n                }\n        }\n    }\n    let targetOffset = 0;\n    if (\n    // If the first node in a fragment is a marker, that means it's an unstable first node,\n    // because something like a when, repeat, etc. could add nodes before the marker.\n    // To mitigate this, we insert a stable first node. However, if we insert a node,\n    // that will alter the result of the TreeWalker. So, we also need to offset the target index.\n    DOM.isMarker(fragment.firstChild) ||\n        // Or if there is only one node and a directive, it means the template's content\n        // is *only* the directive. In that case, HTMLView.dispose() misses any nodes inserted by\n        // the directive. Inserting a new node ensures proper disposal of nodes added by the directive.\n        (fragment.childNodes.length === 1 && directives.length)) {\n        fragment.insertBefore(document.createComment(\"\"), fragment.firstChild);\n        targetOffset = -1;\n    }\n    const viewBehaviorFactories = context.behaviorFactories;\n    context.release();\n    return {\n        fragment,\n        viewBehaviorFactories,\n        hostBehaviorFactories,\n        targetOffset,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}