{"ast":null,"code":"import { DOM } from \"../dom.js\";\nimport { createMetadataLocator, FAST } from \"../platform.js\";\nimport { PropertyChangeNotifier, SubscriberSet } from \"./notifier.js\";\n/**\n * Common Observable APIs.\n * @public\n */\n\nexport const Observable = FAST.getById(2\n/* observable */\n, () => {\n  const volatileRegex = /(:|&&|\\|\\||if)/;\n  const notifierLookup = new WeakMap();\n  const queueUpdate = DOM.queueUpdate;\n  let watcher = void 0;\n\n  let createArrayObserver = array => {\n    throw new Error(\"Must call enableArrayObservation before observing arrays.\");\n  };\n\n  function getNotifier(source) {\n    let found = source.$fastController || notifierLookup.get(source);\n\n    if (found === void 0) {\n      if (Array.isArray(source)) {\n        found = createArrayObserver(source);\n      } else {\n        notifierLookup.set(source, found = new PropertyChangeNotifier(source));\n      }\n    }\n\n    return found;\n  }\n\n  const getAccessors = createMetadataLocator();\n\n  class DefaultObservableAccessor {\n    constructor(name) {\n      this.name = name;\n      this.field = `_${name}`;\n      this.callback = `${name}Changed`;\n    }\n\n    getValue(source) {\n      if (watcher !== void 0) {\n        watcher.watch(source, this.name);\n      }\n\n      return source[this.field];\n    }\n\n    setValue(source, newValue) {\n      const field = this.field;\n      const oldValue = source[field];\n\n      if (oldValue !== newValue) {\n        source[field] = newValue;\n        const callback = source[this.callback];\n\n        if (typeof callback === \"function\") {\n          callback.call(source, oldValue, newValue);\n        }\n\n        getNotifier(source).notify(this.name);\n      }\n    }\n\n  }\n\n  class BindingObserverImplementation extends SubscriberSet {\n    constructor(binding, initialSubscriber) {\n      let isVolatileBinding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      super(binding, initialSubscriber);\n      this.binding = binding;\n      this.isVolatileBinding = isVolatileBinding;\n      this.needsRefresh = true;\n      this.needsQueue = true;\n      this.first = this;\n      this.last = null;\n      this.propertySource = void 0;\n      this.propertyName = void 0;\n      this.notifier = void 0;\n      this.next = void 0;\n    }\n\n    observe(source, context) {\n      if (this.needsRefresh && this.last !== null) {\n        this.disconnect();\n      }\n\n      const previousWatcher = watcher;\n      watcher = this.needsRefresh ? this : void 0;\n      this.needsRefresh = this.isVolatileBinding;\n      const result = this.binding(source, context);\n      watcher = previousWatcher;\n      return result;\n    }\n\n    disconnect() {\n      if (this.last !== null) {\n        let current = this.first;\n\n        while (current !== void 0) {\n          current.notifier.unsubscribe(this, current.propertyName);\n          current = current.next;\n        }\n\n        this.last = null;\n        this.needsRefresh = this.needsQueue = true;\n      }\n    }\n\n    watch(propertySource, propertyName) {\n      const prev = this.last;\n      const notifier = getNotifier(propertySource);\n      const current = prev === null ? this.first : {};\n      current.propertySource = propertySource;\n      current.propertyName = propertyName;\n      current.notifier = notifier;\n      notifier.subscribe(this, propertyName);\n\n      if (prev !== null) {\n        if (!this.needsRefresh) {\n          // Declaring the variable prior to assignment below circumvents\n          // a bug in Angular's optimization process causing infinite recursion\n          // of this watch() method. Details https://github.com/microsoft/fast/issues/4969\n          let prevValue;\n          watcher = void 0;\n          /* eslint-disable-next-line */\n\n          prevValue = prev.propertySource[prev.propertyName];\n          /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n\n          watcher = this;\n\n          if (propertySource === prevValue) {\n            this.needsRefresh = true;\n          }\n        }\n\n        prev.next = current;\n      }\n\n      this.last = current;\n    }\n\n    handleChange() {\n      if (this.needsQueue) {\n        this.needsQueue = false;\n        queueUpdate(this);\n      }\n    }\n\n    call() {\n      if (this.last !== null) {\n        this.needsQueue = true;\n        this.notify(this);\n      }\n    }\n\n    records() {\n      let next = this.first;\n      return {\n        next: () => {\n          const current = next;\n\n          if (current === undefined) {\n            return {\n              value: void 0,\n              done: true\n            };\n          } else {\n            next = next.next;\n            return {\n              value: current,\n              done: false\n            };\n          }\n        },\n        [Symbol.iterator]: function () {\n          return this;\n        }\n      };\n    }\n\n  }\n\n  return Object.freeze({\n    /**\n     * @internal\n     * @param factory - The factory used to create array observers.\n     */\n    setArrayObserverFactory(factory) {\n      createArrayObserver = factory;\n    },\n\n    /**\n     * Gets a notifier for an object or Array.\n     * @param source - The object or Array to get the notifier for.\n     */\n    getNotifier,\n\n    /**\n     * Records a property change for a source object.\n     * @param source - The object to record the change against.\n     * @param propertyName - The property to track as changed.\n     */\n    track(source, propertyName) {\n      if (watcher !== void 0) {\n        watcher.watch(source, propertyName);\n      }\n    },\n\n    /**\n     * Notifies watchers that the currently executing property getter or function is volatile\n     * with respect to its observable dependencies.\n     */\n    trackVolatile() {\n      if (watcher !== void 0) {\n        watcher.needsRefresh = true;\n      }\n    },\n\n    /**\n     * Notifies subscribers of a source object of changes.\n     * @param source - the object to notify of changes.\n     * @param args - The change args to pass to subscribers.\n     */\n    notify(source, args) {\n      getNotifier(source).notify(args);\n    },\n\n    /**\n     * Defines an observable property on an object or prototype.\n     * @param target - The target object to define the observable on.\n     * @param nameOrAccessor - The name of the property to define as observable;\n     * or a custom accessor that specifies the property name and accessor implementation.\n     */\n    defineProperty(target, nameOrAccessor) {\n      if (typeof nameOrAccessor === \"string\") {\n        nameOrAccessor = new DefaultObservableAccessor(nameOrAccessor);\n      }\n\n      getAccessors(target).push(nameOrAccessor);\n      Reflect.defineProperty(target, nameOrAccessor.name, {\n        enumerable: true,\n        get: function () {\n          return nameOrAccessor.getValue(this);\n        },\n        set: function (newValue) {\n          nameOrAccessor.setValue(this, newValue);\n        }\n      });\n    },\n\n    /**\n     * Finds all the observable accessors defined on the target,\n     * including its prototype chain.\n     * @param target - The target object to search for accessor on.\n     */\n    getAccessors,\n\n    /**\n     * Creates a {@link BindingObserver} that can watch the\n     * provided {@link Binding} for changes.\n     * @param binding - The binding to observe.\n     * @param initialSubscriber - An initial subscriber to changes in the binding value.\n     * @param isVolatileBinding - Indicates whether the binding's dependency list must be re-evaluated on every value evaluation.\n     */\n    binding(binding, initialSubscriber) {\n      let isVolatileBinding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.isVolatileBinding(binding);\n      return new BindingObserverImplementation(binding, initialSubscriber, isVolatileBinding);\n    },\n\n    /**\n     * Determines whether a binding expression is volatile and needs to have its dependency list re-evaluated\n     * on every evaluation of the value.\n     * @param binding - The binding to inspect.\n     */\n    isVolatileBinding(binding) {\n      return volatileRegex.test(binding.toString());\n    }\n\n  });\n});\n/**\n * Decorator: Defines an observable property on the target.\n * @param target - The target to define the observable on.\n * @param nameOrAccessor - The property name or accessor to define the observable as.\n * @public\n */\n\nexport function observable(target, nameOrAccessor) {\n  Observable.defineProperty(target, nameOrAccessor);\n}\n/**\n * Decorator: Marks a property getter as having volatile observable dependencies.\n * @param target - The target that the property is defined on.\n * @param name - The property name.\n * @param name - The existing descriptor.\n * @public\n */\n\nexport function volatile(target, name, descriptor) {\n  return Object.assign({}, descriptor, {\n    get: function () {\n      Observable.trackVolatile();\n      return descriptor.get.apply(this);\n    }\n  });\n}\nconst contextEvent = FAST.getById(3\n/* contextEvent */\n, () => {\n  let current = null;\n  return {\n    get() {\n      return current;\n    },\n\n    set(event) {\n      current = event;\n    }\n\n  };\n});\n/**\n * Provides additional contextual information available to behaviors and expressions.\n * @public\n */\n\nexport class ExecutionContext {\n  constructor() {\n    /**\n     * The index of the current item within a repeat context.\n     */\n    this.index = 0;\n    /**\n     * The length of the current collection within a repeat context.\n     */\n\n    this.length = 0;\n    /**\n     * The parent data object within a repeat context.\n     */\n\n    this.parent = null;\n    /**\n     * The parent execution context when in nested context scenarios.\n     */\n\n    this.parentContext = null;\n  }\n  /**\n   * The current event within an event handler.\n   */\n\n\n  get event() {\n    return contextEvent.get();\n  }\n  /**\n   * Indicates whether the current item within a repeat context\n   * has an even index.\n   */\n\n\n  get isEven() {\n    return this.index % 2 === 0;\n  }\n  /**\n   * Indicates whether the current item within a repeat context\n   * has an odd index.\n   */\n\n\n  get isOdd() {\n    return this.index % 2 !== 0;\n  }\n  /**\n   * Indicates whether the current item within a repeat context\n   * is the first item in the collection.\n   */\n\n\n  get isFirst() {\n    return this.index === 0;\n  }\n  /**\n   * Indicates whether the current item within a repeat context\n   * is somewhere in the middle of the collection.\n   */\n\n\n  get isInMiddle() {\n    return !this.isFirst && !this.isLast;\n  }\n  /**\n   * Indicates whether the current item within a repeat context\n   * is the last item in the collection.\n   */\n\n\n  get isLast() {\n    return this.index === this.length - 1;\n  }\n  /**\n   * Sets the event for the current execution context.\n   * @param event - The event to set.\n   * @internal\n   */\n\n\n  static setEvent(event) {\n    contextEvent.set(event);\n  }\n\n}\nObservable.defineProperty(ExecutionContext.prototype, \"index\");\nObservable.defineProperty(ExecutionContext.prototype, \"length\");\n/**\n * The default execution context used in binding expressions.\n * @public\n */\n\nexport const defaultExecutionContext = Object.seal(new ExecutionContext());","map":{"version":3,"names":["DOM","createMetadataLocator","FAST","PropertyChangeNotifier","SubscriberSet","Observable","getById","volatileRegex","notifierLookup","WeakMap","queueUpdate","watcher","createArrayObserver","array","Error","getNotifier","source","found","$fastController","get","Array","isArray","set","getAccessors","DefaultObservableAccessor","constructor","name","field","callback","getValue","watch","setValue","newValue","oldValue","call","notify","BindingObserverImplementation","binding","initialSubscriber","isVolatileBinding","needsRefresh","needsQueue","first","last","propertySource","propertyName","notifier","next","observe","context","disconnect","previousWatcher","result","current","unsubscribe","prev","subscribe","prevValue","handleChange","records","undefined","value","done","Symbol","iterator","Object","freeze","setArrayObserverFactory","factory","track","trackVolatile","args","defineProperty","target","nameOrAccessor","push","Reflect","enumerable","test","toString","observable","volatile","descriptor","assign","apply","contextEvent","event","ExecutionContext","index","length","parent","parentContext","isEven","isOdd","isFirst","isInMiddle","isLast","setEvent","prototype","defaultExecutionContext","seal"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-element/dist/esm/observation/observable.js"],"sourcesContent":["import { DOM } from \"../dom.js\";\nimport { createMetadataLocator, FAST } from \"../platform.js\";\nimport { PropertyChangeNotifier, SubscriberSet } from \"./notifier.js\";\n/**\n * Common Observable APIs.\n * @public\n */\nexport const Observable = FAST.getById(2 /* observable */, () => {\n    const volatileRegex = /(:|&&|\\|\\||if)/;\n    const notifierLookup = new WeakMap();\n    const queueUpdate = DOM.queueUpdate;\n    let watcher = void 0;\n    let createArrayObserver = (array) => {\n        throw new Error(\"Must call enableArrayObservation before observing arrays.\");\n    };\n    function getNotifier(source) {\n        let found = source.$fastController || notifierLookup.get(source);\n        if (found === void 0) {\n            if (Array.isArray(source)) {\n                found = createArrayObserver(source);\n            }\n            else {\n                notifierLookup.set(source, (found = new PropertyChangeNotifier(source)));\n            }\n        }\n        return found;\n    }\n    const getAccessors = createMetadataLocator();\n    class DefaultObservableAccessor {\n        constructor(name) {\n            this.name = name;\n            this.field = `_${name}`;\n            this.callback = `${name}Changed`;\n        }\n        getValue(source) {\n            if (watcher !== void 0) {\n                watcher.watch(source, this.name);\n            }\n            return source[this.field];\n        }\n        setValue(source, newValue) {\n            const field = this.field;\n            const oldValue = source[field];\n            if (oldValue !== newValue) {\n                source[field] = newValue;\n                const callback = source[this.callback];\n                if (typeof callback === \"function\") {\n                    callback.call(source, oldValue, newValue);\n                }\n                getNotifier(source).notify(this.name);\n            }\n        }\n    }\n    class BindingObserverImplementation extends SubscriberSet {\n        constructor(binding, initialSubscriber, isVolatileBinding = false) {\n            super(binding, initialSubscriber);\n            this.binding = binding;\n            this.isVolatileBinding = isVolatileBinding;\n            this.needsRefresh = true;\n            this.needsQueue = true;\n            this.first = this;\n            this.last = null;\n            this.propertySource = void 0;\n            this.propertyName = void 0;\n            this.notifier = void 0;\n            this.next = void 0;\n        }\n        observe(source, context) {\n            if (this.needsRefresh && this.last !== null) {\n                this.disconnect();\n            }\n            const previousWatcher = watcher;\n            watcher = this.needsRefresh ? this : void 0;\n            this.needsRefresh = this.isVolatileBinding;\n            const result = this.binding(source, context);\n            watcher = previousWatcher;\n            return result;\n        }\n        disconnect() {\n            if (this.last !== null) {\n                let current = this.first;\n                while (current !== void 0) {\n                    current.notifier.unsubscribe(this, current.propertyName);\n                    current = current.next;\n                }\n                this.last = null;\n                this.needsRefresh = this.needsQueue = true;\n            }\n        }\n        watch(propertySource, propertyName) {\n            const prev = this.last;\n            const notifier = getNotifier(propertySource);\n            const current = prev === null ? this.first : {};\n            current.propertySource = propertySource;\n            current.propertyName = propertyName;\n            current.notifier = notifier;\n            notifier.subscribe(this, propertyName);\n            if (prev !== null) {\n                if (!this.needsRefresh) {\n                    // Declaring the variable prior to assignment below circumvents\n                    // a bug in Angular's optimization process causing infinite recursion\n                    // of this watch() method. Details https://github.com/microsoft/fast/issues/4969\n                    let prevValue;\n                    watcher = void 0;\n                    /* eslint-disable-next-line */\n                    prevValue = prev.propertySource[prev.propertyName];\n                    /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n                    watcher = this;\n                    if (propertySource === prevValue) {\n                        this.needsRefresh = true;\n                    }\n                }\n                prev.next = current;\n            }\n            this.last = current;\n        }\n        handleChange() {\n            if (this.needsQueue) {\n                this.needsQueue = false;\n                queueUpdate(this);\n            }\n        }\n        call() {\n            if (this.last !== null) {\n                this.needsQueue = true;\n                this.notify(this);\n            }\n        }\n        records() {\n            let next = this.first;\n            return {\n                next: () => {\n                    const current = next;\n                    if (current === undefined) {\n                        return { value: void 0, done: true };\n                    }\n                    else {\n                        next = next.next;\n                        return {\n                            value: current,\n                            done: false,\n                        };\n                    }\n                },\n                [Symbol.iterator]: function () {\n                    return this;\n                },\n            };\n        }\n    }\n    return Object.freeze({\n        /**\n         * @internal\n         * @param factory - The factory used to create array observers.\n         */\n        setArrayObserverFactory(factory) {\n            createArrayObserver = factory;\n        },\n        /**\n         * Gets a notifier for an object or Array.\n         * @param source - The object or Array to get the notifier for.\n         */\n        getNotifier,\n        /**\n         * Records a property change for a source object.\n         * @param source - The object to record the change against.\n         * @param propertyName - The property to track as changed.\n         */\n        track(source, propertyName) {\n            if (watcher !== void 0) {\n                watcher.watch(source, propertyName);\n            }\n        },\n        /**\n         * Notifies watchers that the currently executing property getter or function is volatile\n         * with respect to its observable dependencies.\n         */\n        trackVolatile() {\n            if (watcher !== void 0) {\n                watcher.needsRefresh = true;\n            }\n        },\n        /**\n         * Notifies subscribers of a source object of changes.\n         * @param source - the object to notify of changes.\n         * @param args - The change args to pass to subscribers.\n         */\n        notify(source, args) {\n            getNotifier(source).notify(args);\n        },\n        /**\n         * Defines an observable property on an object or prototype.\n         * @param target - The target object to define the observable on.\n         * @param nameOrAccessor - The name of the property to define as observable;\n         * or a custom accessor that specifies the property name and accessor implementation.\n         */\n        defineProperty(target, nameOrAccessor) {\n            if (typeof nameOrAccessor === \"string\") {\n                nameOrAccessor = new DefaultObservableAccessor(nameOrAccessor);\n            }\n            getAccessors(target).push(nameOrAccessor);\n            Reflect.defineProperty(target, nameOrAccessor.name, {\n                enumerable: true,\n                get: function () {\n                    return nameOrAccessor.getValue(this);\n                },\n                set: function (newValue) {\n                    nameOrAccessor.setValue(this, newValue);\n                },\n            });\n        },\n        /**\n         * Finds all the observable accessors defined on the target,\n         * including its prototype chain.\n         * @param target - The target object to search for accessor on.\n         */\n        getAccessors,\n        /**\n         * Creates a {@link BindingObserver} that can watch the\n         * provided {@link Binding} for changes.\n         * @param binding - The binding to observe.\n         * @param initialSubscriber - An initial subscriber to changes in the binding value.\n         * @param isVolatileBinding - Indicates whether the binding's dependency list must be re-evaluated on every value evaluation.\n         */\n        binding(binding, initialSubscriber, isVolatileBinding = this.isVolatileBinding(binding)) {\n            return new BindingObserverImplementation(binding, initialSubscriber, isVolatileBinding);\n        },\n        /**\n         * Determines whether a binding expression is volatile and needs to have its dependency list re-evaluated\n         * on every evaluation of the value.\n         * @param binding - The binding to inspect.\n         */\n        isVolatileBinding(binding) {\n            return volatileRegex.test(binding.toString());\n        },\n    });\n});\n/**\n * Decorator: Defines an observable property on the target.\n * @param target - The target to define the observable on.\n * @param nameOrAccessor - The property name or accessor to define the observable as.\n * @public\n */\nexport function observable(target, nameOrAccessor) {\n    Observable.defineProperty(target, nameOrAccessor);\n}\n/**\n * Decorator: Marks a property getter as having volatile observable dependencies.\n * @param target - The target that the property is defined on.\n * @param name - The property name.\n * @param name - The existing descriptor.\n * @public\n */\nexport function volatile(target, name, descriptor) {\n    return Object.assign({}, descriptor, {\n        get: function () {\n            Observable.trackVolatile();\n            return descriptor.get.apply(this);\n        },\n    });\n}\nconst contextEvent = FAST.getById(3 /* contextEvent */, () => {\n    let current = null;\n    return {\n        get() {\n            return current;\n        },\n        set(event) {\n            current = event;\n        },\n    };\n});\n/**\n * Provides additional contextual information available to behaviors and expressions.\n * @public\n */\nexport class ExecutionContext {\n    constructor() {\n        /**\n         * The index of the current item within a repeat context.\n         */\n        this.index = 0;\n        /**\n         * The length of the current collection within a repeat context.\n         */\n        this.length = 0;\n        /**\n         * The parent data object within a repeat context.\n         */\n        this.parent = null;\n        /**\n         * The parent execution context when in nested context scenarios.\n         */\n        this.parentContext = null;\n    }\n    /**\n     * The current event within an event handler.\n     */\n    get event() {\n        return contextEvent.get();\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * has an even index.\n     */\n    get isEven() {\n        return this.index % 2 === 0;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * has an odd index.\n     */\n    get isOdd() {\n        return this.index % 2 !== 0;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * is the first item in the collection.\n     */\n    get isFirst() {\n        return this.index === 0;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * is somewhere in the middle of the collection.\n     */\n    get isInMiddle() {\n        return !this.isFirst && !this.isLast;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * is the last item in the collection.\n     */\n    get isLast() {\n        return this.index === this.length - 1;\n    }\n    /**\n     * Sets the event for the current execution context.\n     * @param event - The event to set.\n     * @internal\n     */\n    static setEvent(event) {\n        contextEvent.set(event);\n    }\n}\nObservable.defineProperty(ExecutionContext.prototype, \"index\");\nObservable.defineProperty(ExecutionContext.prototype, \"length\");\n/**\n * The default execution context used in binding expressions.\n * @public\n */\nexport const defaultExecutionContext = Object.seal(new ExecutionContext());\n"],"mappings":"AAAA,SAASA,GAAT,QAAoB,WAApB;AACA,SAASC,qBAAT,EAAgCC,IAAhC,QAA4C,gBAA5C;AACA,SAASC,sBAAT,EAAiCC,aAAjC,QAAsD,eAAtD;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,UAAU,GAAGH,IAAI,CAACI,OAAL,CAAa;AAAE;AAAf,EAAiC,MAAM;EAC7D,MAAMC,aAAa,GAAG,gBAAtB;EACA,MAAMC,cAAc,GAAG,IAAIC,OAAJ,EAAvB;EACA,MAAMC,WAAW,GAAGV,GAAG,CAACU,WAAxB;EACA,IAAIC,OAAO,GAAG,KAAK,CAAnB;;EACA,IAAIC,mBAAmB,GAAIC,KAAD,IAAW;IACjC,MAAM,IAAIC,KAAJ,CAAU,2DAAV,CAAN;EACH,CAFD;;EAGA,SAASC,WAAT,CAAqBC,MAArB,EAA6B;IACzB,IAAIC,KAAK,GAAGD,MAAM,CAACE,eAAP,IAA0BV,cAAc,CAACW,GAAf,CAAmBH,MAAnB,CAAtC;;IACA,IAAIC,KAAK,KAAK,KAAK,CAAnB,EAAsB;MAClB,IAAIG,KAAK,CAACC,OAAN,CAAcL,MAAd,CAAJ,EAA2B;QACvBC,KAAK,GAAGL,mBAAmB,CAACI,MAAD,CAA3B;MACH,CAFD,MAGK;QACDR,cAAc,CAACc,GAAf,CAAmBN,MAAnB,EAA4BC,KAAK,GAAG,IAAId,sBAAJ,CAA2Ba,MAA3B,CAApC;MACH;IACJ;;IACD,OAAOC,KAAP;EACH;;EACD,MAAMM,YAAY,GAAGtB,qBAAqB,EAA1C;;EACA,MAAMuB,yBAAN,CAAgC;IAC5BC,WAAW,CAACC,IAAD,EAAO;MACd,KAAKA,IAAL,GAAYA,IAAZ;MACA,KAAKC,KAAL,GAAc,IAAGD,IAAK,EAAtB;MACA,KAAKE,QAAL,GAAiB,GAAEF,IAAK,SAAxB;IACH;;IACDG,QAAQ,CAACb,MAAD,EAAS;MACb,IAAIL,OAAO,KAAK,KAAK,CAArB,EAAwB;QACpBA,OAAO,CAACmB,KAAR,CAAcd,MAAd,EAAsB,KAAKU,IAA3B;MACH;;MACD,OAAOV,MAAM,CAAC,KAAKW,KAAN,CAAb;IACH;;IACDI,QAAQ,CAACf,MAAD,EAASgB,QAAT,EAAmB;MACvB,MAAML,KAAK,GAAG,KAAKA,KAAnB;MACA,MAAMM,QAAQ,GAAGjB,MAAM,CAACW,KAAD,CAAvB;;MACA,IAAIM,QAAQ,KAAKD,QAAjB,EAA2B;QACvBhB,MAAM,CAACW,KAAD,CAAN,GAAgBK,QAAhB;QACA,MAAMJ,QAAQ,GAAGZ,MAAM,CAAC,KAAKY,QAAN,CAAvB;;QACA,IAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;UAChCA,QAAQ,CAACM,IAAT,CAAclB,MAAd,EAAsBiB,QAAtB,EAAgCD,QAAhC;QACH;;QACDjB,WAAW,CAACC,MAAD,CAAX,CAAoBmB,MAApB,CAA2B,KAAKT,IAAhC;MACH;IACJ;;EAvB2B;;EAyBhC,MAAMU,6BAAN,SAA4ChC,aAA5C,CAA0D;IACtDqB,WAAW,CAACY,OAAD,EAAUC,iBAAV,EAAwD;MAAA,IAA3BC,iBAA2B,uEAAP,KAAO;MAC/D,MAAMF,OAAN,EAAeC,iBAAf;MACA,KAAKD,OAAL,GAAeA,OAAf;MACA,KAAKE,iBAAL,GAAyBA,iBAAzB;MACA,KAAKC,YAAL,GAAoB,IAApB;MACA,KAAKC,UAAL,GAAkB,IAAlB;MACA,KAAKC,KAAL,GAAa,IAAb;MACA,KAAKC,IAAL,GAAY,IAAZ;MACA,KAAKC,cAAL,GAAsB,KAAK,CAA3B;MACA,KAAKC,YAAL,GAAoB,KAAK,CAAzB;MACA,KAAKC,QAAL,GAAgB,KAAK,CAArB;MACA,KAAKC,IAAL,GAAY,KAAK,CAAjB;IACH;;IACDC,OAAO,CAAChC,MAAD,EAASiC,OAAT,EAAkB;MACrB,IAAI,KAAKT,YAAL,IAAqB,KAAKG,IAAL,KAAc,IAAvC,EAA6C;QACzC,KAAKO,UAAL;MACH;;MACD,MAAMC,eAAe,GAAGxC,OAAxB;MACAA,OAAO,GAAG,KAAK6B,YAAL,GAAoB,IAApB,GAA2B,KAAK,CAA1C;MACA,KAAKA,YAAL,GAAoB,KAAKD,iBAAzB;MACA,MAAMa,MAAM,GAAG,KAAKf,OAAL,CAAarB,MAAb,EAAqBiC,OAArB,CAAf;MACAtC,OAAO,GAAGwC,eAAV;MACA,OAAOC,MAAP;IACH;;IACDF,UAAU,GAAG;MACT,IAAI,KAAKP,IAAL,KAAc,IAAlB,EAAwB;QACpB,IAAIU,OAAO,GAAG,KAAKX,KAAnB;;QACA,OAAOW,OAAO,KAAK,KAAK,CAAxB,EAA2B;UACvBA,OAAO,CAACP,QAAR,CAAiBQ,WAAjB,CAA6B,IAA7B,EAAmCD,OAAO,CAACR,YAA3C;UACAQ,OAAO,GAAGA,OAAO,CAACN,IAAlB;QACH;;QACD,KAAKJ,IAAL,GAAY,IAAZ;QACA,KAAKH,YAAL,GAAoB,KAAKC,UAAL,GAAkB,IAAtC;MACH;IACJ;;IACDX,KAAK,CAACc,cAAD,EAAiBC,YAAjB,EAA+B;MAChC,MAAMU,IAAI,GAAG,KAAKZ,IAAlB;MACA,MAAMG,QAAQ,GAAG/B,WAAW,CAAC6B,cAAD,CAA5B;MACA,MAAMS,OAAO,GAAGE,IAAI,KAAK,IAAT,GAAgB,KAAKb,KAArB,GAA6B,EAA7C;MACAW,OAAO,CAACT,cAAR,GAAyBA,cAAzB;MACAS,OAAO,CAACR,YAAR,GAAuBA,YAAvB;MACAQ,OAAO,CAACP,QAAR,GAAmBA,QAAnB;MACAA,QAAQ,CAACU,SAAT,CAAmB,IAAnB,EAAyBX,YAAzB;;MACA,IAAIU,IAAI,KAAK,IAAb,EAAmB;QACf,IAAI,CAAC,KAAKf,YAAV,EAAwB;UACpB;UACA;UACA;UACA,IAAIiB,SAAJ;UACA9C,OAAO,GAAG,KAAK,CAAf;UACA;;UACA8C,SAAS,GAAGF,IAAI,CAACX,cAAL,CAAoBW,IAAI,CAACV,YAAzB,CAAZ;UACA;;UACAlC,OAAO,GAAG,IAAV;;UACA,IAAIiC,cAAc,KAAKa,SAAvB,EAAkC;YAC9B,KAAKjB,YAAL,GAAoB,IAApB;UACH;QACJ;;QACDe,IAAI,CAACR,IAAL,GAAYM,OAAZ;MACH;;MACD,KAAKV,IAAL,GAAYU,OAAZ;IACH;;IACDK,YAAY,GAAG;MACX,IAAI,KAAKjB,UAAT,EAAqB;QACjB,KAAKA,UAAL,GAAkB,KAAlB;QACA/B,WAAW,CAAC,IAAD,CAAX;MACH;IACJ;;IACDwB,IAAI,GAAG;MACH,IAAI,KAAKS,IAAL,KAAc,IAAlB,EAAwB;QACpB,KAAKF,UAAL,GAAkB,IAAlB;QACA,KAAKN,MAAL,CAAY,IAAZ;MACH;IACJ;;IACDwB,OAAO,GAAG;MACN,IAAIZ,IAAI,GAAG,KAAKL,KAAhB;MACA,OAAO;QACHK,IAAI,EAAE,MAAM;UACR,MAAMM,OAAO,GAAGN,IAAhB;;UACA,IAAIM,OAAO,KAAKO,SAAhB,EAA2B;YACvB,OAAO;cAAEC,KAAK,EAAE,KAAK,CAAd;cAAiBC,IAAI,EAAE;YAAvB,CAAP;UACH,CAFD,MAGK;YACDf,IAAI,GAAGA,IAAI,CAACA,IAAZ;YACA,OAAO;cACHc,KAAK,EAAER,OADJ;cAEHS,IAAI,EAAE;YAFH,CAAP;UAIH;QACJ,CAbE;QAcH,CAACC,MAAM,CAACC,QAAR,GAAmB,YAAY;UAC3B,OAAO,IAAP;QACH;MAhBE,CAAP;IAkBH;;EA/FqD;;EAiG1D,OAAOC,MAAM,CAACC,MAAP,CAAc;IACjB;AACR;AACA;AACA;IACQC,uBAAuB,CAACC,OAAD,EAAU;MAC7BxD,mBAAmB,GAAGwD,OAAtB;IACH,CAPgB;;IAQjB;AACR;AACA;AACA;IACQrD,WAZiB;;IAajB;AACR;AACA;AACA;AACA;IACQsD,KAAK,CAACrD,MAAD,EAAS6B,YAAT,EAAuB;MACxB,IAAIlC,OAAO,KAAK,KAAK,CAArB,EAAwB;QACpBA,OAAO,CAACmB,KAAR,CAAcd,MAAd,EAAsB6B,YAAtB;MACH;IACJ,CAtBgB;;IAuBjB;AACR;AACA;AACA;IACQyB,aAAa,GAAG;MACZ,IAAI3D,OAAO,KAAK,KAAK,CAArB,EAAwB;QACpBA,OAAO,CAAC6B,YAAR,GAAuB,IAAvB;MACH;IACJ,CA/BgB;;IAgCjB;AACR;AACA;AACA;AACA;IACQL,MAAM,CAACnB,MAAD,EAASuD,IAAT,EAAe;MACjBxD,WAAW,CAACC,MAAD,CAAX,CAAoBmB,MAApB,CAA2BoC,IAA3B;IACH,CAvCgB;;IAwCjB;AACR;AACA;AACA;AACA;AACA;IACQC,cAAc,CAACC,MAAD,EAASC,cAAT,EAAyB;MACnC,IAAI,OAAOA,cAAP,KAA0B,QAA9B,EAAwC;QACpCA,cAAc,GAAG,IAAIlD,yBAAJ,CAA8BkD,cAA9B,CAAjB;MACH;;MACDnD,YAAY,CAACkD,MAAD,CAAZ,CAAqBE,IAArB,CAA0BD,cAA1B;MACAE,OAAO,CAACJ,cAAR,CAAuBC,MAAvB,EAA+BC,cAAc,CAAChD,IAA9C,EAAoD;QAChDmD,UAAU,EAAE,IADoC;QAEhD1D,GAAG,EAAE,YAAY;UACb,OAAOuD,cAAc,CAAC7C,QAAf,CAAwB,IAAxB,CAAP;QACH,CAJ+C;QAKhDP,GAAG,EAAE,UAAUU,QAAV,EAAoB;UACrB0C,cAAc,CAAC3C,QAAf,CAAwB,IAAxB,EAA8BC,QAA9B;QACH;MAP+C,CAApD;IASH,CA5DgB;;IA6DjB;AACR;AACA;AACA;AACA;IACQT,YAlEiB;;IAmEjB;AACR;AACA;AACA;AACA;AACA;AACA;IACQc,OAAO,CAACA,OAAD,EAAUC,iBAAV,EAAkF;MAAA,IAArDC,iBAAqD,uEAAjC,KAAKA,iBAAL,CAAuBF,OAAvB,CAAiC;MACrF,OAAO,IAAID,6BAAJ,CAAkCC,OAAlC,EAA2CC,iBAA3C,EAA8DC,iBAA9D,CAAP;IACH,CA5EgB;;IA6EjB;AACR;AACA;AACA;AACA;IACQA,iBAAiB,CAACF,OAAD,EAAU;MACvB,OAAO9B,aAAa,CAACuE,IAAd,CAAmBzC,OAAO,CAAC0C,QAAR,EAAnB,CAAP;IACH;;EApFgB,CAAd,CAAP;AAsFH,CArOyB,CAAnB;AAsOP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,UAAT,CAAoBP,MAApB,EAA4BC,cAA5B,EAA4C;EAC/CrE,UAAU,CAACmE,cAAX,CAA0BC,MAA1B,EAAkCC,cAAlC;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASO,QAAT,CAAkBR,MAAlB,EAA0B/C,IAA1B,EAAgCwD,UAAhC,EAA4C;EAC/C,OAAOjB,MAAM,CAACkB,MAAP,CAAc,EAAd,EAAkBD,UAAlB,EAA8B;IACjC/D,GAAG,EAAE,YAAY;MACbd,UAAU,CAACiE,aAAX;MACA,OAAOY,UAAU,CAAC/D,GAAX,CAAeiE,KAAf,CAAqB,IAArB,CAAP;IACH;EAJgC,CAA9B,CAAP;AAMH;AACD,MAAMC,YAAY,GAAGnF,IAAI,CAACI,OAAL,CAAa;AAAE;AAAf,EAAmC,MAAM;EAC1D,IAAI+C,OAAO,GAAG,IAAd;EACA,OAAO;IACHlC,GAAG,GAAG;MACF,OAAOkC,OAAP;IACH,CAHE;;IAIH/B,GAAG,CAACgE,KAAD,EAAQ;MACPjC,OAAO,GAAGiC,KAAV;IACH;;EANE,CAAP;AAQH,CAVoB,CAArB;AAWA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,gBAAN,CAAuB;EAC1B9D,WAAW,GAAG;IACV;AACR;AACA;IACQ,KAAK+D,KAAL,GAAa,CAAb;IACA;AACR;AACA;;IACQ,KAAKC,MAAL,GAAc,CAAd;IACA;AACR;AACA;;IACQ,KAAKC,MAAL,GAAc,IAAd;IACA;AACR;AACA;;IACQ,KAAKC,aAAL,GAAqB,IAArB;EACH;EACD;AACJ;AACA;;;EACa,IAALL,KAAK,GAAG;IACR,OAAOD,YAAY,CAAClE,GAAb,EAAP;EACH;EACD;AACJ;AACA;AACA;;;EACc,IAANyE,MAAM,GAAG;IACT,OAAO,KAAKJ,KAAL,GAAa,CAAb,KAAmB,CAA1B;EACH;EACD;AACJ;AACA;AACA;;;EACa,IAALK,KAAK,GAAG;IACR,OAAO,KAAKL,KAAL,GAAa,CAAb,KAAmB,CAA1B;EACH;EACD;AACJ;AACA;AACA;;;EACe,IAAPM,OAAO,GAAG;IACV,OAAO,KAAKN,KAAL,KAAe,CAAtB;EACH;EACD;AACJ;AACA;AACA;;;EACkB,IAAVO,UAAU,GAAG;IACb,OAAO,CAAC,KAAKD,OAAN,IAAiB,CAAC,KAAKE,MAA9B;EACH;EACD;AACJ;AACA;AACA;;;EACc,IAANA,MAAM,GAAG;IACT,OAAO,KAAKR,KAAL,KAAe,KAAKC,MAAL,GAAc,CAApC;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACmB,OAARQ,QAAQ,CAACX,KAAD,EAAQ;IACnBD,YAAY,CAAC/D,GAAb,CAAiBgE,KAAjB;EACH;;AAnEyB;AAqE9BjF,UAAU,CAACmE,cAAX,CAA0Be,gBAAgB,CAACW,SAA3C,EAAsD,OAAtD;AACA7F,UAAU,CAACmE,cAAX,CAA0Be,gBAAgB,CAACW,SAA3C,EAAsD,QAAtD;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,uBAAuB,GAAGlC,MAAM,CAACmC,IAAP,CAAY,IAAIb,gBAAJ,EAAZ,CAAhC"},"metadata":{},"sourceType":"module"}