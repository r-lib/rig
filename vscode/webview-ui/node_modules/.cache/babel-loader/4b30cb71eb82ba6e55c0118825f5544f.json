{"ast":null,"code":"import { DOM } from \"../dom.js\";\nimport { PropertyChangeNotifier } from \"../observation/notifier.js\";\nimport { defaultExecutionContext, Observable } from \"../observation/observable.js\";\nimport { FASTElementDefinition } from \"./fast-definitions.js\";\nconst shadowRoots = new WeakMap();\nconst defaultEventOptions = {\n  bubbles: true,\n  composed: true,\n  cancelable: true\n};\n\nfunction getShadowRoot(element) {\n  return element.shadowRoot || shadowRoots.get(element) || null;\n}\n/**\n * Controls the lifecycle and rendering of a `FASTElement`.\n * @public\n */\n\n\nexport class Controller extends PropertyChangeNotifier {\n  /**\n   * Creates a Controller to control the specified element.\n   * @param element - The element to be controlled by this controller.\n   * @param definition - The element definition metadata that instructs this\n   * controller in how to handle rendering and other platform integrations.\n   * @internal\n   */\n  constructor(element, definition) {\n    super(element);\n    this.boundObservables = null;\n    this.behaviors = null;\n    this.needsInitialization = true;\n    this._template = null;\n    this._styles = null;\n    this._isConnected = false;\n    /**\n     * This allows Observable.getNotifier(...) to return the Controller\n     * when the notifier for the Controller itself is being requested. The\n     * result is that the Observable system does not need to create a separate\n     * instance of Notifier for observables on the Controller. The component and\n     * the controller will now share the same notifier, removing one-object construct\n     * per web component instance.\n     */\n\n    this.$fastController = this;\n    /**\n     * The view associated with the custom element.\n     * @remarks\n     * If `null` then the element is managing its own rendering.\n     */\n\n    this.view = null;\n    this.element = element;\n    this.definition = definition;\n    const shadowOptions = definition.shadowOptions;\n\n    if (shadowOptions !== void 0) {\n      const shadowRoot = element.attachShadow(shadowOptions);\n\n      if (shadowOptions.mode === \"closed\") {\n        shadowRoots.set(element, shadowRoot);\n      }\n    } // Capture any observable values that were set by the binding engine before\n    // the browser upgraded the element. Then delete the property since it will\n    // shadow the getter/setter that is required to make the observable operate.\n    // Later, in the connect callback, we'll re-apply the values.\n\n\n    const accessors = Observable.getAccessors(element);\n\n    if (accessors.length > 0) {\n      const boundObservables = this.boundObservables = Object.create(null);\n\n      for (let i = 0, ii = accessors.length; i < ii; ++i) {\n        const propertyName = accessors[i].name;\n        const value = element[propertyName];\n\n        if (value !== void 0) {\n          delete element[propertyName];\n          boundObservables[propertyName] = value;\n        }\n      }\n    }\n  }\n  /**\n   * Indicates whether or not the custom element has been\n   * connected to the document.\n   */\n\n\n  get isConnected() {\n    Observable.track(this, \"isConnected\");\n    return this._isConnected;\n  }\n\n  setIsConnected(value) {\n    this._isConnected = value;\n    Observable.notify(this, \"isConnected\");\n  }\n  /**\n   * Gets/sets the template used to render the component.\n   * @remarks\n   * This value can only be accurately read after connect but can be set at any time.\n   */\n\n\n  get template() {\n    return this._template;\n  }\n\n  set template(value) {\n    if (this._template === value) {\n      return;\n    }\n\n    this._template = value;\n\n    if (!this.needsInitialization) {\n      this.renderTemplate(value);\n    }\n  }\n  /**\n   * Gets/sets the primary styles used for the component.\n   * @remarks\n   * This value can only be accurately read after connect but can be set at any time.\n   */\n\n\n  get styles() {\n    return this._styles;\n  }\n\n  set styles(value) {\n    if (this._styles === value) {\n      return;\n    }\n\n    if (this._styles !== null) {\n      this.removeStyles(this._styles);\n    }\n\n    this._styles = value;\n\n    if (!this.needsInitialization && value !== null) {\n      this.addStyles(value);\n    }\n  }\n  /**\n   * Adds styles to this element. Providing an HTMLStyleElement will attach the element instance to the shadowRoot.\n   * @param styles - The styles to add.\n   */\n\n\n  addStyles(styles) {\n    const target = getShadowRoot(this.element) || this.element.getRootNode();\n\n    if (styles instanceof HTMLStyleElement) {\n      target.append(styles);\n    } else if (!styles.isAttachedTo(target)) {\n      const sourceBehaviors = styles.behaviors;\n      styles.addStylesTo(target);\n\n      if (sourceBehaviors !== null) {\n        this.addBehaviors(sourceBehaviors);\n      }\n    }\n  }\n  /**\n   * Removes styles from this element. Providing an HTMLStyleElement will detach the element instance from the shadowRoot.\n   * @param styles - the styles to remove.\n   */\n\n\n  removeStyles(styles) {\n    const target = getShadowRoot(this.element) || this.element.getRootNode();\n\n    if (styles instanceof HTMLStyleElement) {\n      target.removeChild(styles);\n    } else if (styles.isAttachedTo(target)) {\n      const sourceBehaviors = styles.behaviors;\n      styles.removeStylesFrom(target);\n\n      if (sourceBehaviors !== null) {\n        this.removeBehaviors(sourceBehaviors);\n      }\n    }\n  }\n  /**\n   * Adds behaviors to this element.\n   * @param behaviors - The behaviors to add.\n   */\n\n\n  addBehaviors(behaviors) {\n    const targetBehaviors = this.behaviors || (this.behaviors = new Map());\n    const length = behaviors.length;\n    const behaviorsToBind = [];\n\n    for (let i = 0; i < length; ++i) {\n      const behavior = behaviors[i];\n\n      if (targetBehaviors.has(behavior)) {\n        targetBehaviors.set(behavior, targetBehaviors.get(behavior) + 1);\n      } else {\n        targetBehaviors.set(behavior, 1);\n        behaviorsToBind.push(behavior);\n      }\n    }\n\n    if (this._isConnected) {\n      const element = this.element;\n\n      for (let i = 0; i < behaviorsToBind.length; ++i) {\n        behaviorsToBind[i].bind(element, defaultExecutionContext);\n      }\n    }\n  }\n  /**\n   * Removes behaviors from this element.\n   * @param behaviors - The behaviors to remove.\n   * @param force - Forces unbinding of behaviors.\n   */\n\n\n  removeBehaviors(behaviors) {\n    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const targetBehaviors = this.behaviors;\n\n    if (targetBehaviors === null) {\n      return;\n    }\n\n    const length = behaviors.length;\n    const behaviorsToUnbind = [];\n\n    for (let i = 0; i < length; ++i) {\n      const behavior = behaviors[i];\n\n      if (targetBehaviors.has(behavior)) {\n        const count = targetBehaviors.get(behavior) - 1;\n        count === 0 || force ? targetBehaviors.delete(behavior) && behaviorsToUnbind.push(behavior) : targetBehaviors.set(behavior, count);\n      }\n    }\n\n    if (this._isConnected) {\n      const element = this.element;\n\n      for (let i = 0; i < behaviorsToUnbind.length; ++i) {\n        behaviorsToUnbind[i].unbind(element);\n      }\n    }\n  }\n  /**\n   * Runs connected lifecycle behavior on the associated element.\n   */\n\n\n  onConnectedCallback() {\n    if (this._isConnected) {\n      return;\n    }\n\n    const element = this.element;\n\n    if (this.needsInitialization) {\n      this.finishInitialization();\n    } else if (this.view !== null) {\n      this.view.bind(element, defaultExecutionContext);\n    }\n\n    const behaviors = this.behaviors;\n\n    if (behaviors !== null) {\n      for (const [behavior] of behaviors) {\n        behavior.bind(element, defaultExecutionContext);\n      }\n    }\n\n    this.setIsConnected(true);\n  }\n  /**\n   * Runs disconnected lifecycle behavior on the associated element.\n   */\n\n\n  onDisconnectedCallback() {\n    if (!this._isConnected) {\n      return;\n    }\n\n    this.setIsConnected(false);\n    const view = this.view;\n\n    if (view !== null) {\n      view.unbind();\n    }\n\n    const behaviors = this.behaviors;\n\n    if (behaviors !== null) {\n      const element = this.element;\n\n      for (const [behavior] of behaviors) {\n        behavior.unbind(element);\n      }\n    }\n  }\n  /**\n   * Runs the attribute changed callback for the associated element.\n   * @param name - The name of the attribute that changed.\n   * @param oldValue - The previous value of the attribute.\n   * @param newValue - The new value of the attribute.\n   */\n\n\n  onAttributeChangedCallback(name, oldValue, newValue) {\n    const attrDef = this.definition.attributeLookup[name];\n\n    if (attrDef !== void 0) {\n      attrDef.onAttributeChangedCallback(this.element, newValue);\n    }\n  }\n  /**\n   * Emits a custom HTML event.\n   * @param type - The type name of the event.\n   * @param detail - The event detail object to send with the event.\n   * @param options - The event options. By default bubbles and composed.\n   * @remarks\n   * Only emits events if connected.\n   */\n\n\n  emit(type, detail, options) {\n    if (this._isConnected) {\n      return this.element.dispatchEvent(new CustomEvent(type, Object.assign(Object.assign({\n        detail\n      }, defaultEventOptions), options)));\n    }\n\n    return false;\n  }\n\n  finishInitialization() {\n    const element = this.element;\n    const boundObservables = this.boundObservables; // If we have any observables that were bound, re-apply their values.\n\n    if (boundObservables !== null) {\n      const propertyNames = Object.keys(boundObservables);\n\n      for (let i = 0, ii = propertyNames.length; i < ii; ++i) {\n        const propertyName = propertyNames[i];\n        element[propertyName] = boundObservables[propertyName];\n      }\n\n      this.boundObservables = null;\n    }\n\n    const definition = this.definition; // 1. Template overrides take top precedence.\n\n    if (this._template === null) {\n      if (this.element.resolveTemplate) {\n        // 2. Allow for element instance overrides next.\n        this._template = this.element.resolveTemplate();\n      } else if (definition.template) {\n        // 3. Default to the static definition.\n        this._template = definition.template || null;\n      }\n    } // If we have a template after the above process, render it.\n    // If there's no template, then the element author has opted into\n    // custom rendering and they will managed the shadow root's content themselves.\n\n\n    if (this._template !== null) {\n      this.renderTemplate(this._template);\n    } // 1. Styles overrides take top precedence.\n\n\n    if (this._styles === null) {\n      if (this.element.resolveStyles) {\n        // 2. Allow for element instance overrides next.\n        this._styles = this.element.resolveStyles();\n      } else if (definition.styles) {\n        // 3. Default to the static definition.\n        this._styles = definition.styles || null;\n      }\n    } // If we have styles after the above process, add them.\n\n\n    if (this._styles !== null) {\n      this.addStyles(this._styles);\n    }\n\n    this.needsInitialization = false;\n  }\n\n  renderTemplate(template) {\n    const element = this.element; // When getting the host to render to, we start by looking\n    // up the shadow root. If there isn't one, then that means\n    // we're doing a Light DOM render to the element's direct children.\n\n    const host = getShadowRoot(element) || element;\n\n    if (this.view !== null) {\n      // If there's already a view, we need to unbind and remove through dispose.\n      this.view.dispose();\n      this.view = null;\n    } else if (!this.needsInitialization) {\n      // If there was previous custom rendering, we need to clear out the host.\n      DOM.removeChildNodes(host);\n    }\n\n    if (template) {\n      // If a new template was provided, render it.\n      this.view = template.render(element, host, element);\n    }\n  }\n  /**\n   * Locates or creates a controller for the specified element.\n   * @param element - The element to return the controller for.\n   * @remarks\n   * The specified element must have a {@link FASTElementDefinition}\n   * registered either through the use of the {@link customElement}\n   * decorator or a call to `FASTElement.define`.\n   */\n\n\n  static forCustomElement(element) {\n    const controller = element.$fastController;\n\n    if (controller !== void 0) {\n      return controller;\n    }\n\n    const definition = FASTElementDefinition.forType(element.constructor);\n\n    if (definition === void 0) {\n      throw new Error(\"Missing FASTElement definition.\");\n    }\n\n    return element.$fastController = new Controller(element, definition);\n  }\n\n}","map":{"version":3,"names":["DOM","PropertyChangeNotifier","defaultExecutionContext","Observable","FASTElementDefinition","shadowRoots","WeakMap","defaultEventOptions","bubbles","composed","cancelable","getShadowRoot","element","shadowRoot","get","Controller","constructor","definition","boundObservables","behaviors","needsInitialization","_template","_styles","_isConnected","$fastController","view","shadowOptions","attachShadow","mode","set","accessors","getAccessors","length","Object","create","i","ii","propertyName","name","value","isConnected","track","setIsConnected","notify","template","renderTemplate","styles","removeStyles","addStyles","target","getRootNode","HTMLStyleElement","append","isAttachedTo","sourceBehaviors","addStylesTo","addBehaviors","removeChild","removeStylesFrom","removeBehaviors","targetBehaviors","Map","behaviorsToBind","behavior","has","push","bind","force","behaviorsToUnbind","count","delete","unbind","onConnectedCallback","finishInitialization","onDisconnectedCallback","onAttributeChangedCallback","oldValue","newValue","attrDef","attributeLookup","emit","type","detail","options","dispatchEvent","CustomEvent","assign","propertyNames","keys","resolveTemplate","resolveStyles","host","dispose","removeChildNodes","render","forCustomElement","controller","forType","Error"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-element/dist/esm/components/controller.js"],"sourcesContent":["import { DOM } from \"../dom.js\";\nimport { PropertyChangeNotifier } from \"../observation/notifier.js\";\nimport { defaultExecutionContext, Observable } from \"../observation/observable.js\";\nimport { FASTElementDefinition } from \"./fast-definitions.js\";\nconst shadowRoots = new WeakMap();\nconst defaultEventOptions = {\n    bubbles: true,\n    composed: true,\n    cancelable: true,\n};\nfunction getShadowRoot(element) {\n    return element.shadowRoot || shadowRoots.get(element) || null;\n}\n/**\n * Controls the lifecycle and rendering of a `FASTElement`.\n * @public\n */\nexport class Controller extends PropertyChangeNotifier {\n    /**\n     * Creates a Controller to control the specified element.\n     * @param element - The element to be controlled by this controller.\n     * @param definition - The element definition metadata that instructs this\n     * controller in how to handle rendering and other platform integrations.\n     * @internal\n     */\n    constructor(element, definition) {\n        super(element);\n        this.boundObservables = null;\n        this.behaviors = null;\n        this.needsInitialization = true;\n        this._template = null;\n        this._styles = null;\n        this._isConnected = false;\n        /**\n         * This allows Observable.getNotifier(...) to return the Controller\n         * when the notifier for the Controller itself is being requested. The\n         * result is that the Observable system does not need to create a separate\n         * instance of Notifier for observables on the Controller. The component and\n         * the controller will now share the same notifier, removing one-object construct\n         * per web component instance.\n         */\n        this.$fastController = this;\n        /**\n         * The view associated with the custom element.\n         * @remarks\n         * If `null` then the element is managing its own rendering.\n         */\n        this.view = null;\n        this.element = element;\n        this.definition = definition;\n        const shadowOptions = definition.shadowOptions;\n        if (shadowOptions !== void 0) {\n            const shadowRoot = element.attachShadow(shadowOptions);\n            if (shadowOptions.mode === \"closed\") {\n                shadowRoots.set(element, shadowRoot);\n            }\n        }\n        // Capture any observable values that were set by the binding engine before\n        // the browser upgraded the element. Then delete the property since it will\n        // shadow the getter/setter that is required to make the observable operate.\n        // Later, in the connect callback, we'll re-apply the values.\n        const accessors = Observable.getAccessors(element);\n        if (accessors.length > 0) {\n            const boundObservables = (this.boundObservables = Object.create(null));\n            for (let i = 0, ii = accessors.length; i < ii; ++i) {\n                const propertyName = accessors[i].name;\n                const value = element[propertyName];\n                if (value !== void 0) {\n                    delete element[propertyName];\n                    boundObservables[propertyName] = value;\n                }\n            }\n        }\n    }\n    /**\n     * Indicates whether or not the custom element has been\n     * connected to the document.\n     */\n    get isConnected() {\n        Observable.track(this, \"isConnected\");\n        return this._isConnected;\n    }\n    setIsConnected(value) {\n        this._isConnected = value;\n        Observable.notify(this, \"isConnected\");\n    }\n    /**\n     * Gets/sets the template used to render the component.\n     * @remarks\n     * This value can only be accurately read after connect but can be set at any time.\n     */\n    get template() {\n        return this._template;\n    }\n    set template(value) {\n        if (this._template === value) {\n            return;\n        }\n        this._template = value;\n        if (!this.needsInitialization) {\n            this.renderTemplate(value);\n        }\n    }\n    /**\n     * Gets/sets the primary styles used for the component.\n     * @remarks\n     * This value can only be accurately read after connect but can be set at any time.\n     */\n    get styles() {\n        return this._styles;\n    }\n    set styles(value) {\n        if (this._styles === value) {\n            return;\n        }\n        if (this._styles !== null) {\n            this.removeStyles(this._styles);\n        }\n        this._styles = value;\n        if (!this.needsInitialization && value !== null) {\n            this.addStyles(value);\n        }\n    }\n    /**\n     * Adds styles to this element. Providing an HTMLStyleElement will attach the element instance to the shadowRoot.\n     * @param styles - The styles to add.\n     */\n    addStyles(styles) {\n        const target = getShadowRoot(this.element) ||\n            this.element.getRootNode();\n        if (styles instanceof HTMLStyleElement) {\n            target.append(styles);\n        }\n        else if (!styles.isAttachedTo(target)) {\n            const sourceBehaviors = styles.behaviors;\n            styles.addStylesTo(target);\n            if (sourceBehaviors !== null) {\n                this.addBehaviors(sourceBehaviors);\n            }\n        }\n    }\n    /**\n     * Removes styles from this element. Providing an HTMLStyleElement will detach the element instance from the shadowRoot.\n     * @param styles - the styles to remove.\n     */\n    removeStyles(styles) {\n        const target = getShadowRoot(this.element) ||\n            this.element.getRootNode();\n        if (styles instanceof HTMLStyleElement) {\n            target.removeChild(styles);\n        }\n        else if (styles.isAttachedTo(target)) {\n            const sourceBehaviors = styles.behaviors;\n            styles.removeStylesFrom(target);\n            if (sourceBehaviors !== null) {\n                this.removeBehaviors(sourceBehaviors);\n            }\n        }\n    }\n    /**\n     * Adds behaviors to this element.\n     * @param behaviors - The behaviors to add.\n     */\n    addBehaviors(behaviors) {\n        const targetBehaviors = this.behaviors || (this.behaviors = new Map());\n        const length = behaviors.length;\n        const behaviorsToBind = [];\n        for (let i = 0; i < length; ++i) {\n            const behavior = behaviors[i];\n            if (targetBehaviors.has(behavior)) {\n                targetBehaviors.set(behavior, targetBehaviors.get(behavior) + 1);\n            }\n            else {\n                targetBehaviors.set(behavior, 1);\n                behaviorsToBind.push(behavior);\n            }\n        }\n        if (this._isConnected) {\n            const element = this.element;\n            for (let i = 0; i < behaviorsToBind.length; ++i) {\n                behaviorsToBind[i].bind(element, defaultExecutionContext);\n            }\n        }\n    }\n    /**\n     * Removes behaviors from this element.\n     * @param behaviors - The behaviors to remove.\n     * @param force - Forces unbinding of behaviors.\n     */\n    removeBehaviors(behaviors, force = false) {\n        const targetBehaviors = this.behaviors;\n        if (targetBehaviors === null) {\n            return;\n        }\n        const length = behaviors.length;\n        const behaviorsToUnbind = [];\n        for (let i = 0; i < length; ++i) {\n            const behavior = behaviors[i];\n            if (targetBehaviors.has(behavior)) {\n                const count = targetBehaviors.get(behavior) - 1;\n                count === 0 || force\n                    ? targetBehaviors.delete(behavior) && behaviorsToUnbind.push(behavior)\n                    : targetBehaviors.set(behavior, count);\n            }\n        }\n        if (this._isConnected) {\n            const element = this.element;\n            for (let i = 0; i < behaviorsToUnbind.length; ++i) {\n                behaviorsToUnbind[i].unbind(element);\n            }\n        }\n    }\n    /**\n     * Runs connected lifecycle behavior on the associated element.\n     */\n    onConnectedCallback() {\n        if (this._isConnected) {\n            return;\n        }\n        const element = this.element;\n        if (this.needsInitialization) {\n            this.finishInitialization();\n        }\n        else if (this.view !== null) {\n            this.view.bind(element, defaultExecutionContext);\n        }\n        const behaviors = this.behaviors;\n        if (behaviors !== null) {\n            for (const [behavior] of behaviors) {\n                behavior.bind(element, defaultExecutionContext);\n            }\n        }\n        this.setIsConnected(true);\n    }\n    /**\n     * Runs disconnected lifecycle behavior on the associated element.\n     */\n    onDisconnectedCallback() {\n        if (!this._isConnected) {\n            return;\n        }\n        this.setIsConnected(false);\n        const view = this.view;\n        if (view !== null) {\n            view.unbind();\n        }\n        const behaviors = this.behaviors;\n        if (behaviors !== null) {\n            const element = this.element;\n            for (const [behavior] of behaviors) {\n                behavior.unbind(element);\n            }\n        }\n    }\n    /**\n     * Runs the attribute changed callback for the associated element.\n     * @param name - The name of the attribute that changed.\n     * @param oldValue - The previous value of the attribute.\n     * @param newValue - The new value of the attribute.\n     */\n    onAttributeChangedCallback(name, oldValue, newValue) {\n        const attrDef = this.definition.attributeLookup[name];\n        if (attrDef !== void 0) {\n            attrDef.onAttributeChangedCallback(this.element, newValue);\n        }\n    }\n    /**\n     * Emits a custom HTML event.\n     * @param type - The type name of the event.\n     * @param detail - The event detail object to send with the event.\n     * @param options - The event options. By default bubbles and composed.\n     * @remarks\n     * Only emits events if connected.\n     */\n    emit(type, detail, options) {\n        if (this._isConnected) {\n            return this.element.dispatchEvent(new CustomEvent(type, Object.assign(Object.assign({ detail }, defaultEventOptions), options)));\n        }\n        return false;\n    }\n    finishInitialization() {\n        const element = this.element;\n        const boundObservables = this.boundObservables;\n        // If we have any observables that were bound, re-apply their values.\n        if (boundObservables !== null) {\n            const propertyNames = Object.keys(boundObservables);\n            for (let i = 0, ii = propertyNames.length; i < ii; ++i) {\n                const propertyName = propertyNames[i];\n                element[propertyName] = boundObservables[propertyName];\n            }\n            this.boundObservables = null;\n        }\n        const definition = this.definition;\n        // 1. Template overrides take top precedence.\n        if (this._template === null) {\n            if (this.element.resolveTemplate) {\n                // 2. Allow for element instance overrides next.\n                this._template = this.element.resolveTemplate();\n            }\n            else if (definition.template) {\n                // 3. Default to the static definition.\n                this._template = definition.template || null;\n            }\n        }\n        // If we have a template after the above process, render it.\n        // If there's no template, then the element author has opted into\n        // custom rendering and they will managed the shadow root's content themselves.\n        if (this._template !== null) {\n            this.renderTemplate(this._template);\n        }\n        // 1. Styles overrides take top precedence.\n        if (this._styles === null) {\n            if (this.element.resolveStyles) {\n                // 2. Allow for element instance overrides next.\n                this._styles = this.element.resolveStyles();\n            }\n            else if (definition.styles) {\n                // 3. Default to the static definition.\n                this._styles = definition.styles || null;\n            }\n        }\n        // If we have styles after the above process, add them.\n        if (this._styles !== null) {\n            this.addStyles(this._styles);\n        }\n        this.needsInitialization = false;\n    }\n    renderTemplate(template) {\n        const element = this.element;\n        // When getting the host to render to, we start by looking\n        // up the shadow root. If there isn't one, then that means\n        // we're doing a Light DOM render to the element's direct children.\n        const host = getShadowRoot(element) || element;\n        if (this.view !== null) {\n            // If there's already a view, we need to unbind and remove through dispose.\n            this.view.dispose();\n            this.view = null;\n        }\n        else if (!this.needsInitialization) {\n            // If there was previous custom rendering, we need to clear out the host.\n            DOM.removeChildNodes(host);\n        }\n        if (template) {\n            // If a new template was provided, render it.\n            this.view = template.render(element, host, element);\n        }\n    }\n    /**\n     * Locates or creates a controller for the specified element.\n     * @param element - The element to return the controller for.\n     * @remarks\n     * The specified element must have a {@link FASTElementDefinition}\n     * registered either through the use of the {@link customElement}\n     * decorator or a call to `FASTElement.define`.\n     */\n    static forCustomElement(element) {\n        const controller = element.$fastController;\n        if (controller !== void 0) {\n            return controller;\n        }\n        const definition = FASTElementDefinition.forType(element.constructor);\n        if (definition === void 0) {\n            throw new Error(\"Missing FASTElement definition.\");\n        }\n        return (element.$fastController = new Controller(element, definition));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}