{"ast":null,"code":"import { emptyArray } from \"../platform.js\";\n/** @internal */\n\nexport function newSplice(index, removed, addedCount) {\n  return {\n    index: index,\n    removed: removed,\n    addedCount: addedCount\n  };\n}\nconst EDIT_LEAVE = 0;\nconst EDIT_UPDATE = 1;\nconst EDIT_ADD = 2;\nconst EDIT_DELETE = 3; // Note: This function is *based* on the computation of the Levenshtein\n// \"edit\" distance. The one change is that \"updates\" are treated as two\n// edits - not one. With Array splices, an update is really a delete\n// followed by an add. By retaining this, we optimize for \"keeping\" the\n// maximum array items in the original array. For example:\n//\n//   'xxxx123' -> '123yyyy'\n//\n// With 1-edit updates, the shortest path would be just to update all seven\n// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n// leaves the substring '123' intact.\n\nfunction calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  // \"Deletion\" columns\n  const rowCount = oldEnd - oldStart + 1;\n  const columnCount = currentEnd - currentStart + 1;\n  const distances = new Array(rowCount);\n  let north;\n  let west; // \"Addition\" rows. Initialize null column.\n\n  for (let i = 0; i < rowCount; ++i) {\n    distances[i] = new Array(columnCount);\n    distances[i][0] = i;\n  } // Initialize null row\n\n\n  for (let j = 0; j < columnCount; ++j) {\n    distances[0][j] = j;\n  }\n\n  for (let i = 1; i < rowCount; ++i) {\n    for (let j = 1; j < columnCount; ++j) {\n      if (current[currentStart + j - 1] === old[oldStart + i - 1]) {\n        distances[i][j] = distances[i - 1][j - 1];\n      } else {\n        north = distances[i - 1][j] + 1;\n        west = distances[i][j - 1] + 1;\n        distances[i][j] = north < west ? north : west;\n      }\n    }\n  }\n\n  return distances;\n} // This starts at the final weight, and walks \"backward\" by finding\n// the minimum previous weight recursively until the origin of the weight\n// matrix.\n\n\nfunction spliceOperationsFromEditDistances(distances) {\n  let i = distances.length - 1;\n  let j = distances[0].length - 1;\n  let current = distances[i][j];\n  const edits = [];\n\n  while (i > 0 || j > 0) {\n    if (i === 0) {\n      edits.push(EDIT_ADD);\n      j--;\n      continue;\n    }\n\n    if (j === 0) {\n      edits.push(EDIT_DELETE);\n      i--;\n      continue;\n    }\n\n    const northWest = distances[i - 1][j - 1];\n    const west = distances[i - 1][j];\n    const north = distances[i][j - 1];\n    let min;\n\n    if (west < north) {\n      min = west < northWest ? west : northWest;\n    } else {\n      min = north < northWest ? north : northWest;\n    }\n\n    if (min === northWest) {\n      if (northWest === current) {\n        edits.push(EDIT_LEAVE);\n      } else {\n        edits.push(EDIT_UPDATE);\n        current = northWest;\n      }\n\n      i--;\n      j--;\n    } else if (min === west) {\n      edits.push(EDIT_DELETE);\n      i--;\n      current = west;\n    } else {\n      edits.push(EDIT_ADD);\n      j--;\n      current = north;\n    }\n  }\n\n  edits.reverse();\n  return edits;\n}\n\nfunction sharedPrefix(current, old, searchLength) {\n  for (let i = 0; i < searchLength; ++i) {\n    if (current[i] !== old[i]) {\n      return i;\n    }\n  }\n\n  return searchLength;\n}\n\nfunction sharedSuffix(current, old, searchLength) {\n  let index1 = current.length;\n  let index2 = old.length;\n  let count = 0;\n\n  while (count < searchLength && current[--index1] === old[--index2]) {\n    count++;\n  }\n\n  return count;\n}\n\nfunction intersect(start1, end1, start2, end2) {\n  // Disjoint\n  if (end1 < start2 || end2 < start1) {\n    return -1;\n  } // Adjacent\n\n\n  if (end1 === start2 || end2 === start1) {\n    return 0;\n  } // Non-zero intersect, span1 first\n\n\n  if (start1 < start2) {\n    if (end1 < end2) {\n      return end1 - start2; // Overlap\n    }\n\n    return end2 - start2; // Contained\n  } // Non-zero intersect, span2 first\n\n\n  if (end2 < end1) {\n    return end2 - start1; // Overlap\n  }\n\n  return end1 - start1; // Contained\n}\n/**\n * Splice Projection functions:\n *\n * A splice map is a representation of how a previous array of items\n * was transformed into a new array of items. Conceptually it is a list of\n * tuples of\n *\n *   <index, removed, addedCount>\n *\n * which are kept in ascending index order of. The tuple represents that at\n * the |index|, |removed| sequence of items were removed, and counting forward\n * from |index|, |addedCount| items were added.\n */\n\n/**\n * @internal\n * @remarks\n * Lacking individual splice mutation information, the minimal set of\n * splices can be synthesized given the previous state and final state of an\n * array. The basic approach is to calculate the edit distance matrix and\n * choose the shortest path through it.\n *\n * Complexity: O(l * p)\n *   l: The length of the current array\n *   p: The length of the old array\n */\n\n\nexport function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  let prefixCount = 0;\n  let suffixCount = 0;\n  const minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n\n  if (currentStart === 0 && oldStart === 0) {\n    prefixCount = sharedPrefix(current, old, minLength);\n  }\n\n  if (currentEnd === current.length && oldEnd === old.length) {\n    suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n  }\n\n  currentStart += prefixCount;\n  oldStart += prefixCount;\n  currentEnd -= suffixCount;\n  oldEnd -= suffixCount;\n\n  if (currentEnd - currentStart === 0 && oldEnd - oldStart === 0) {\n    return emptyArray;\n  }\n\n  if (currentStart === currentEnd) {\n    const splice = newSplice(currentStart, [], 0);\n\n    while (oldStart < oldEnd) {\n      splice.removed.push(old[oldStart++]);\n    }\n\n    return [splice];\n  } else if (oldStart === oldEnd) {\n    return [newSplice(currentStart, [], currentEnd - currentStart)];\n  }\n\n  const ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n  const splices = [];\n  let splice = void 0;\n  let index = currentStart;\n  let oldIndex = oldStart;\n\n  for (let i = 0; i < ops.length; ++i) {\n    switch (ops[i]) {\n      case EDIT_LEAVE:\n        if (splice !== void 0) {\n          splices.push(splice);\n          splice = void 0;\n        }\n\n        index++;\n        oldIndex++;\n        break;\n\n      case EDIT_UPDATE:\n        if (splice === void 0) {\n          splice = newSplice(index, [], 0);\n        }\n\n        splice.addedCount++;\n        index++;\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n\n      case EDIT_ADD:\n        if (splice === void 0) {\n          splice = newSplice(index, [], 0);\n        }\n\n        splice.addedCount++;\n        index++;\n        break;\n\n      case EDIT_DELETE:\n        if (splice === void 0) {\n          splice = newSplice(index, [], 0);\n        }\n\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n      // no default\n    }\n  }\n\n  if (splice !== void 0) {\n    splices.push(splice);\n  }\n\n  return splices;\n}\nconst $push = Array.prototype.push;\n\nfunction mergeSplice(splices, index, removed, addedCount) {\n  const splice = newSplice(index, removed, addedCount);\n  let inserted = false;\n  let insertionOffset = 0;\n\n  for (let i = 0; i < splices.length; i++) {\n    const current = splices[i];\n    current.index += insertionOffset;\n\n    if (inserted) {\n      continue;\n    }\n\n    const intersectCount = intersect(splice.index, splice.index + splice.removed.length, current.index, current.index + current.addedCount);\n\n    if (intersectCount >= 0) {\n      // Merge the two splices\n      splices.splice(i, 1);\n      i--;\n      insertionOffset -= current.addedCount - current.removed.length;\n      splice.addedCount += current.addedCount - intersectCount;\n      const deleteCount = splice.removed.length + current.removed.length - intersectCount;\n\n      if (!splice.addedCount && !deleteCount) {\n        // merged splice is a noop. discard.\n        inserted = true;\n      } else {\n        let currentRemoved = current.removed;\n\n        if (splice.index < current.index) {\n          // some prefix of splice.removed is prepended to current.removed.\n          const prepend = splice.removed.slice(0, current.index - splice.index);\n          $push.apply(prepend, currentRemoved);\n          currentRemoved = prepend;\n        }\n\n        if (splice.index + splice.removed.length > current.index + current.addedCount) {\n          // some suffix of splice.removed is appended to current.removed.\n          const append = splice.removed.slice(current.index + current.addedCount - splice.index);\n          $push.apply(currentRemoved, append);\n        }\n\n        splice.removed = currentRemoved;\n\n        if (current.index < splice.index) {\n          splice.index = current.index;\n        }\n      }\n    } else if (splice.index < current.index) {\n      // Insert splice here.\n      inserted = true;\n      splices.splice(i, 0, splice);\n      i++;\n      const offset = splice.addedCount - splice.removed.length;\n      current.index += offset;\n      insertionOffset += offset;\n    }\n  }\n\n  if (!inserted) {\n    splices.push(splice);\n  }\n}\n\nfunction createInitialSplices(changeRecords) {\n  const splices = [];\n\n  for (let i = 0, ii = changeRecords.length; i < ii; i++) {\n    const record = changeRecords[i];\n    mergeSplice(splices, record.index, record.removed, record.addedCount);\n  }\n\n  return splices;\n}\n/** @internal */\n\n\nexport function projectArraySplices(array, changeRecords) {\n  let splices = [];\n  const initialSplices = createInitialSplices(changeRecords);\n\n  for (let i = 0, ii = initialSplices.length; i < ii; ++i) {\n    const splice = initialSplices[i];\n\n    if (splice.addedCount === 1 && splice.removed.length === 1) {\n      if (splice.removed[0] !== array[splice.index]) {\n        splices.push(splice);\n      }\n\n      continue;\n    }\n\n    splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));\n  }\n\n  return splices;\n}","map":{"version":3,"names":["emptyArray","newSplice","index","removed","addedCount","EDIT_LEAVE","EDIT_UPDATE","EDIT_ADD","EDIT_DELETE","calcEditDistances","current","currentStart","currentEnd","old","oldStart","oldEnd","rowCount","columnCount","distances","Array","north","west","i","j","spliceOperationsFromEditDistances","length","edits","push","northWest","min","reverse","sharedPrefix","searchLength","sharedSuffix","index1","index2","count","intersect","start1","end1","start2","end2","calcSplices","prefixCount","suffixCount","minLength","Math","splice","ops","splices","oldIndex","$push","prototype","mergeSplice","inserted","insertionOffset","intersectCount","deleteCount","currentRemoved","prepend","slice","apply","append","offset","createInitialSplices","changeRecords","ii","record","projectArraySplices","array","initialSplices","concat"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-element/dist/esm/observation/array-change-records.js"],"sourcesContent":["import { emptyArray } from \"../platform.js\";\n/** @internal */\nexport function newSplice(index, removed, addedCount) {\n    return {\n        index: index,\n        removed: removed,\n        addedCount: addedCount,\n    };\n}\nconst EDIT_LEAVE = 0;\nconst EDIT_UPDATE = 1;\nconst EDIT_ADD = 2;\nconst EDIT_DELETE = 3;\n// Note: This function is *based* on the computation of the Levenshtein\n// \"edit\" distance. The one change is that \"updates\" are treated as two\n// edits - not one. With Array splices, an update is really a delete\n// followed by an add. By retaining this, we optimize for \"keeping\" the\n// maximum array items in the original array. For example:\n//\n//   'xxxx123' -> '123yyyy'\n//\n// With 1-edit updates, the shortest path would be just to update all seven\n// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n// leaves the substring '123' intact.\nfunction calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n    // \"Deletion\" columns\n    const rowCount = oldEnd - oldStart + 1;\n    const columnCount = currentEnd - currentStart + 1;\n    const distances = new Array(rowCount);\n    let north;\n    let west;\n    // \"Addition\" rows. Initialize null column.\n    for (let i = 0; i < rowCount; ++i) {\n        distances[i] = new Array(columnCount);\n        distances[i][0] = i;\n    }\n    // Initialize null row\n    for (let j = 0; j < columnCount; ++j) {\n        distances[0][j] = j;\n    }\n    for (let i = 1; i < rowCount; ++i) {\n        for (let j = 1; j < columnCount; ++j) {\n            if (current[currentStart + j - 1] === old[oldStart + i - 1]) {\n                distances[i][j] = distances[i - 1][j - 1];\n            }\n            else {\n                north = distances[i - 1][j] + 1;\n                west = distances[i][j - 1] + 1;\n                distances[i][j] = north < west ? north : west;\n            }\n        }\n    }\n    return distances;\n}\n// This starts at the final weight, and walks \"backward\" by finding\n// the minimum previous weight recursively until the origin of the weight\n// matrix.\nfunction spliceOperationsFromEditDistances(distances) {\n    let i = distances.length - 1;\n    let j = distances[0].length - 1;\n    let current = distances[i][j];\n    const edits = [];\n    while (i > 0 || j > 0) {\n        if (i === 0) {\n            edits.push(EDIT_ADD);\n            j--;\n            continue;\n        }\n        if (j === 0) {\n            edits.push(EDIT_DELETE);\n            i--;\n            continue;\n        }\n        const northWest = distances[i - 1][j - 1];\n        const west = distances[i - 1][j];\n        const north = distances[i][j - 1];\n        let min;\n        if (west < north) {\n            min = west < northWest ? west : northWest;\n        }\n        else {\n            min = north < northWest ? north : northWest;\n        }\n        if (min === northWest) {\n            if (northWest === current) {\n                edits.push(EDIT_LEAVE);\n            }\n            else {\n                edits.push(EDIT_UPDATE);\n                current = northWest;\n            }\n            i--;\n            j--;\n        }\n        else if (min === west) {\n            edits.push(EDIT_DELETE);\n            i--;\n            current = west;\n        }\n        else {\n            edits.push(EDIT_ADD);\n            j--;\n            current = north;\n        }\n    }\n    edits.reverse();\n    return edits;\n}\nfunction sharedPrefix(current, old, searchLength) {\n    for (let i = 0; i < searchLength; ++i) {\n        if (current[i] !== old[i]) {\n            return i;\n        }\n    }\n    return searchLength;\n}\nfunction sharedSuffix(current, old, searchLength) {\n    let index1 = current.length;\n    let index2 = old.length;\n    let count = 0;\n    while (count < searchLength && current[--index1] === old[--index2]) {\n        count++;\n    }\n    return count;\n}\nfunction intersect(start1, end1, start2, end2) {\n    // Disjoint\n    if (end1 < start2 || end2 < start1) {\n        return -1;\n    }\n    // Adjacent\n    if (end1 === start2 || end2 === start1) {\n        return 0;\n    }\n    // Non-zero intersect, span1 first\n    if (start1 < start2) {\n        if (end1 < end2) {\n            return end1 - start2; // Overlap\n        }\n        return end2 - start2; // Contained\n    }\n    // Non-zero intersect, span2 first\n    if (end2 < end1) {\n        return end2 - start1; // Overlap\n    }\n    return end1 - start1; // Contained\n}\n/**\n * Splice Projection functions:\n *\n * A splice map is a representation of how a previous array of items\n * was transformed into a new array of items. Conceptually it is a list of\n * tuples of\n *\n *   <index, removed, addedCount>\n *\n * which are kept in ascending index order of. The tuple represents that at\n * the |index|, |removed| sequence of items were removed, and counting forward\n * from |index|, |addedCount| items were added.\n */\n/**\n * @internal\n * @remarks\n * Lacking individual splice mutation information, the minimal set of\n * splices can be synthesized given the previous state and final state of an\n * array. The basic approach is to calculate the edit distance matrix and\n * choose the shortest path through it.\n *\n * Complexity: O(l * p)\n *   l: The length of the current array\n *   p: The length of the old array\n */\nexport function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n    let prefixCount = 0;\n    let suffixCount = 0;\n    const minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n    if (currentStart === 0 && oldStart === 0) {\n        prefixCount = sharedPrefix(current, old, minLength);\n    }\n    if (currentEnd === current.length && oldEnd === old.length) {\n        suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n    }\n    currentStart += prefixCount;\n    oldStart += prefixCount;\n    currentEnd -= suffixCount;\n    oldEnd -= suffixCount;\n    if (currentEnd - currentStart === 0 && oldEnd - oldStart === 0) {\n        return emptyArray;\n    }\n    if (currentStart === currentEnd) {\n        const splice = newSplice(currentStart, [], 0);\n        while (oldStart < oldEnd) {\n            splice.removed.push(old[oldStart++]);\n        }\n        return [splice];\n    }\n    else if (oldStart === oldEnd) {\n        return [newSplice(currentStart, [], currentEnd - currentStart)];\n    }\n    const ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n    const splices = [];\n    let splice = void 0;\n    let index = currentStart;\n    let oldIndex = oldStart;\n    for (let i = 0; i < ops.length; ++i) {\n        switch (ops[i]) {\n            case EDIT_LEAVE:\n                if (splice !== void 0) {\n                    splices.push(splice);\n                    splice = void 0;\n                }\n                index++;\n                oldIndex++;\n                break;\n            case EDIT_UPDATE:\n                if (splice === void 0) {\n                    splice = newSplice(index, [], 0);\n                }\n                splice.addedCount++;\n                index++;\n                splice.removed.push(old[oldIndex]);\n                oldIndex++;\n                break;\n            case EDIT_ADD:\n                if (splice === void 0) {\n                    splice = newSplice(index, [], 0);\n                }\n                splice.addedCount++;\n                index++;\n                break;\n            case EDIT_DELETE:\n                if (splice === void 0) {\n                    splice = newSplice(index, [], 0);\n                }\n                splice.removed.push(old[oldIndex]);\n                oldIndex++;\n                break;\n            // no default\n        }\n    }\n    if (splice !== void 0) {\n        splices.push(splice);\n    }\n    return splices;\n}\nconst $push = Array.prototype.push;\nfunction mergeSplice(splices, index, removed, addedCount) {\n    const splice = newSplice(index, removed, addedCount);\n    let inserted = false;\n    let insertionOffset = 0;\n    for (let i = 0; i < splices.length; i++) {\n        const current = splices[i];\n        current.index += insertionOffset;\n        if (inserted) {\n            continue;\n        }\n        const intersectCount = intersect(splice.index, splice.index + splice.removed.length, current.index, current.index + current.addedCount);\n        if (intersectCount >= 0) {\n            // Merge the two splices\n            splices.splice(i, 1);\n            i--;\n            insertionOffset -= current.addedCount - current.removed.length;\n            splice.addedCount += current.addedCount - intersectCount;\n            const deleteCount = splice.removed.length + current.removed.length - intersectCount;\n            if (!splice.addedCount && !deleteCount) {\n                // merged splice is a noop. discard.\n                inserted = true;\n            }\n            else {\n                let currentRemoved = current.removed;\n                if (splice.index < current.index) {\n                    // some prefix of splice.removed is prepended to current.removed.\n                    const prepend = splice.removed.slice(0, current.index - splice.index);\n                    $push.apply(prepend, currentRemoved);\n                    currentRemoved = prepend;\n                }\n                if (splice.index + splice.removed.length >\n                    current.index + current.addedCount) {\n                    // some suffix of splice.removed is appended to current.removed.\n                    const append = splice.removed.slice(current.index + current.addedCount - splice.index);\n                    $push.apply(currentRemoved, append);\n                }\n                splice.removed = currentRemoved;\n                if (current.index < splice.index) {\n                    splice.index = current.index;\n                }\n            }\n        }\n        else if (splice.index < current.index) {\n            // Insert splice here.\n            inserted = true;\n            splices.splice(i, 0, splice);\n            i++;\n            const offset = splice.addedCount - splice.removed.length;\n            current.index += offset;\n            insertionOffset += offset;\n        }\n    }\n    if (!inserted) {\n        splices.push(splice);\n    }\n}\nfunction createInitialSplices(changeRecords) {\n    const splices = [];\n    for (let i = 0, ii = changeRecords.length; i < ii; i++) {\n        const record = changeRecords[i];\n        mergeSplice(splices, record.index, record.removed, record.addedCount);\n    }\n    return splices;\n}\n/** @internal */\nexport function projectArraySplices(array, changeRecords) {\n    let splices = [];\n    const initialSplices = createInitialSplices(changeRecords);\n    for (let i = 0, ii = initialSplices.length; i < ii; ++i) {\n        const splice = initialSplices[i];\n        if (splice.addedCount === 1 && splice.removed.length === 1) {\n            if (splice.removed[0] !== array[splice.index]) {\n                splices.push(splice);\n            }\n            continue;\n        }\n        splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));\n    }\n    return splices;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}