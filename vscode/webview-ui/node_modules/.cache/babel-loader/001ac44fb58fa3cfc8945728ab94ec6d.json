{"ast":null,"code":"import { DOM } from \"../dom.js\";\nimport { defaultExecutionContext } from \"../observation/observable.js\";\nimport { compileTemplate } from \"./compiler.js\";\nimport { HTMLView } from \"./view.js\";\nimport { HTMLDirective, TargetedHTMLDirective } from \"./html-directive.js\";\nimport { HTMLBindingDirective } from \"./binding.js\";\n/**\n * A template capable of creating HTMLView instances or rendering directly to DOM.\n * @public\n */\n\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n\nexport class ViewTemplate {\n  /**\n   * Creates an instance of ViewTemplate.\n   * @param html - The html representing what this template will instantiate, including placeholders for directives.\n   * @param directives - The directives that will be connected to placeholders in the html.\n   */\n  constructor(html, directives) {\n    this.behaviorCount = 0;\n    this.hasHostBehaviors = false;\n    this.fragment = null;\n    this.targetOffset = 0;\n    this.viewBehaviorFactories = null;\n    this.hostBehaviorFactories = null;\n    this.html = html;\n    this.directives = directives;\n  }\n  /**\n   * Creates an HTMLView instance based on this template definition.\n   * @param hostBindingTarget - The element that host behaviors will be bound to.\n   */\n\n\n  create(hostBindingTarget) {\n    if (this.fragment === null) {\n      let template;\n      const html = this.html;\n\n      if (typeof html === \"string\") {\n        template = document.createElement(\"template\");\n        template.innerHTML = DOM.createHTML(html);\n        const fec = template.content.firstElementChild;\n\n        if (fec !== null && fec.tagName === \"TEMPLATE\") {\n          template = fec;\n        }\n      } else {\n        template = html;\n      }\n\n      const result = compileTemplate(template, this.directives);\n      this.fragment = result.fragment;\n      this.viewBehaviorFactories = result.viewBehaviorFactories;\n      this.hostBehaviorFactories = result.hostBehaviorFactories;\n      this.targetOffset = result.targetOffset;\n      this.behaviorCount = this.viewBehaviorFactories.length + this.hostBehaviorFactories.length;\n      this.hasHostBehaviors = this.hostBehaviorFactories.length > 0;\n    }\n\n    const fragment = this.fragment.cloneNode(true);\n    const viewFactories = this.viewBehaviorFactories;\n    const behaviors = new Array(this.behaviorCount);\n    const walker = DOM.createTemplateWalker(fragment);\n    let behaviorIndex = 0;\n    let targetIndex = this.targetOffset;\n    let node = walker.nextNode();\n\n    for (let ii = viewFactories.length; behaviorIndex < ii; ++behaviorIndex) {\n      const factory = viewFactories[behaviorIndex];\n      const factoryIndex = factory.targetIndex;\n\n      while (node !== null) {\n        if (targetIndex === factoryIndex) {\n          behaviors[behaviorIndex] = factory.createBehavior(node);\n          break;\n        } else {\n          node = walker.nextNode();\n          targetIndex++;\n        }\n      }\n    }\n\n    if (this.hasHostBehaviors) {\n      const hostFactories = this.hostBehaviorFactories;\n\n      for (let i = 0, ii = hostFactories.length; i < ii; ++i, ++behaviorIndex) {\n        behaviors[behaviorIndex] = hostFactories[i].createBehavior(hostBindingTarget);\n      }\n    }\n\n    return new HTMLView(fragment, behaviors);\n  }\n  /**\n   * Creates an HTMLView from this template, binds it to the source, and then appends it to the host.\n   * @param source - The data source to bind the template to.\n   * @param host - The Element where the template will be rendered.\n   * @param hostBindingTarget - An HTML element to target the host bindings at if different from the\n   * host that the template is being attached to.\n   */\n\n\n  render(source, host, hostBindingTarget) {\n    if (typeof host === \"string\") {\n      host = document.getElementById(host);\n    }\n\n    if (hostBindingTarget === void 0) {\n      hostBindingTarget = host;\n    }\n\n    const view = this.create(hostBindingTarget);\n    view.bind(source, defaultExecutionContext);\n    view.appendTo(host);\n    return view;\n  }\n\n} // Much thanks to LitHTML for working this out!\n\nconst lastAttributeNameRegex =\n/* eslint-disable-next-line no-control-regex */\n/([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n/**\n * Transforms a template literal string into a renderable ViewTemplate.\n * @param strings - The string fragments that are interpolated with the values.\n * @param values - The values that are interpolated with the string fragments.\n * @remarks\n * The html helper supports interpolation of strings, numbers, binding expressions,\n * other template instances, and Directive instances.\n * @public\n */\n\nexport function html(strings) {\n  const directives = [];\n  let html = \"\";\n\n  for (let i = 0, ii = strings.length - 1; i < ii; ++i) {\n    const currentString = strings[i];\n    let value = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    html += currentString;\n\n    if (value instanceof ViewTemplate) {\n      const template = value;\n\n      value = () => template;\n    }\n\n    if (typeof value === \"function\") {\n      value = new HTMLBindingDirective(value);\n    }\n\n    if (value instanceof TargetedHTMLDirective) {\n      const match = lastAttributeNameRegex.exec(currentString);\n\n      if (match !== null) {\n        value.targetName = match[2];\n      }\n    }\n\n    if (value instanceof HTMLDirective) {\n      // Since not all values are directives, we can't use i\n      // as the index for the placeholder. Instead, we need to\n      // use directives.length to get the next index.\n      html += value.createPlaceholder(directives.length);\n      directives.push(value);\n    } else {\n      html += value;\n    }\n  }\n\n  html += strings[strings.length - 1];\n  return new ViewTemplate(html, directives);\n}","map":{"version":3,"names":["DOM","defaultExecutionContext","compileTemplate","HTMLView","HTMLDirective","TargetedHTMLDirective","HTMLBindingDirective","ViewTemplate","constructor","html","directives","behaviorCount","hasHostBehaviors","fragment","targetOffset","viewBehaviorFactories","hostBehaviorFactories","create","hostBindingTarget","template","document","createElement","innerHTML","createHTML","fec","content","firstElementChild","tagName","result","length","cloneNode","viewFactories","behaviors","Array","walker","createTemplateWalker","behaviorIndex","targetIndex","node","nextNode","ii","factory","factoryIndex","createBehavior","hostFactories","i","render","source","host","getElementById","view","bind","appendTo","lastAttributeNameRegex","strings","currentString","value","match","exec","targetName","createPlaceholder","push"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-element/dist/esm/templating/template.js"],"sourcesContent":["import { DOM } from \"../dom.js\";\nimport { defaultExecutionContext } from \"../observation/observable.js\";\nimport { compileTemplate } from \"./compiler.js\";\nimport { HTMLView } from \"./view.js\";\nimport { HTMLDirective, TargetedHTMLDirective, } from \"./html-directive.js\";\nimport { HTMLBindingDirective } from \"./binding.js\";\n/**\n * A template capable of creating HTMLView instances or rendering directly to DOM.\n * @public\n */\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\nexport class ViewTemplate {\n    /**\n     * Creates an instance of ViewTemplate.\n     * @param html - The html representing what this template will instantiate, including placeholders for directives.\n     * @param directives - The directives that will be connected to placeholders in the html.\n     */\n    constructor(html, directives) {\n        this.behaviorCount = 0;\n        this.hasHostBehaviors = false;\n        this.fragment = null;\n        this.targetOffset = 0;\n        this.viewBehaviorFactories = null;\n        this.hostBehaviorFactories = null;\n        this.html = html;\n        this.directives = directives;\n    }\n    /**\n     * Creates an HTMLView instance based on this template definition.\n     * @param hostBindingTarget - The element that host behaviors will be bound to.\n     */\n    create(hostBindingTarget) {\n        if (this.fragment === null) {\n            let template;\n            const html = this.html;\n            if (typeof html === \"string\") {\n                template = document.createElement(\"template\");\n                template.innerHTML = DOM.createHTML(html);\n                const fec = template.content.firstElementChild;\n                if (fec !== null && fec.tagName === \"TEMPLATE\") {\n                    template = fec;\n                }\n            }\n            else {\n                template = html;\n            }\n            const result = compileTemplate(template, this.directives);\n            this.fragment = result.fragment;\n            this.viewBehaviorFactories = result.viewBehaviorFactories;\n            this.hostBehaviorFactories = result.hostBehaviorFactories;\n            this.targetOffset = result.targetOffset;\n            this.behaviorCount =\n                this.viewBehaviorFactories.length + this.hostBehaviorFactories.length;\n            this.hasHostBehaviors = this.hostBehaviorFactories.length > 0;\n        }\n        const fragment = this.fragment.cloneNode(true);\n        const viewFactories = this.viewBehaviorFactories;\n        const behaviors = new Array(this.behaviorCount);\n        const walker = DOM.createTemplateWalker(fragment);\n        let behaviorIndex = 0;\n        let targetIndex = this.targetOffset;\n        let node = walker.nextNode();\n        for (let ii = viewFactories.length; behaviorIndex < ii; ++behaviorIndex) {\n            const factory = viewFactories[behaviorIndex];\n            const factoryIndex = factory.targetIndex;\n            while (node !== null) {\n                if (targetIndex === factoryIndex) {\n                    behaviors[behaviorIndex] = factory.createBehavior(node);\n                    break;\n                }\n                else {\n                    node = walker.nextNode();\n                    targetIndex++;\n                }\n            }\n        }\n        if (this.hasHostBehaviors) {\n            const hostFactories = this.hostBehaviorFactories;\n            for (let i = 0, ii = hostFactories.length; i < ii; ++i, ++behaviorIndex) {\n                behaviors[behaviorIndex] = hostFactories[i].createBehavior(hostBindingTarget);\n            }\n        }\n        return new HTMLView(fragment, behaviors);\n    }\n    /**\n     * Creates an HTMLView from this template, binds it to the source, and then appends it to the host.\n     * @param source - The data source to bind the template to.\n     * @param host - The Element where the template will be rendered.\n     * @param hostBindingTarget - An HTML element to target the host bindings at if different from the\n     * host that the template is being attached to.\n     */\n    render(source, host, hostBindingTarget) {\n        if (typeof host === \"string\") {\n            host = document.getElementById(host);\n        }\n        if (hostBindingTarget === void 0) {\n            hostBindingTarget = host;\n        }\n        const view = this.create(hostBindingTarget);\n        view.bind(source, defaultExecutionContext);\n        view.appendTo(host);\n        return view;\n    }\n}\n// Much thanks to LitHTML for working this out!\nconst lastAttributeNameRegex = \n/* eslint-disable-next-line no-control-regex */\n/([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n/**\n * Transforms a template literal string into a renderable ViewTemplate.\n * @param strings - The string fragments that are interpolated with the values.\n * @param values - The values that are interpolated with the string fragments.\n * @remarks\n * The html helper supports interpolation of strings, numbers, binding expressions,\n * other template instances, and Directive instances.\n * @public\n */\nexport function html(strings, ...values) {\n    const directives = [];\n    let html = \"\";\n    for (let i = 0, ii = strings.length - 1; i < ii; ++i) {\n        const currentString = strings[i];\n        let value = values[i];\n        html += currentString;\n        if (value instanceof ViewTemplate) {\n            const template = value;\n            value = () => template;\n        }\n        if (typeof value === \"function\") {\n            value = new HTMLBindingDirective(value);\n        }\n        if (value instanceof TargetedHTMLDirective) {\n            const match = lastAttributeNameRegex.exec(currentString);\n            if (match !== null) {\n                value.targetName = match[2];\n            }\n        }\n        if (value instanceof HTMLDirective) {\n            // Since not all values are directives, we can't use i\n            // as the index for the placeholder. Instead, we need to\n            // use directives.length to get the next index.\n            html += value.createPlaceholder(directives.length);\n            directives.push(value);\n        }\n        else {\n            html += value;\n        }\n    }\n    html += strings[strings.length - 1];\n    return new ViewTemplate(html, directives);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}