{"ast":null,"code":"import { attr, booleanConverter, DOM, emptyArray, observable } from \"@microsoft/fast-element\";\nimport { keyEnter } from \"@microsoft/fast-web-utilities\";\nconst proxySlotName = \"form-associated-proxy\";\nconst ElementInternalsKey = \"ElementInternals\";\n/**\n * @alpha\n */\n\nexport const supportsElementInternals = ElementInternalsKey in window && \"setFormValue\" in window[ElementInternalsKey].prototype;\nconst InternalsMap = new WeakMap();\n/**\n * Base function for providing Custom Element Form Association.\n *\n * @alpha\n */\n\nexport function FormAssociated(BaseCtor) {\n  const C = class extends BaseCtor {\n    constructor() {\n      super(...arguments);\n      /**\n       * Track whether the value has been changed from the initial value\n       */\n\n      this.dirtyValue = false;\n      /**\n       * Sets the element's disabled state. A disabled element will not be included during form submission.\n       *\n       * @remarks\n       * HTML Attribute: disabled\n       */\n\n      this.disabled = false;\n      /**\n       * These are events that are still fired by the proxy\n       * element based on user / programmatic interaction.\n       *\n       * The proxy implementation should be transparent to\n       * the app author, so block these events from emitting.\n       */\n\n      this.proxyEventsToBlock = [\"change\", \"click\"];\n      this.proxyInitialized = false;\n      this.required = false;\n      this.initialValue = this.initialValue || \"\";\n\n      if (!this.elementInternals) {\n        // When elementInternals is not supported, formResetCallback is\n        // bound to an event listener, so ensure the handler's `this`\n        // context is correct.\n        this.formResetCallback = this.formResetCallback.bind(this);\n      }\n    }\n    /**\n     * Must evaluate to true to enable elementInternals.\n     * Feature detects API support and resolve respectively\n     *\n     * @internal\n     */\n\n\n    static get formAssociated() {\n      return supportsElementInternals;\n    }\n    /**\n     * Returns the validity state of the element\n     *\n     * @alpha\n     */\n\n\n    get validity() {\n      return this.elementInternals ? this.elementInternals.validity : this.proxy.validity;\n    }\n    /**\n     * Retrieve a reference to the associated form.\n     * Returns null if not associated to any form.\n     *\n     * @alpha\n     */\n\n\n    get form() {\n      return this.elementInternals ? this.elementInternals.form : this.proxy.form;\n    }\n    /**\n     * Retrieve the localized validation message,\n     * or custom validation message if set.\n     *\n     * @alpha\n     */\n\n\n    get validationMessage() {\n      return this.elementInternals ? this.elementInternals.validationMessage : this.proxy.validationMessage;\n    }\n    /**\n     * Whether the element will be validated when the\n     * form is submitted\n     */\n\n\n    get willValidate() {\n      return this.elementInternals ? this.elementInternals.willValidate : this.proxy.willValidate;\n    }\n    /**\n     * A reference to all associated label elements\n     */\n\n\n    get labels() {\n      if (this.elementInternals) {\n        return Object.freeze(Array.from(this.elementInternals.labels));\n      } else if (this.proxy instanceof HTMLElement && this.proxy.ownerDocument && this.id) {\n        // Labels associated by wrapping the element: <label><custom-element></custom-element></label>\n        const parentLabels = this.proxy.labels; // Labels associated using the `for` attribute\n\n        const forLabels = Array.from(this.proxy.getRootNode().querySelectorAll(`[for='${this.id}']`));\n        const labels = parentLabels ? forLabels.concat(Array.from(parentLabels)) : forLabels;\n        return Object.freeze(labels);\n      } else {\n        return emptyArray;\n      }\n    }\n    /**\n     * Invoked when the `value` property changes\n     * @param previous - the previous value\n     * @param next - the new value\n     *\n     * @remarks\n     * If elements extending `FormAssociated` implement a `valueChanged` method\n     * They must be sure to invoke `super.valueChanged(previous, next)` to ensure\n     * proper functioning of `FormAssociated`\n     */\n\n\n    valueChanged(previous, next) {\n      this.dirtyValue = true;\n\n      if (this.proxy instanceof HTMLElement) {\n        this.proxy.value = this.value;\n      }\n\n      this.currentValue = this.value;\n      this.setFormValue(this.value);\n      this.validate();\n    }\n\n    currentValueChanged() {\n      this.value = this.currentValue;\n    }\n    /**\n     * Invoked when the `initialValue` property changes\n     *\n     * @param previous - the previous value\n     * @param next - the new value\n     *\n     * @remarks\n     * If elements extending `FormAssociated` implement a `initialValueChanged` method\n     * They must be sure to invoke `super.initialValueChanged(previous, next)` to ensure\n     * proper functioning of `FormAssociated`\n     */\n\n\n    initialValueChanged(previous, next) {\n      // If the value is clean and the component is connected to the DOM\n      // then set value equal to the attribute value.\n      if (!this.dirtyValue) {\n        this.value = this.initialValue;\n        this.dirtyValue = false;\n      }\n    }\n    /**\n     * Invoked when the `disabled` property changes\n     *\n     * @param previous - the previous value\n     * @param next - the new value\n     *\n     * @remarks\n     * If elements extending `FormAssociated` implement a `disabledChanged` method\n     * They must be sure to invoke `super.disabledChanged(previous, next)` to ensure\n     * proper functioning of `FormAssociated`\n     */\n\n\n    disabledChanged(previous, next) {\n      if (this.proxy instanceof HTMLElement) {\n        this.proxy.disabled = this.disabled;\n      }\n\n      DOM.queueUpdate(() => this.classList.toggle(\"disabled\", this.disabled));\n    }\n    /**\n     * Invoked when the `name` property changes\n     *\n     * @param previous - the previous value\n     * @param next - the new value\n     *\n     * @remarks\n     * If elements extending `FormAssociated` implement a `nameChanged` method\n     * They must be sure to invoke `super.nameChanged(previous, next)` to ensure\n     * proper functioning of `FormAssociated`\n     */\n\n\n    nameChanged(previous, next) {\n      if (this.proxy instanceof HTMLElement) {\n        this.proxy.name = this.name;\n      }\n    }\n    /**\n     * Invoked when the `required` property changes\n     *\n     * @param previous - the previous value\n     * @param next - the new value\n     *\n     * @remarks\n     * If elements extending `FormAssociated` implement a `requiredChanged` method\n     * They must be sure to invoke `super.requiredChanged(previous, next)` to ensure\n     * proper functioning of `FormAssociated`\n     */\n\n\n    requiredChanged(prev, next) {\n      if (this.proxy instanceof HTMLElement) {\n        this.proxy.required = this.required;\n      }\n\n      DOM.queueUpdate(() => this.classList.toggle(\"required\", this.required));\n      this.validate();\n    }\n    /**\n     * The element internals object. Will only exist\n     * in browsers supporting the attachInternals API\n     */\n\n\n    get elementInternals() {\n      if (!supportsElementInternals) {\n        return null;\n      }\n\n      let internals = InternalsMap.get(this);\n\n      if (!internals) {\n        internals = this.attachInternals();\n        InternalsMap.set(this, internals);\n      }\n\n      return internals;\n    }\n    /**\n     * @internal\n     */\n\n\n    connectedCallback() {\n      super.connectedCallback();\n      this.addEventListener(\"keypress\", this._keypressHandler);\n\n      if (!this.value) {\n        this.value = this.initialValue;\n        this.dirtyValue = false;\n      }\n\n      if (!this.elementInternals) {\n        this.attachProxy();\n\n        if (this.form) {\n          this.form.addEventListener(\"reset\", this.formResetCallback);\n        }\n      }\n    }\n    /**\n     * @internal\n     */\n\n\n    disconnectedCallback() {\n      this.proxyEventsToBlock.forEach(name => this.proxy.removeEventListener(name, this.stopPropagation));\n\n      if (!this.elementInternals && this.form) {\n        this.form.removeEventListener(\"reset\", this.formResetCallback);\n      }\n    }\n    /**\n     * Return the current validity of the element.\n     */\n\n\n    checkValidity() {\n      return this.elementInternals ? this.elementInternals.checkValidity() : this.proxy.checkValidity();\n    }\n    /**\n     * Return the current validity of the element.\n     * If false, fires an invalid event at the element.\n     */\n\n\n    reportValidity() {\n      return this.elementInternals ? this.elementInternals.reportValidity() : this.proxy.reportValidity();\n    }\n    /**\n     * Set the validity of the control. In cases when the elementInternals object is not\n     * available (and the proxy element is used to report validity), this function will\n     * do nothing unless a message is provided, at which point the setCustomValidity method\n     * of the proxy element will be invoked with the provided message.\n     * @param flags - Validity flags\n     * @param message - Optional message to supply\n     * @param anchor - Optional element used by UA to display an interactive validation UI\n     */\n\n\n    setValidity(flags, message, anchor) {\n      if (this.elementInternals) {\n        this.elementInternals.setValidity(flags, message, anchor);\n      } else if (typeof message === \"string\") {\n        this.proxy.setCustomValidity(message);\n      }\n    }\n    /**\n     * Invoked when a connected component's form or fieldset has its disabled\n     * state changed.\n     * @param disabled - the disabled value of the form / fieldset\n     */\n\n\n    formDisabledCallback(disabled) {\n      this.disabled = disabled;\n    }\n\n    formResetCallback() {\n      this.value = this.initialValue;\n      this.dirtyValue = false;\n    }\n    /**\n     * Attach the proxy element to the DOM\n     */\n\n\n    attachProxy() {\n      var _a;\n\n      if (!this.proxyInitialized) {\n        this.proxyInitialized = true;\n        this.proxy.style.display = \"none\";\n        this.proxyEventsToBlock.forEach(name => this.proxy.addEventListener(name, this.stopPropagation)); // These are typically mapped to the proxy during\n        // property change callbacks, but during initialization\n        // on the initial call of the callback, the proxy is\n        // still undefined. We should find a better way to address this.\n\n        this.proxy.disabled = this.disabled;\n        this.proxy.required = this.required;\n\n        if (typeof this.name === \"string\") {\n          this.proxy.name = this.name;\n        }\n\n        if (typeof this.value === \"string\") {\n          this.proxy.value = this.value;\n        }\n\n        this.proxy.setAttribute(\"slot\", proxySlotName);\n        this.proxySlot = document.createElement(\"slot\");\n        this.proxySlot.setAttribute(\"name\", proxySlotName);\n      }\n\n      (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.appendChild(this.proxySlot);\n      this.appendChild(this.proxy);\n    }\n    /**\n     * Detach the proxy element from the DOM\n     */\n\n\n    detachProxy() {\n      var _a;\n\n      this.removeChild(this.proxy);\n      (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.removeChild(this.proxySlot);\n    }\n    /** {@inheritDoc (FormAssociated:interface).validate} */\n\n\n    validate(anchor) {\n      if (this.proxy instanceof HTMLElement) {\n        this.setValidity(this.proxy.validity, this.proxy.validationMessage, anchor);\n      }\n    }\n    /**\n     * Associates the provided value (and optional state) with the parent form.\n     * @param value - The value to set\n     * @param state - The state object provided to during session restores and when autofilling.\n     */\n\n\n    setFormValue(value, state) {\n      if (this.elementInternals) {\n        this.elementInternals.setFormValue(value, state || value);\n      }\n    }\n\n    _keypressHandler(e) {\n      switch (e.key) {\n        case keyEnter:\n          if (this.form instanceof HTMLFormElement) {\n            // Implicit submission\n            const defaultButton = this.form.querySelector(\"[type=submit]\");\n            defaultButton === null || defaultButton === void 0 ? void 0 : defaultButton.click();\n          }\n\n          break;\n      }\n    }\n    /**\n     * Used to stop propagation of proxy element events\n     * @param e - Event object\n     */\n\n\n    stopPropagation(e) {\n      e.stopPropagation();\n    }\n\n  };\n  attr({\n    mode: \"boolean\"\n  })(C.prototype, \"disabled\");\n  attr({\n    mode: \"fromView\",\n    attribute: \"value\"\n  })(C.prototype, \"initialValue\");\n  attr({\n    attribute: \"current-value\"\n  })(C.prototype, \"currentValue\");\n  attr(C.prototype, \"name\");\n  attr({\n    mode: \"boolean\"\n  })(C.prototype, \"required\");\n  observable(C.prototype, \"value\");\n  return C;\n}\n/**\n * @alpha\n */\n\nexport function CheckableFormAssociated(BaseCtor) {\n  class C extends FormAssociated(BaseCtor) {}\n\n  class D extends C {\n    constructor() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      super(args);\n      /**\n       * Tracks whether the \"checked\" property has been changed.\n       * This is necessary to provide consistent behavior with\n       * normal input checkboxes\n       */\n\n      this.dirtyChecked = false;\n      /**\n       * Provides the default checkedness of the input element\n       * Passed down to proxy\n       *\n       * @public\n       * @remarks\n       * HTML Attribute: checked\n       */\n\n      this.checkedAttribute = false;\n      /**\n       * The checked state of the control.\n       *\n       * @public\n       */\n\n      this.checked = false; // Re-initialize dirtyChecked because initialization of other values\n      // causes it to become true\n\n      this.dirtyChecked = false;\n    }\n\n    checkedAttributeChanged() {\n      this.defaultChecked = this.checkedAttribute;\n    }\n    /**\n     * @internal\n     */\n\n\n    defaultCheckedChanged() {\n      if (!this.dirtyChecked) {\n        // Setting this.checked will cause us to enter a dirty state,\n        // but if we are clean when defaultChecked is changed, we want to stay\n        // in a clean state, so reset this.dirtyChecked\n        this.checked = this.defaultChecked;\n        this.dirtyChecked = false;\n      }\n    }\n\n    checkedChanged(prev, next) {\n      if (!this.dirtyChecked) {\n        this.dirtyChecked = true;\n      }\n\n      this.currentChecked = this.checked;\n      this.updateForm();\n\n      if (this.proxy instanceof HTMLInputElement) {\n        this.proxy.checked = this.checked;\n      }\n\n      if (prev !== undefined) {\n        this.$emit(\"change\");\n      }\n\n      this.validate();\n    }\n\n    currentCheckedChanged(prev, next) {\n      this.checked = this.currentChecked;\n    }\n\n    updateForm() {\n      const value = this.checked ? this.value : null;\n      this.setFormValue(value, value);\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      this.updateForm();\n    }\n\n    formResetCallback() {\n      super.formResetCallback();\n      this.checked = !!this.checkedAttribute;\n      this.dirtyChecked = false;\n    }\n\n  }\n\n  attr({\n    attribute: \"checked\",\n    mode: \"boolean\"\n  })(D.prototype, \"checkedAttribute\");\n  attr({\n    attribute: \"current-checked\",\n    converter: booleanConverter\n  })(D.prototype, \"currentChecked\");\n  observable(D.prototype, \"defaultChecked\");\n  observable(D.prototype, \"checked\");\n  return D;\n}","map":{"version":3,"names":["attr","booleanConverter","DOM","emptyArray","observable","keyEnter","proxySlotName","ElementInternalsKey","supportsElementInternals","window","prototype","InternalsMap","WeakMap","FormAssociated","BaseCtor","C","constructor","dirtyValue","disabled","proxyEventsToBlock","proxyInitialized","required","initialValue","elementInternals","formResetCallback","bind","formAssociated","validity","proxy","form","validationMessage","willValidate","labels","Object","freeze","Array","from","HTMLElement","ownerDocument","id","parentLabels","forLabels","getRootNode","querySelectorAll","concat","valueChanged","previous","next","value","currentValue","setFormValue","validate","currentValueChanged","initialValueChanged","disabledChanged","queueUpdate","classList","toggle","nameChanged","name","requiredChanged","prev","internals","get","attachInternals","set","connectedCallback","addEventListener","_keypressHandler","attachProxy","disconnectedCallback","forEach","removeEventListener","stopPropagation","checkValidity","reportValidity","setValidity","flags","message","anchor","setCustomValidity","formDisabledCallback","_a","style","display","setAttribute","proxySlot","document","createElement","shadowRoot","appendChild","detachProxy","removeChild","state","e","key","HTMLFormElement","defaultButton","querySelector","click","mode","attribute","CheckableFormAssociated","D","args","dirtyChecked","checkedAttribute","checked","checkedAttributeChanged","defaultChecked","defaultCheckedChanged","checkedChanged","currentChecked","updateForm","HTMLInputElement","undefined","$emit","currentCheckedChanged","converter"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/form-associated/form-associated.js"],"sourcesContent":["import { attr, booleanConverter, DOM, emptyArray, observable, } from \"@microsoft/fast-element\";\nimport { keyEnter } from \"@microsoft/fast-web-utilities\";\nconst proxySlotName = \"form-associated-proxy\";\nconst ElementInternalsKey = \"ElementInternals\";\n/**\n * @alpha\n */\nexport const supportsElementInternals = ElementInternalsKey in window &&\n    \"setFormValue\" in window[ElementInternalsKey].prototype;\nconst InternalsMap = new WeakMap();\n/**\n * Base function for providing Custom Element Form Association.\n *\n * @alpha\n */\nexport function FormAssociated(BaseCtor) {\n    const C = class extends BaseCtor {\n        constructor(...args) {\n            super(...args);\n            /**\n             * Track whether the value has been changed from the initial value\n             */\n            this.dirtyValue = false;\n            /**\n             * Sets the element's disabled state. A disabled element will not be included during form submission.\n             *\n             * @remarks\n             * HTML Attribute: disabled\n             */\n            this.disabled = false;\n            /**\n             * These are events that are still fired by the proxy\n             * element based on user / programmatic interaction.\n             *\n             * The proxy implementation should be transparent to\n             * the app author, so block these events from emitting.\n             */\n            this.proxyEventsToBlock = [\"change\", \"click\"];\n            this.proxyInitialized = false;\n            this.required = false;\n            this.initialValue = this.initialValue || \"\";\n            if (!this.elementInternals) {\n                // When elementInternals is not supported, formResetCallback is\n                // bound to an event listener, so ensure the handler's `this`\n                // context is correct.\n                this.formResetCallback = this.formResetCallback.bind(this);\n            }\n        }\n        /**\n         * Must evaluate to true to enable elementInternals.\n         * Feature detects API support and resolve respectively\n         *\n         * @internal\n         */\n        static get formAssociated() {\n            return supportsElementInternals;\n        }\n        /**\n         * Returns the validity state of the element\n         *\n         * @alpha\n         */\n        get validity() {\n            return this.elementInternals\n                ? this.elementInternals.validity\n                : this.proxy.validity;\n        }\n        /**\n         * Retrieve a reference to the associated form.\n         * Returns null if not associated to any form.\n         *\n         * @alpha\n         */\n        get form() {\n            return this.elementInternals ? this.elementInternals.form : this.proxy.form;\n        }\n        /**\n         * Retrieve the localized validation message,\n         * or custom validation message if set.\n         *\n         * @alpha\n         */\n        get validationMessage() {\n            return this.elementInternals\n                ? this.elementInternals.validationMessage\n                : this.proxy.validationMessage;\n        }\n        /**\n         * Whether the element will be validated when the\n         * form is submitted\n         */\n        get willValidate() {\n            return this.elementInternals\n                ? this.elementInternals.willValidate\n                : this.proxy.willValidate;\n        }\n        /**\n         * A reference to all associated label elements\n         */\n        get labels() {\n            if (this.elementInternals) {\n                return Object.freeze(Array.from(this.elementInternals.labels));\n            }\n            else if (this.proxy instanceof HTMLElement &&\n                this.proxy.ownerDocument &&\n                this.id) {\n                // Labels associated by wrapping the element: <label><custom-element></custom-element></label>\n                const parentLabels = this.proxy.labels;\n                // Labels associated using the `for` attribute\n                const forLabels = Array.from(this.proxy.getRootNode().querySelectorAll(`[for='${this.id}']`));\n                const labels = parentLabels\n                    ? forLabels.concat(Array.from(parentLabels))\n                    : forLabels;\n                return Object.freeze(labels);\n            }\n            else {\n                return emptyArray;\n            }\n        }\n        /**\n         * Invoked when the `value` property changes\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `valueChanged` method\n         * They must be sure to invoke `super.valueChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        valueChanged(previous, next) {\n            this.dirtyValue = true;\n            if (this.proxy instanceof HTMLElement) {\n                this.proxy.value = this.value;\n            }\n            this.currentValue = this.value;\n            this.setFormValue(this.value);\n            this.validate();\n        }\n        currentValueChanged() {\n            this.value = this.currentValue;\n        }\n        /**\n         * Invoked when the `initialValue` property changes\n         *\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `initialValueChanged` method\n         * They must be sure to invoke `super.initialValueChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        initialValueChanged(previous, next) {\n            // If the value is clean and the component is connected to the DOM\n            // then set value equal to the attribute value.\n            if (!this.dirtyValue) {\n                this.value = this.initialValue;\n                this.dirtyValue = false;\n            }\n        }\n        /**\n         * Invoked when the `disabled` property changes\n         *\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `disabledChanged` method\n         * They must be sure to invoke `super.disabledChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        disabledChanged(previous, next) {\n            if (this.proxy instanceof HTMLElement) {\n                this.proxy.disabled = this.disabled;\n            }\n            DOM.queueUpdate(() => this.classList.toggle(\"disabled\", this.disabled));\n        }\n        /**\n         * Invoked when the `name` property changes\n         *\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `nameChanged` method\n         * They must be sure to invoke `super.nameChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        nameChanged(previous, next) {\n            if (this.proxy instanceof HTMLElement) {\n                this.proxy.name = this.name;\n            }\n        }\n        /**\n         * Invoked when the `required` property changes\n         *\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `requiredChanged` method\n         * They must be sure to invoke `super.requiredChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        requiredChanged(prev, next) {\n            if (this.proxy instanceof HTMLElement) {\n                this.proxy.required = this.required;\n            }\n            DOM.queueUpdate(() => this.classList.toggle(\"required\", this.required));\n            this.validate();\n        }\n        /**\n         * The element internals object. Will only exist\n         * in browsers supporting the attachInternals API\n         */\n        get elementInternals() {\n            if (!supportsElementInternals) {\n                return null;\n            }\n            let internals = InternalsMap.get(this);\n            if (!internals) {\n                internals = this.attachInternals();\n                InternalsMap.set(this, internals);\n            }\n            return internals;\n        }\n        /**\n         * @internal\n         */\n        connectedCallback() {\n            super.connectedCallback();\n            this.addEventListener(\"keypress\", this._keypressHandler);\n            if (!this.value) {\n                this.value = this.initialValue;\n                this.dirtyValue = false;\n            }\n            if (!this.elementInternals) {\n                this.attachProxy();\n                if (this.form) {\n                    this.form.addEventListener(\"reset\", this.formResetCallback);\n                }\n            }\n        }\n        /**\n         * @internal\n         */\n        disconnectedCallback() {\n            this.proxyEventsToBlock.forEach(name => this.proxy.removeEventListener(name, this.stopPropagation));\n            if (!this.elementInternals && this.form) {\n                this.form.removeEventListener(\"reset\", this.formResetCallback);\n            }\n        }\n        /**\n         * Return the current validity of the element.\n         */\n        checkValidity() {\n            return this.elementInternals\n                ? this.elementInternals.checkValidity()\n                : this.proxy.checkValidity();\n        }\n        /**\n         * Return the current validity of the element.\n         * If false, fires an invalid event at the element.\n         */\n        reportValidity() {\n            return this.elementInternals\n                ? this.elementInternals.reportValidity()\n                : this.proxy.reportValidity();\n        }\n        /**\n         * Set the validity of the control. In cases when the elementInternals object is not\n         * available (and the proxy element is used to report validity), this function will\n         * do nothing unless a message is provided, at which point the setCustomValidity method\n         * of the proxy element will be invoked with the provided message.\n         * @param flags - Validity flags\n         * @param message - Optional message to supply\n         * @param anchor - Optional element used by UA to display an interactive validation UI\n         */\n        setValidity(flags, message, anchor) {\n            if (this.elementInternals) {\n                this.elementInternals.setValidity(flags, message, anchor);\n            }\n            else if (typeof message === \"string\") {\n                this.proxy.setCustomValidity(message);\n            }\n        }\n        /**\n         * Invoked when a connected component's form or fieldset has its disabled\n         * state changed.\n         * @param disabled - the disabled value of the form / fieldset\n         */\n        formDisabledCallback(disabled) {\n            this.disabled = disabled;\n        }\n        formResetCallback() {\n            this.value = this.initialValue;\n            this.dirtyValue = false;\n        }\n        /**\n         * Attach the proxy element to the DOM\n         */\n        attachProxy() {\n            var _a;\n            if (!this.proxyInitialized) {\n                this.proxyInitialized = true;\n                this.proxy.style.display = \"none\";\n                this.proxyEventsToBlock.forEach(name => this.proxy.addEventListener(name, this.stopPropagation));\n                // These are typically mapped to the proxy during\n                // property change callbacks, but during initialization\n                // on the initial call of the callback, the proxy is\n                // still undefined. We should find a better way to address this.\n                this.proxy.disabled = this.disabled;\n                this.proxy.required = this.required;\n                if (typeof this.name === \"string\") {\n                    this.proxy.name = this.name;\n                }\n                if (typeof this.value === \"string\") {\n                    this.proxy.value = this.value;\n                }\n                this.proxy.setAttribute(\"slot\", proxySlotName);\n                this.proxySlot = document.createElement(\"slot\");\n                this.proxySlot.setAttribute(\"name\", proxySlotName);\n            }\n            (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.appendChild(this.proxySlot);\n            this.appendChild(this.proxy);\n        }\n        /**\n         * Detach the proxy element from the DOM\n         */\n        detachProxy() {\n            var _a;\n            this.removeChild(this.proxy);\n            (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.removeChild(this.proxySlot);\n        }\n        /** {@inheritDoc (FormAssociated:interface).validate} */\n        validate(anchor) {\n            if (this.proxy instanceof HTMLElement) {\n                this.setValidity(this.proxy.validity, this.proxy.validationMessage, anchor);\n            }\n        }\n        /**\n         * Associates the provided value (and optional state) with the parent form.\n         * @param value - The value to set\n         * @param state - The state object provided to during session restores and when autofilling.\n         */\n        setFormValue(value, state) {\n            if (this.elementInternals) {\n                this.elementInternals.setFormValue(value, state || value);\n            }\n        }\n        _keypressHandler(e) {\n            switch (e.key) {\n                case keyEnter:\n                    if (this.form instanceof HTMLFormElement) {\n                        // Implicit submission\n                        const defaultButton = this.form.querySelector(\"[type=submit]\");\n                        defaultButton === null || defaultButton === void 0 ? void 0 : defaultButton.click();\n                    }\n                    break;\n            }\n        }\n        /**\n         * Used to stop propagation of proxy element events\n         * @param e - Event object\n         */\n        stopPropagation(e) {\n            e.stopPropagation();\n        }\n    };\n    attr({ mode: \"boolean\" })(C.prototype, \"disabled\");\n    attr({ mode: \"fromView\", attribute: \"value\" })(C.prototype, \"initialValue\");\n    attr({ attribute: \"current-value\" })(C.prototype, \"currentValue\");\n    attr(C.prototype, \"name\");\n    attr({ mode: \"boolean\" })(C.prototype, \"required\");\n    observable(C.prototype, \"value\");\n    return C;\n}\n/**\n * @alpha\n */\nexport function CheckableFormAssociated(BaseCtor) {\n    class C extends FormAssociated(BaseCtor) {\n    }\n    class D extends C {\n        constructor(...args) {\n            super(args);\n            /**\n             * Tracks whether the \"checked\" property has been changed.\n             * This is necessary to provide consistent behavior with\n             * normal input checkboxes\n             */\n            this.dirtyChecked = false;\n            /**\n             * Provides the default checkedness of the input element\n             * Passed down to proxy\n             *\n             * @public\n             * @remarks\n             * HTML Attribute: checked\n             */\n            this.checkedAttribute = false;\n            /**\n             * The checked state of the control.\n             *\n             * @public\n             */\n            this.checked = false;\n            // Re-initialize dirtyChecked because initialization of other values\n            // causes it to become true\n            this.dirtyChecked = false;\n        }\n        checkedAttributeChanged() {\n            this.defaultChecked = this.checkedAttribute;\n        }\n        /**\n         * @internal\n         */\n        defaultCheckedChanged() {\n            if (!this.dirtyChecked) {\n                // Setting this.checked will cause us to enter a dirty state,\n                // but if we are clean when defaultChecked is changed, we want to stay\n                // in a clean state, so reset this.dirtyChecked\n                this.checked = this.defaultChecked;\n                this.dirtyChecked = false;\n            }\n        }\n        checkedChanged(prev, next) {\n            if (!this.dirtyChecked) {\n                this.dirtyChecked = true;\n            }\n            this.currentChecked = this.checked;\n            this.updateForm();\n            if (this.proxy instanceof HTMLInputElement) {\n                this.proxy.checked = this.checked;\n            }\n            if (prev !== undefined) {\n                this.$emit(\"change\");\n            }\n            this.validate();\n        }\n        currentCheckedChanged(prev, next) {\n            this.checked = this.currentChecked;\n        }\n        updateForm() {\n            const value = this.checked ? this.value : null;\n            this.setFormValue(value, value);\n        }\n        connectedCallback() {\n            super.connectedCallback();\n            this.updateForm();\n        }\n        formResetCallback() {\n            super.formResetCallback();\n            this.checked = !!this.checkedAttribute;\n            this.dirtyChecked = false;\n        }\n    }\n    attr({ attribute: \"checked\", mode: \"boolean\" })(D.prototype, \"checkedAttribute\");\n    attr({ attribute: \"current-checked\", converter: booleanConverter })(D.prototype, \"currentChecked\");\n    observable(D.prototype, \"defaultChecked\");\n    observable(D.prototype, \"checked\");\n    return D;\n}\n"],"mappings":"AAAA,SAASA,IAAT,EAAeC,gBAAf,EAAiCC,GAAjC,EAAsCC,UAAtC,EAAkDC,UAAlD,QAAqE,yBAArE;AACA,SAASC,QAAT,QAAyB,+BAAzB;AACA,MAAMC,aAAa,GAAG,uBAAtB;AACA,MAAMC,mBAAmB,GAAG,kBAA5B;AACA;AACA;AACA;;AACA,OAAO,MAAMC,wBAAwB,GAAGD,mBAAmB,IAAIE,MAAvB,IACpC,kBAAkBA,MAAM,CAACF,mBAAD,CAAN,CAA4BG,SAD3C;AAEP,MAAMC,YAAY,GAAG,IAAIC,OAAJ,EAArB;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,cAAT,CAAwBC,QAAxB,EAAkC;EACrC,MAAMC,CAAC,GAAG,cAAcD,QAAd,CAAuB;IAC7BE,WAAW,GAAU;MACjB,MAAM,YAAN;MACA;AACZ;AACA;;MACY,KAAKC,UAAL,GAAkB,KAAlB;MACA;AACZ;AACA;AACA;AACA;AACA;;MACY,KAAKC,QAAL,GAAgB,KAAhB;MACA;AACZ;AACA;AACA;AACA;AACA;AACA;;MACY,KAAKC,kBAAL,GAA0B,CAAC,QAAD,EAAW,OAAX,CAA1B;MACA,KAAKC,gBAAL,GAAwB,KAAxB;MACA,KAAKC,QAAL,GAAgB,KAAhB;MACA,KAAKC,YAAL,GAAoB,KAAKA,YAAL,IAAqB,EAAzC;;MACA,IAAI,CAAC,KAAKC,gBAAV,EAA4B;QACxB;QACA;QACA;QACA,KAAKC,iBAAL,GAAyB,KAAKA,iBAAL,CAAuBC,IAAvB,CAA4B,IAA5B,CAAzB;MACH;IACJ;IACD;AACR;AACA;AACA;AACA;AACA;;;IACiC,WAAdC,cAAc,GAAG;MACxB,OAAOlB,wBAAP;IACH;IACD;AACR;AACA;AACA;AACA;;;IACoB,IAARmB,QAAQ,GAAG;MACX,OAAO,KAAKJ,gBAAL,GACD,KAAKA,gBAAL,CAAsBI,QADrB,GAED,KAAKC,KAAL,CAAWD,QAFjB;IAGH;IACD;AACR;AACA;AACA;AACA;AACA;;;IACgB,IAAJE,IAAI,GAAG;MACP,OAAO,KAAKN,gBAAL,GAAwB,KAAKA,gBAAL,CAAsBM,IAA9C,GAAqD,KAAKD,KAAL,CAAWC,IAAvE;IACH;IACD;AACR;AACA;AACA;AACA;AACA;;;IAC6B,IAAjBC,iBAAiB,GAAG;MACpB,OAAO,KAAKP,gBAAL,GACD,KAAKA,gBAAL,CAAsBO,iBADrB,GAED,KAAKF,KAAL,CAAWE,iBAFjB;IAGH;IACD;AACR;AACA;AACA;;;IACwB,IAAZC,YAAY,GAAG;MACf,OAAO,KAAKR,gBAAL,GACD,KAAKA,gBAAL,CAAsBQ,YADrB,GAED,KAAKH,KAAL,CAAWG,YAFjB;IAGH;IACD;AACR;AACA;;;IACkB,IAANC,MAAM,GAAG;MACT,IAAI,KAAKT,gBAAT,EAA2B;QACvB,OAAOU,MAAM,CAACC,MAAP,CAAcC,KAAK,CAACC,IAAN,CAAW,KAAKb,gBAAL,CAAsBS,MAAjC,CAAd,CAAP;MACH,CAFD,MAGK,IAAI,KAAKJ,KAAL,YAAsBS,WAAtB,IACL,KAAKT,KAAL,CAAWU,aADN,IAEL,KAAKC,EAFJ,EAEQ;QACT;QACA,MAAMC,YAAY,GAAG,KAAKZ,KAAL,CAAWI,MAAhC,CAFS,CAGT;;QACA,MAAMS,SAAS,GAAGN,KAAK,CAACC,IAAN,CAAW,KAAKR,KAAL,CAAWc,WAAX,GAAyBC,gBAAzB,CAA2C,SAAQ,KAAKJ,EAAG,IAA3D,CAAX,CAAlB;QACA,MAAMP,MAAM,GAAGQ,YAAY,GACrBC,SAAS,CAACG,MAAV,CAAiBT,KAAK,CAACC,IAAN,CAAWI,YAAX,CAAjB,CADqB,GAErBC,SAFN;QAGA,OAAOR,MAAM,CAACC,MAAP,CAAcF,MAAd,CAAP;MACH,CAXI,MAYA;QACD,OAAO7B,UAAP;MACH;IACJ;IACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQ0C,YAAY,CAACC,QAAD,EAAWC,IAAX,EAAiB;MACzB,KAAK9B,UAAL,GAAkB,IAAlB;;MACA,IAAI,KAAKW,KAAL,YAAsBS,WAA1B,EAAuC;QACnC,KAAKT,KAAL,CAAWoB,KAAX,GAAmB,KAAKA,KAAxB;MACH;;MACD,KAAKC,YAAL,GAAoB,KAAKD,KAAzB;MACA,KAAKE,YAAL,CAAkB,KAAKF,KAAvB;MACA,KAAKG,QAAL;IACH;;IACDC,mBAAmB,GAAG;MAClB,KAAKJ,KAAL,GAAa,KAAKC,YAAlB;IACH;IACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQI,mBAAmB,CAACP,QAAD,EAAWC,IAAX,EAAiB;MAChC;MACA;MACA,IAAI,CAAC,KAAK9B,UAAV,EAAsB;QAClB,KAAK+B,KAAL,GAAa,KAAK1B,YAAlB;QACA,KAAKL,UAAL,GAAkB,KAAlB;MACH;IACJ;IACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQqC,eAAe,CAACR,QAAD,EAAWC,IAAX,EAAiB;MAC5B,IAAI,KAAKnB,KAAL,YAAsBS,WAA1B,EAAuC;QACnC,KAAKT,KAAL,CAAWV,QAAX,GAAsB,KAAKA,QAA3B;MACH;;MACDhB,GAAG,CAACqD,WAAJ,CAAgB,MAAM,KAAKC,SAAL,CAAeC,MAAf,CAAsB,UAAtB,EAAkC,KAAKvC,QAAvC,CAAtB;IACH;IACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQwC,WAAW,CAACZ,QAAD,EAAWC,IAAX,EAAiB;MACxB,IAAI,KAAKnB,KAAL,YAAsBS,WAA1B,EAAuC;QACnC,KAAKT,KAAL,CAAW+B,IAAX,GAAkB,KAAKA,IAAvB;MACH;IACJ;IACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQC,eAAe,CAACC,IAAD,EAAOd,IAAP,EAAa;MACxB,IAAI,KAAKnB,KAAL,YAAsBS,WAA1B,EAAuC;QACnC,KAAKT,KAAL,CAAWP,QAAX,GAAsB,KAAKA,QAA3B;MACH;;MACDnB,GAAG,CAACqD,WAAJ,CAAgB,MAAM,KAAKC,SAAL,CAAeC,MAAf,CAAsB,UAAtB,EAAkC,KAAKpC,QAAvC,CAAtB;MACA,KAAK8B,QAAL;IACH;IACD;AACR;AACA;AACA;;;IAC4B,IAAhB5B,gBAAgB,GAAG;MACnB,IAAI,CAACf,wBAAL,EAA+B;QAC3B,OAAO,IAAP;MACH;;MACD,IAAIsD,SAAS,GAAGnD,YAAY,CAACoD,GAAb,CAAiB,IAAjB,CAAhB;;MACA,IAAI,CAACD,SAAL,EAAgB;QACZA,SAAS,GAAG,KAAKE,eAAL,EAAZ;QACArD,YAAY,CAACsD,GAAb,CAAiB,IAAjB,EAAuBH,SAAvB;MACH;;MACD,OAAOA,SAAP;IACH;IACD;AACR;AACA;;;IACQI,iBAAiB,GAAG;MAChB,MAAMA,iBAAN;MACA,KAAKC,gBAAL,CAAsB,UAAtB,EAAkC,KAAKC,gBAAvC;;MACA,IAAI,CAAC,KAAKpB,KAAV,EAAiB;QACb,KAAKA,KAAL,GAAa,KAAK1B,YAAlB;QACA,KAAKL,UAAL,GAAkB,KAAlB;MACH;;MACD,IAAI,CAAC,KAAKM,gBAAV,EAA4B;QACxB,KAAK8C,WAAL;;QACA,IAAI,KAAKxC,IAAT,EAAe;UACX,KAAKA,IAAL,CAAUsC,gBAAV,CAA2B,OAA3B,EAAoC,KAAK3C,iBAAzC;QACH;MACJ;IACJ;IACD;AACR;AACA;;;IACQ8C,oBAAoB,GAAG;MACnB,KAAKnD,kBAAL,CAAwBoD,OAAxB,CAAgCZ,IAAI,IAAI,KAAK/B,KAAL,CAAW4C,mBAAX,CAA+Bb,IAA/B,EAAqC,KAAKc,eAA1C,CAAxC;;MACA,IAAI,CAAC,KAAKlD,gBAAN,IAA0B,KAAKM,IAAnC,EAAyC;QACrC,KAAKA,IAAL,CAAU2C,mBAAV,CAA8B,OAA9B,EAAuC,KAAKhD,iBAA5C;MACH;IACJ;IACD;AACR;AACA;;;IACQkD,aAAa,GAAG;MACZ,OAAO,KAAKnD,gBAAL,GACD,KAAKA,gBAAL,CAAsBmD,aAAtB,EADC,GAED,KAAK9C,KAAL,CAAW8C,aAAX,EAFN;IAGH;IACD;AACR;AACA;AACA;;;IACQC,cAAc,GAAG;MACb,OAAO,KAAKpD,gBAAL,GACD,KAAKA,gBAAL,CAAsBoD,cAAtB,EADC,GAED,KAAK/C,KAAL,CAAW+C,cAAX,EAFN;IAGH;IACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQC,WAAW,CAACC,KAAD,EAAQC,OAAR,EAAiBC,MAAjB,EAAyB;MAChC,IAAI,KAAKxD,gBAAT,EAA2B;QACvB,KAAKA,gBAAL,CAAsBqD,WAAtB,CAAkCC,KAAlC,EAAyCC,OAAzC,EAAkDC,MAAlD;MACH,CAFD,MAGK,IAAI,OAAOD,OAAP,KAAmB,QAAvB,EAAiC;QAClC,KAAKlD,KAAL,CAAWoD,iBAAX,CAA6BF,OAA7B;MACH;IACJ;IACD;AACR;AACA;AACA;AACA;;;IACQG,oBAAoB,CAAC/D,QAAD,EAAW;MAC3B,KAAKA,QAAL,GAAgBA,QAAhB;IACH;;IACDM,iBAAiB,GAAG;MAChB,KAAKwB,KAAL,GAAa,KAAK1B,YAAlB;MACA,KAAKL,UAAL,GAAkB,KAAlB;IACH;IACD;AACR;AACA;;;IACQoD,WAAW,GAAG;MACV,IAAIa,EAAJ;;MACA,IAAI,CAAC,KAAK9D,gBAAV,EAA4B;QACxB,KAAKA,gBAAL,GAAwB,IAAxB;QACA,KAAKQ,KAAL,CAAWuD,KAAX,CAAiBC,OAAjB,GAA2B,MAA3B;QACA,KAAKjE,kBAAL,CAAwBoD,OAAxB,CAAgCZ,IAAI,IAAI,KAAK/B,KAAL,CAAWuC,gBAAX,CAA4BR,IAA5B,EAAkC,KAAKc,eAAvC,CAAxC,EAHwB,CAIxB;QACA;QACA;QACA;;QACA,KAAK7C,KAAL,CAAWV,QAAX,GAAsB,KAAKA,QAA3B;QACA,KAAKU,KAAL,CAAWP,QAAX,GAAsB,KAAKA,QAA3B;;QACA,IAAI,OAAO,KAAKsC,IAAZ,KAAqB,QAAzB,EAAmC;UAC/B,KAAK/B,KAAL,CAAW+B,IAAX,GAAkB,KAAKA,IAAvB;QACH;;QACD,IAAI,OAAO,KAAKX,KAAZ,KAAsB,QAA1B,EAAoC;UAChC,KAAKpB,KAAL,CAAWoB,KAAX,GAAmB,KAAKA,KAAxB;QACH;;QACD,KAAKpB,KAAL,CAAWyD,YAAX,CAAwB,MAAxB,EAAgC/E,aAAhC;QACA,KAAKgF,SAAL,GAAiBC,QAAQ,CAACC,aAAT,CAAuB,MAAvB,CAAjB;QACA,KAAKF,SAAL,CAAeD,YAAf,CAA4B,MAA5B,EAAoC/E,aAApC;MACH;;MACD,CAAC4E,EAAE,GAAG,KAAKO,UAAX,MAA2B,IAA3B,IAAmCP,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACQ,WAAH,CAAe,KAAKJ,SAApB,CAA5D;MACA,KAAKI,WAAL,CAAiB,KAAK9D,KAAtB;IACH;IACD;AACR;AACA;;;IACQ+D,WAAW,GAAG;MACV,IAAIT,EAAJ;;MACA,KAAKU,WAAL,CAAiB,KAAKhE,KAAtB;MACA,CAACsD,EAAE,GAAG,KAAKO,UAAX,MAA2B,IAA3B,IAAmCP,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACU,WAAH,CAAe,KAAKN,SAApB,CAA5D;IACH;IACD;;;IACAnC,QAAQ,CAAC4B,MAAD,EAAS;MACb,IAAI,KAAKnD,KAAL,YAAsBS,WAA1B,EAAuC;QACnC,KAAKuC,WAAL,CAAiB,KAAKhD,KAAL,CAAWD,QAA5B,EAAsC,KAAKC,KAAL,CAAWE,iBAAjD,EAAoEiD,MAApE;MACH;IACJ;IACD;AACR;AACA;AACA;AACA;;;IACQ7B,YAAY,CAACF,KAAD,EAAQ6C,KAAR,EAAe;MACvB,IAAI,KAAKtE,gBAAT,EAA2B;QACvB,KAAKA,gBAAL,CAAsB2B,YAAtB,CAAmCF,KAAnC,EAA0C6C,KAAK,IAAI7C,KAAnD;MACH;IACJ;;IACDoB,gBAAgB,CAAC0B,CAAD,EAAI;MAChB,QAAQA,CAAC,CAACC,GAAV;QACI,KAAK1F,QAAL;UACI,IAAI,KAAKwB,IAAL,YAAqBmE,eAAzB,EAA0C;YACtC;YACA,MAAMC,aAAa,GAAG,KAAKpE,IAAL,CAAUqE,aAAV,CAAwB,eAAxB,CAAtB;YACAD,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,GAAqD,KAAK,CAA1D,GAA8DA,aAAa,CAACE,KAAd,EAA9D;UACH;;UACD;MAPR;IASH;IACD;AACR;AACA;AACA;;;IACQ1B,eAAe,CAACqB,CAAD,EAAI;MACfA,CAAC,CAACrB,eAAF;IACH;;EA/V4B,CAAjC;EAiWAzE,IAAI,CAAC;IAAEoG,IAAI,EAAE;EAAR,CAAD,CAAJ,CAA0BrF,CAAC,CAACL,SAA5B,EAAuC,UAAvC;EACAV,IAAI,CAAC;IAAEoG,IAAI,EAAE,UAAR;IAAoBC,SAAS,EAAE;EAA/B,CAAD,CAAJ,CAA+CtF,CAAC,CAACL,SAAjD,EAA4D,cAA5D;EACAV,IAAI,CAAC;IAAEqG,SAAS,EAAE;EAAb,CAAD,CAAJ,CAAqCtF,CAAC,CAACL,SAAvC,EAAkD,cAAlD;EACAV,IAAI,CAACe,CAAC,CAACL,SAAH,EAAc,MAAd,CAAJ;EACAV,IAAI,CAAC;IAAEoG,IAAI,EAAE;EAAR,CAAD,CAAJ,CAA0BrF,CAAC,CAACL,SAA5B,EAAuC,UAAvC;EACAN,UAAU,CAACW,CAAC,CAACL,SAAH,EAAc,OAAd,CAAV;EACA,OAAOK,CAAP;AACH;AACD;AACA;AACA;;AACA,OAAO,SAASuF,uBAAT,CAAiCxF,QAAjC,EAA2C;EAC9C,MAAMC,CAAN,SAAgBF,cAAc,CAACC,QAAD,CAA9B,CAAyC;;EAEzC,MAAMyF,CAAN,SAAgBxF,CAAhB,CAAkB;IACdC,WAAW,GAAU;MAAA,kCAANwF,IAAM;QAANA,IAAM;MAAA;;MACjB,MAAMA,IAAN;MACA;AACZ;AACA;AACA;AACA;;MACY,KAAKC,YAAL,GAAoB,KAApB;MACA;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;MACY,KAAKC,gBAAL,GAAwB,KAAxB;MACA;AACZ;AACA;AACA;AACA;;MACY,KAAKC,OAAL,GAAe,KAAf,CAtBiB,CAuBjB;MACA;;MACA,KAAKF,YAAL,GAAoB,KAApB;IACH;;IACDG,uBAAuB,GAAG;MACtB,KAAKC,cAAL,GAAsB,KAAKH,gBAA3B;IACH;IACD;AACR;AACA;;;IACQI,qBAAqB,GAAG;MACpB,IAAI,CAAC,KAAKL,YAAV,EAAwB;QACpB;QACA;QACA;QACA,KAAKE,OAAL,GAAe,KAAKE,cAApB;QACA,KAAKJ,YAAL,GAAoB,KAApB;MACH;IACJ;;IACDM,cAAc,CAAClD,IAAD,EAAOd,IAAP,EAAa;MACvB,IAAI,CAAC,KAAK0D,YAAV,EAAwB;QACpB,KAAKA,YAAL,GAAoB,IAApB;MACH;;MACD,KAAKO,cAAL,GAAsB,KAAKL,OAA3B;MACA,KAAKM,UAAL;;MACA,IAAI,KAAKrF,KAAL,YAAsBsF,gBAA1B,EAA4C;QACxC,KAAKtF,KAAL,CAAW+E,OAAX,GAAqB,KAAKA,OAA1B;MACH;;MACD,IAAI9C,IAAI,KAAKsD,SAAb,EAAwB;QACpB,KAAKC,KAAL,CAAW,QAAX;MACH;;MACD,KAAKjE,QAAL;IACH;;IACDkE,qBAAqB,CAACxD,IAAD,EAAOd,IAAP,EAAa;MAC9B,KAAK4D,OAAL,GAAe,KAAKK,cAApB;IACH;;IACDC,UAAU,GAAG;MACT,MAAMjE,KAAK,GAAG,KAAK2D,OAAL,GAAe,KAAK3D,KAApB,GAA4B,IAA1C;MACA,KAAKE,YAAL,CAAkBF,KAAlB,EAAyBA,KAAzB;IACH;;IACDkB,iBAAiB,GAAG;MAChB,MAAMA,iBAAN;MACA,KAAK+C,UAAL;IACH;;IACDzF,iBAAiB,GAAG;MAChB,MAAMA,iBAAN;MACA,KAAKmF,OAAL,GAAe,CAAC,CAAC,KAAKD,gBAAtB;MACA,KAAKD,YAAL,GAAoB,KAApB;IACH;;EAxEa;;EA0ElBzG,IAAI,CAAC;IAAEqG,SAAS,EAAE,SAAb;IAAwBD,IAAI,EAAE;EAA9B,CAAD,CAAJ,CAAgDG,CAAC,CAAC7F,SAAlD,EAA6D,kBAA7D;EACAV,IAAI,CAAC;IAAEqG,SAAS,EAAE,iBAAb;IAAgCiB,SAAS,EAAErH;EAA3C,CAAD,CAAJ,CAAoEsG,CAAC,CAAC7F,SAAtE,EAAiF,gBAAjF;EACAN,UAAU,CAACmG,CAAC,CAAC7F,SAAH,EAAc,gBAAd,CAAV;EACAN,UAAU,CAACmG,CAAC,CAAC7F,SAAH,EAAc,SAAd,CAAV;EACA,OAAO6F,CAAP;AACH"},"metadata":{},"sourceType":"module"}