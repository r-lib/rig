{"ast":null,"code":"import { $global } from \"@microsoft/fast-element\";\n/**\n *  A service to batch intersection event callbacks so multiple elements can share a single observer\n *\n * @public\n */\n\nexport class IntersectionService {\n  constructor() {\n    this.intersectionDetector = null;\n    this.observedElements = new Map();\n    /**\n     * Request the position of a target element\n     *\n     * @internal\n     */\n\n    this.requestPosition = (target, callback) => {\n      var _a;\n\n      if (this.intersectionDetector === null) {\n        return;\n      }\n\n      if (this.observedElements.has(target)) {\n        (_a = this.observedElements.get(target)) === null || _a === void 0 ? void 0 : _a.push(callback);\n        return;\n      }\n\n      this.observedElements.set(target, [callback]);\n      this.intersectionDetector.observe(target);\n    };\n    /**\n     * Cancel a position request\n     *\n     * @internal\n     */\n\n\n    this.cancelRequestPosition = (target, callback) => {\n      const callbacks = this.observedElements.get(target);\n\n      if (callbacks !== undefined) {\n        const callBackIndex = callbacks.indexOf(callback);\n\n        if (callBackIndex !== -1) {\n          callbacks.splice(callBackIndex, 1);\n        }\n      }\n    };\n    /**\n     * initialize intersection detector\n     */\n\n\n    this.initializeIntersectionDetector = () => {\n      if (!$global.IntersectionObserver) {\n        //intersection observer not supported\n        return;\n      }\n\n      this.intersectionDetector = new IntersectionObserver(this.handleIntersection, {\n        root: null,\n        rootMargin: \"0px\",\n        threshold: [0, 1]\n      });\n    };\n    /**\n     *  Handle intersections\n     */\n\n\n    this.handleIntersection = entries => {\n      if (this.intersectionDetector === null) {\n        return;\n      }\n\n      const pendingCallbacks = [];\n      const pendingCallbackParams = []; // go through the entries to build a list of callbacks and params for each\n\n      entries.forEach(entry => {\n        var _a; // stop watching this element until we get new update requests for it\n\n\n        (_a = this.intersectionDetector) === null || _a === void 0 ? void 0 : _a.unobserve(entry.target);\n        const thisElementCallbacks = this.observedElements.get(entry.target);\n\n        if (thisElementCallbacks !== undefined) {\n          thisElementCallbacks.forEach(callback => {\n            let targetCallbackIndex = pendingCallbacks.indexOf(callback);\n\n            if (targetCallbackIndex === -1) {\n              targetCallbackIndex = pendingCallbacks.length;\n              pendingCallbacks.push(callback);\n              pendingCallbackParams.push([]);\n            }\n\n            pendingCallbackParams[targetCallbackIndex].push(entry);\n          });\n          this.observedElements.delete(entry.target);\n        }\n      }); // execute callbacks\n\n      pendingCallbacks.forEach((callback, index) => {\n        callback(pendingCallbackParams[index]);\n      });\n    };\n\n    this.initializeIntersectionDetector();\n  }\n\n}","map":{"version":3,"names":["$global","IntersectionService","constructor","intersectionDetector","observedElements","Map","requestPosition","target","callback","_a","has","get","push","set","observe","cancelRequestPosition","callbacks","undefined","callBackIndex","indexOf","splice","initializeIntersectionDetector","IntersectionObserver","handleIntersection","root","rootMargin","threshold","entries","pendingCallbacks","pendingCallbackParams","forEach","entry","unobserve","thisElementCallbacks","targetCallbackIndex","length","delete","index"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/utilities/intersection-service.js"],"sourcesContent":["import { $global } from \"@microsoft/fast-element\";\n/**\n *  A service to batch intersection event callbacks so multiple elements can share a single observer\n *\n * @public\n */\nexport class IntersectionService {\n    constructor() {\n        this.intersectionDetector = null;\n        this.observedElements = new Map();\n        /**\n         * Request the position of a target element\n         *\n         * @internal\n         */\n        this.requestPosition = (target, callback) => {\n            var _a;\n            if (this.intersectionDetector === null) {\n                return;\n            }\n            if (this.observedElements.has(target)) {\n                (_a = this.observedElements.get(target)) === null || _a === void 0 ? void 0 : _a.push(callback);\n                return;\n            }\n            this.observedElements.set(target, [callback]);\n            this.intersectionDetector.observe(target);\n        };\n        /**\n         * Cancel a position request\n         *\n         * @internal\n         */\n        this.cancelRequestPosition = (target, callback) => {\n            const callbacks = this.observedElements.get(target);\n            if (callbacks !== undefined) {\n                const callBackIndex = callbacks.indexOf(callback);\n                if (callBackIndex !== -1) {\n                    callbacks.splice(callBackIndex, 1);\n                }\n            }\n        };\n        /**\n         * initialize intersection detector\n         */\n        this.initializeIntersectionDetector = () => {\n            if (!$global.IntersectionObserver) {\n                //intersection observer not supported\n                return;\n            }\n            this.intersectionDetector = new IntersectionObserver(this.handleIntersection, {\n                root: null,\n                rootMargin: \"0px\",\n                threshold: [0, 1],\n            });\n        };\n        /**\n         *  Handle intersections\n         */\n        this.handleIntersection = (entries) => {\n            if (this.intersectionDetector === null) {\n                return;\n            }\n            const pendingCallbacks = [];\n            const pendingCallbackParams = [];\n            // go through the entries to build a list of callbacks and params for each\n            entries.forEach((entry) => {\n                var _a;\n                // stop watching this element until we get new update requests for it\n                (_a = this.intersectionDetector) === null || _a === void 0 ? void 0 : _a.unobserve(entry.target);\n                const thisElementCallbacks = this.observedElements.get(entry.target);\n                if (thisElementCallbacks !== undefined) {\n                    thisElementCallbacks.forEach((callback) => {\n                        let targetCallbackIndex = pendingCallbacks.indexOf(callback);\n                        if (targetCallbackIndex === -1) {\n                            targetCallbackIndex = pendingCallbacks.length;\n                            pendingCallbacks.push(callback);\n                            pendingCallbackParams.push([]);\n                        }\n                        pendingCallbackParams[targetCallbackIndex].push(entry);\n                    });\n                    this.observedElements.delete(entry.target);\n                }\n            });\n            // execute callbacks\n            pendingCallbacks.forEach((callback, index) => {\n                callback(pendingCallbackParams[index]);\n            });\n        };\n        this.initializeIntersectionDetector();\n    }\n}\n"],"mappings":"AAAA,SAASA,OAAT,QAAwB,yBAAxB;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,mBAAN,CAA0B;EAC7BC,WAAW,GAAG;IACV,KAAKC,oBAAL,GAA4B,IAA5B;IACA,KAAKC,gBAAL,GAAwB,IAAIC,GAAJ,EAAxB;IACA;AACR;AACA;AACA;AACA;;IACQ,KAAKC,eAAL,GAAuB,CAACC,MAAD,EAASC,QAAT,KAAsB;MACzC,IAAIC,EAAJ;;MACA,IAAI,KAAKN,oBAAL,KAA8B,IAAlC,EAAwC;QACpC;MACH;;MACD,IAAI,KAAKC,gBAAL,CAAsBM,GAAtB,CAA0BH,MAA1B,CAAJ,EAAuC;QACnC,CAACE,EAAE,GAAG,KAAKL,gBAAL,CAAsBO,GAAtB,CAA0BJ,MAA1B,CAAN,MAA6C,IAA7C,IAAqDE,EAAE,KAAK,KAAK,CAAjE,GAAqE,KAAK,CAA1E,GAA8EA,EAAE,CAACG,IAAH,CAAQJ,QAAR,CAA9E;QACA;MACH;;MACD,KAAKJ,gBAAL,CAAsBS,GAAtB,CAA0BN,MAA1B,EAAkC,CAACC,QAAD,CAAlC;MACA,KAAKL,oBAAL,CAA0BW,OAA1B,CAAkCP,MAAlC;IACH,CAXD;IAYA;AACR;AACA;AACA;AACA;;;IACQ,KAAKQ,qBAAL,GAA6B,CAACR,MAAD,EAASC,QAAT,KAAsB;MAC/C,MAAMQ,SAAS,GAAG,KAAKZ,gBAAL,CAAsBO,GAAtB,CAA0BJ,MAA1B,CAAlB;;MACA,IAAIS,SAAS,KAAKC,SAAlB,EAA6B;QACzB,MAAMC,aAAa,GAAGF,SAAS,CAACG,OAAV,CAAkBX,QAAlB,CAAtB;;QACA,IAAIU,aAAa,KAAK,CAAC,CAAvB,EAA0B;UACtBF,SAAS,CAACI,MAAV,CAAiBF,aAAjB,EAAgC,CAAhC;QACH;MACJ;IACJ,CARD;IASA;AACR;AACA;;;IACQ,KAAKG,8BAAL,GAAsC,MAAM;MACxC,IAAI,CAACrB,OAAO,CAACsB,oBAAb,EAAmC;QAC/B;QACA;MACH;;MACD,KAAKnB,oBAAL,GAA4B,IAAImB,oBAAJ,CAAyB,KAAKC,kBAA9B,EAAkD;QAC1EC,IAAI,EAAE,IADoE;QAE1EC,UAAU,EAAE,KAF8D;QAG1EC,SAAS,EAAE,CAAC,CAAD,EAAI,CAAJ;MAH+D,CAAlD,CAA5B;IAKH,CAVD;IAWA;AACR;AACA;;;IACQ,KAAKH,kBAAL,GAA2BI,OAAD,IAAa;MACnC,IAAI,KAAKxB,oBAAL,KAA8B,IAAlC,EAAwC;QACpC;MACH;;MACD,MAAMyB,gBAAgB,GAAG,EAAzB;MACA,MAAMC,qBAAqB,GAAG,EAA9B,CALmC,CAMnC;;MACAF,OAAO,CAACG,OAAR,CAAiBC,KAAD,IAAW;QACvB,IAAItB,EAAJ,CADuB,CAEvB;;;QACA,CAACA,EAAE,GAAG,KAAKN,oBAAX,MAAqC,IAArC,IAA6CM,EAAE,KAAK,KAAK,CAAzD,GAA6D,KAAK,CAAlE,GAAsEA,EAAE,CAACuB,SAAH,CAAaD,KAAK,CAACxB,MAAnB,CAAtE;QACA,MAAM0B,oBAAoB,GAAG,KAAK7B,gBAAL,CAAsBO,GAAtB,CAA0BoB,KAAK,CAACxB,MAAhC,CAA7B;;QACA,IAAI0B,oBAAoB,KAAKhB,SAA7B,EAAwC;UACpCgB,oBAAoB,CAACH,OAArB,CAA8BtB,QAAD,IAAc;YACvC,IAAI0B,mBAAmB,GAAGN,gBAAgB,CAACT,OAAjB,CAAyBX,QAAzB,CAA1B;;YACA,IAAI0B,mBAAmB,KAAK,CAAC,CAA7B,EAAgC;cAC5BA,mBAAmB,GAAGN,gBAAgB,CAACO,MAAvC;cACAP,gBAAgB,CAAChB,IAAjB,CAAsBJ,QAAtB;cACAqB,qBAAqB,CAACjB,IAAtB,CAA2B,EAA3B;YACH;;YACDiB,qBAAqB,CAACK,mBAAD,CAArB,CAA2CtB,IAA3C,CAAgDmB,KAAhD;UACH,CARD;UASA,KAAK3B,gBAAL,CAAsBgC,MAAtB,CAA6BL,KAAK,CAACxB,MAAnC;QACH;MACJ,CAjBD,EAPmC,CAyBnC;;MACAqB,gBAAgB,CAACE,OAAjB,CAAyB,CAACtB,QAAD,EAAW6B,KAAX,KAAqB;QAC1C7B,QAAQ,CAACqB,qBAAqB,CAACQ,KAAD,CAAtB,CAAR;MACH,CAFD;IAGH,CA7BD;;IA8BA,KAAKhB,8BAAL;EACH;;AAnF4B"},"metadata":{},"sourceType":"module"}