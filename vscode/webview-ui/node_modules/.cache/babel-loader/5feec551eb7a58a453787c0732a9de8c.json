{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { attr, booleanConverter, DOM, nullableNumberConverter, observable } from \"@microsoft/fast-element\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\n/**\n * A HorizontalScroll Custom HTML Element\n *\n * @slot start - Content which can be provided before the scroll area\n * @slot end - Content which can be provided after the scroll area\n * @csspart scroll-area - Wraps the entire scrollable region\n * @csspart scroll-view - The visible scroll area\n * @csspart content-container - The container for the content\n * @csspart scroll-prev - The previous flipper container\n * @csspart scroll-action-previous - The element wrapping the previous flipper\n * @csspart scroll-next - The next flipper container\n * @csspart scroll-action-next - The element wrapping the next flipper\n * @fires scrollstart - Fires a custom 'scrollstart' event when scrolling\n * @fires scrollend - Fires a custom 'scrollend' event when scrolling stops\n *\n * @public\n */\n\nexport class HorizontalScroll extends FoundationElement {\n  constructor() {\n    super(...arguments);\n    /**\n     * @internal\n     */\n\n    this.framesPerSecond = 60;\n    /**\n     * Flag indicating that the items are being updated\n     *\n     * @internal\n     */\n\n    this.updatingItems = false;\n    /**\n     * Speed of scroll in pixels per second\n     * @public\n     */\n\n    this.speed = 600;\n    /**\n     * Attribute used for easing, defaults to ease-in-out\n     * @public\n     */\n\n    this.easing = \"ease-in-out\";\n    /**\n     * Attribute to hide flippers from assistive technology\n     * @public\n     */\n\n    this.flippersHiddenFromAT = false;\n    /**\n     * Scrolling state\n     * @internal\n     */\n\n    this.scrolling = false;\n    /**\n     * Detects if the component has been resized\n     * @internal\n     */\n\n    this.resizeDetector = null;\n  }\n  /**\n   * The calculated duration for a frame.\n   *\n   * @internal\n   */\n\n\n  get frameTime() {\n    return 1000 / this.framesPerSecond;\n  }\n  /**\n   * Firing scrollstart and scrollend events\n   * @internal\n   */\n\n\n  scrollingChanged(prev, next) {\n    if (this.scrollContainer) {\n      const event = this.scrolling == true ? \"scrollstart\" : \"scrollend\";\n      this.$emit(event, this.scrollContainer.scrollLeft);\n    }\n  }\n  /**\n   * In RTL mode\n   * @internal\n   */\n\n\n  get isRtl() {\n    return this.scrollItems.length > 1 && this.scrollItems[0].offsetLeft > this.scrollItems[1].offsetLeft;\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.initializeResizeDetector();\n  }\n\n  disconnectedCallback() {\n    this.disconnectResizeDetector();\n    super.disconnectedCallback();\n  }\n  /**\n   * Updates scroll stops and flippers when scroll items change\n   * @param previous - current scroll items\n   * @param next - new updated scroll items\n   * @public\n   */\n\n\n  scrollItemsChanged(previous, next) {\n    if (next && !this.updatingItems) {\n      DOM.queueUpdate(() => this.setStops());\n    }\n  }\n  /**\n   * destroys the instance's resize observer\n   * @internal\n   */\n\n\n  disconnectResizeDetector() {\n    if (this.resizeDetector) {\n      this.resizeDetector.disconnect();\n      this.resizeDetector = null;\n    }\n  }\n  /**\n   * initializes the instance's resize observer\n   * @internal\n   */\n\n\n  initializeResizeDetector() {\n    this.disconnectResizeDetector();\n    this.resizeDetector = new window.ResizeObserver(this.resized.bind(this));\n    this.resizeDetector.observe(this);\n  }\n  /**\n   * Looks for slots and uses child nodes instead\n   * @internal\n   */\n\n\n  updateScrollStops() {\n    this.updatingItems = true;\n    const updatedItems = this.scrollItems.reduce((scrollItems, scrollItem) => {\n      if (scrollItem instanceof HTMLSlotElement) {\n        return scrollItems.concat(scrollItem.assignedElements());\n      }\n\n      scrollItems.push(scrollItem);\n      return scrollItems;\n    }, []);\n    this.scrollItems = updatedItems;\n    this.updatingItems = false;\n  }\n  /**\n   * Finds all of the scroll stops between elements\n   * @internal\n   */\n\n\n  setStops() {\n    this.updateScrollStops();\n    const {\n      scrollContainer: container\n    } = this;\n    const {\n      scrollLeft\n    } = container;\n    const {\n      width: containerWidth,\n      left: containerLeft\n    } = container.getBoundingClientRect();\n    this.width = containerWidth;\n    let lastStop = 0;\n    let stops = this.scrollItems.map((item, index) => {\n      const {\n        left,\n        width\n      } = item.getBoundingClientRect();\n      const leftPosition = Math.round(left + scrollLeft - containerLeft);\n      const right = Math.round(leftPosition + width);\n\n      if (this.isRtl) {\n        return -right;\n      }\n\n      lastStop = right;\n      return index === 0 ? 0 : leftPosition;\n    }).concat(lastStop);\n    /* Fixes a FireFox bug where it doesn't scroll to the start */\n\n    stops = this.fixScrollMisalign(stops);\n    /* Sort to zero */\n\n    stops.sort((a, b) => Math.abs(a) - Math.abs(b));\n    this.scrollStops = stops;\n    this.setFlippers();\n  }\n  /**\n   *\n   */\n\n\n  fixScrollMisalign(stops) {\n    if (this.isRtl && stops.some(stop => stop > 0)) {\n      stops.sort((a, b) => b - a);\n      const offset = stops[0];\n      stops = stops.map(stop => stop - offset);\n    }\n\n    return stops;\n  }\n  /**\n   * Sets the controls view if enabled\n   * @internal\n   */\n\n\n  setFlippers() {\n    var _a, _b;\n\n    const position = this.scrollContainer.scrollLeft;\n    (_a = this.previousFlipperContainer) === null || _a === void 0 ? void 0 : _a.classList.toggle(\"disabled\", position === 0);\n\n    if (this.scrollStops) {\n      const lastStop = Math.abs(this.scrollStops[this.scrollStops.length - 1]);\n      (_b = this.nextFlipperContainer) === null || _b === void 0 ? void 0 : _b.classList.toggle(\"disabled\", Math.abs(position) + this.width >= lastStop);\n    }\n  }\n  /**\n   * Function that can scroll an item into view.\n   * @param item - An item index, a scroll item or a child of one of the scroll items\n   * @param padding - Padding of the viewport where the active item shouldn't be\n   * @param rightPadding - Optional right padding. Uses the padding if not defined\n   *\n   * @public\n   */\n\n\n  scrollInView(item) {\n    let padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let rightPadding = arguments.length > 2 ? arguments[2] : undefined;\n\n    var _a;\n\n    if (typeof item !== \"number\" && item) {\n      item = this.scrollItems.findIndex(scrollItem => scrollItem === item || scrollItem.contains(item));\n    }\n\n    if (item !== undefined) {\n      rightPadding = rightPadding !== null && rightPadding !== void 0 ? rightPadding : padding;\n      const {\n        scrollContainer: container,\n        scrollStops,\n        scrollItems: items\n      } = this;\n      const {\n        scrollLeft\n      } = this.scrollContainer;\n      const {\n        width: containerWidth\n      } = container.getBoundingClientRect();\n      const itemStart = scrollStops[item];\n      const {\n        width\n      } = items[item].getBoundingClientRect();\n      const itemEnd = itemStart + width;\n      const isBefore = scrollLeft + padding > itemStart;\n\n      if (isBefore || scrollLeft + containerWidth - rightPadding < itemEnd) {\n        const stops = [...scrollStops].sort((a, b) => isBefore ? b - a : a - b);\n        const scrollTo = (_a = stops.find(position => isBefore ? position + padding < itemStart : position + containerWidth - (rightPadding !== null && rightPadding !== void 0 ? rightPadding : 0) > itemEnd)) !== null && _a !== void 0 ? _a : 0;\n        this.scrollToPosition(scrollTo);\n      }\n    }\n  }\n  /**\n   * Lets the user arrow left and right through the horizontal scroll\n   * @param e - Keyboard event\n   * @public\n   */\n\n\n  keyupHandler(e) {\n    const key = e.key;\n\n    switch (key) {\n      case \"ArrowLeft\":\n        this.scrollToPrevious();\n        break;\n\n      case \"ArrowRight\":\n        this.scrollToNext();\n        break;\n    }\n  }\n  /**\n   * Scrolls items to the left\n   * @public\n   */\n\n\n  scrollToPrevious() {\n    const scrollPosition = this.scrollContainer.scrollLeft;\n    const current = this.scrollStops.findIndex((stop, index) => stop >= scrollPosition && (this.isRtl || index === this.scrollStops.length - 1 || this.scrollStops[index + 1] > scrollPosition));\n    const right = Math.abs(this.scrollStops[current + 1]);\n    let nextIndex = this.scrollStops.findIndex(stop => Math.abs(stop) + this.width > right);\n\n    if (nextIndex >= current || nextIndex === -1) {\n      nextIndex = current > 0 ? current - 1 : 0;\n    }\n\n    this.scrollToPosition(this.scrollStops[nextIndex], scrollPosition);\n  }\n  /**\n   * Scrolls items to the right\n   * @public\n   */\n\n\n  scrollToNext() {\n    const scrollPosition = this.scrollContainer.scrollLeft;\n    const current = this.scrollStops.findIndex(stop => Math.abs(stop) >= Math.abs(scrollPosition));\n    const outOfView = this.scrollStops.findIndex(stop => Math.abs(scrollPosition) + this.width <= Math.abs(stop));\n    let nextIndex = current;\n\n    if (outOfView > current + 2) {\n      nextIndex = outOfView - 2;\n    } else if (current < this.scrollStops.length - 2) {\n      nextIndex = current + 1;\n    }\n\n    this.scrollToPosition(this.scrollStops[nextIndex], scrollPosition);\n  }\n  /**\n   * Handles scrolling with easing\n   * @param position - starting position\n   * @param newPosition - position to scroll to\n   * @public\n   */\n\n\n  scrollToPosition(newPosition) {\n    let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scrollContainer.scrollLeft;\n\n    var _a;\n\n    if (this.scrolling) {\n      return;\n    }\n\n    this.scrolling = true;\n    const seconds = (_a = this.duration) !== null && _a !== void 0 ? _a : `${Math.abs(newPosition - position) / this.speed}s`;\n    this.content.style.setProperty(\"transition-duration\", seconds);\n    const computedDuration = parseFloat(getComputedStyle(this.content).getPropertyValue(\"transition-duration\"));\n\n    const transitionendHandler = e => {\n      if (e && e.target !== e.currentTarget) {\n        return;\n      }\n\n      this.content.style.setProperty(\"transition-duration\", \"0s\");\n      this.content.style.removeProperty(\"transform\");\n      this.scrollContainer.style.setProperty(\"scroll-behavior\", \"auto\");\n      this.scrollContainer.scrollLeft = newPosition;\n      this.setFlippers();\n      this.content.removeEventListener(\"transitionend\", transitionendHandler);\n      this.scrolling = false;\n    };\n\n    if (computedDuration === 0) {\n      transitionendHandler();\n      return;\n    }\n\n    this.content.addEventListener(\"transitionend\", transitionendHandler);\n    const maxScrollValue = this.scrollContainer.scrollWidth - this.scrollContainer.clientWidth;\n    let transitionStop = this.scrollContainer.scrollLeft - Math.min(newPosition, maxScrollValue);\n\n    if (this.isRtl) {\n      transitionStop = this.scrollContainer.scrollLeft + Math.min(Math.abs(newPosition), maxScrollValue);\n    }\n\n    this.content.style.setProperty(\"transition-property\", \"transform\");\n    this.content.style.setProperty(\"transition-timing-function\", this.easing);\n    this.content.style.setProperty(\"transform\", `translateX(${transitionStop}px)`);\n  }\n  /**\n   * Monitors resize event on the horizontal-scroll element\n   * @public\n   */\n\n\n  resized() {\n    if (this.resizeTimeout) {\n      this.resizeTimeout = clearTimeout(this.resizeTimeout);\n    }\n\n    this.resizeTimeout = setTimeout(() => {\n      this.width = this.scrollContainer.offsetWidth;\n      this.setFlippers();\n    }, this.frameTime);\n  }\n  /**\n   * Monitors scrolled event on the content container\n   * @public\n   */\n\n\n  scrolled() {\n    if (this.scrollTimeout) {\n      this.scrollTimeout = clearTimeout(this.scrollTimeout);\n    }\n\n    this.scrollTimeout = setTimeout(() => {\n      this.setFlippers();\n    }, this.frameTime);\n  }\n\n}\n\n__decorate([attr({\n  converter: nullableNumberConverter\n})], HorizontalScroll.prototype, \"speed\", void 0);\n\n__decorate([attr], HorizontalScroll.prototype, \"duration\", void 0);\n\n__decorate([attr], HorizontalScroll.prototype, \"easing\", void 0);\n\n__decorate([attr({\n  attribute: \"flippers-hidden-from-at\",\n  converter: booleanConverter\n})], HorizontalScroll.prototype, \"flippersHiddenFromAT\", void 0);\n\n__decorate([observable], HorizontalScroll.prototype, \"scrolling\", void 0);\n\n__decorate([observable], HorizontalScroll.prototype, \"scrollItems\", void 0);\n\n__decorate([attr({\n  attribute: \"view\"\n})], HorizontalScroll.prototype, \"view\", void 0);","map":{"version":3,"names":["__decorate","attr","booleanConverter","DOM","nullableNumberConverter","observable","FoundationElement","HorizontalScroll","constructor","arguments","framesPerSecond","updatingItems","speed","easing","flippersHiddenFromAT","scrolling","resizeDetector","frameTime","scrollingChanged","prev","next","scrollContainer","event","$emit","scrollLeft","isRtl","scrollItems","length","offsetLeft","connectedCallback","initializeResizeDetector","disconnectedCallback","disconnectResizeDetector","scrollItemsChanged","previous","queueUpdate","setStops","disconnect","window","ResizeObserver","resized","bind","observe","updateScrollStops","updatedItems","reduce","scrollItem","HTMLSlotElement","concat","assignedElements","push","container","width","containerWidth","left","containerLeft","getBoundingClientRect","lastStop","stops","map","item","index","leftPosition","Math","round","right","fixScrollMisalign","sort","a","b","abs","scrollStops","setFlippers","some","stop","offset","_a","_b","position","previousFlipperContainer","classList","toggle","nextFlipperContainer","scrollInView","padding","rightPadding","findIndex","contains","undefined","items","itemStart","itemEnd","isBefore","scrollTo","find","scrollToPosition","keyupHandler","e","key","scrollToPrevious","scrollToNext","scrollPosition","current","nextIndex","outOfView","newPosition","seconds","duration","content","style","setProperty","computedDuration","parseFloat","getComputedStyle","getPropertyValue","transitionendHandler","target","currentTarget","removeProperty","removeEventListener","addEventListener","maxScrollValue","scrollWidth","clientWidth","transitionStop","min","resizeTimeout","clearTimeout","setTimeout","offsetWidth","scrolled","scrollTimeout","converter","prototype","attribute"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/horizontal-scroll.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { attr, booleanConverter, DOM, nullableNumberConverter, observable, } from \"@microsoft/fast-element\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\n/**\n * A HorizontalScroll Custom HTML Element\n *\n * @slot start - Content which can be provided before the scroll area\n * @slot end - Content which can be provided after the scroll area\n * @csspart scroll-area - Wraps the entire scrollable region\n * @csspart scroll-view - The visible scroll area\n * @csspart content-container - The container for the content\n * @csspart scroll-prev - The previous flipper container\n * @csspart scroll-action-previous - The element wrapping the previous flipper\n * @csspart scroll-next - The next flipper container\n * @csspart scroll-action-next - The element wrapping the next flipper\n * @fires scrollstart - Fires a custom 'scrollstart' event when scrolling\n * @fires scrollend - Fires a custom 'scrollend' event when scrolling stops\n *\n * @public\n */\nexport class HorizontalScroll extends FoundationElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * @internal\n         */\n        this.framesPerSecond = 60;\n        /**\n         * Flag indicating that the items are being updated\n         *\n         * @internal\n         */\n        this.updatingItems = false;\n        /**\n         * Speed of scroll in pixels per second\n         * @public\n         */\n        this.speed = 600;\n        /**\n         * Attribute used for easing, defaults to ease-in-out\n         * @public\n         */\n        this.easing = \"ease-in-out\";\n        /**\n         * Attribute to hide flippers from assistive technology\n         * @public\n         */\n        this.flippersHiddenFromAT = false;\n        /**\n         * Scrolling state\n         * @internal\n         */\n        this.scrolling = false;\n        /**\n         * Detects if the component has been resized\n         * @internal\n         */\n        this.resizeDetector = null;\n    }\n    /**\n     * The calculated duration for a frame.\n     *\n     * @internal\n     */\n    get frameTime() {\n        return 1000 / this.framesPerSecond;\n    }\n    /**\n     * Firing scrollstart and scrollend events\n     * @internal\n     */\n    scrollingChanged(prev, next) {\n        if (this.scrollContainer) {\n            const event = this.scrolling == true ? \"scrollstart\" : \"scrollend\";\n            this.$emit(event, this.scrollContainer.scrollLeft);\n        }\n    }\n    /**\n     * In RTL mode\n     * @internal\n     */\n    get isRtl() {\n        return (this.scrollItems.length > 1 &&\n            this.scrollItems[0].offsetLeft > this.scrollItems[1].offsetLeft);\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.initializeResizeDetector();\n    }\n    disconnectedCallback() {\n        this.disconnectResizeDetector();\n        super.disconnectedCallback();\n    }\n    /**\n     * Updates scroll stops and flippers when scroll items change\n     * @param previous - current scroll items\n     * @param next - new updated scroll items\n     * @public\n     */\n    scrollItemsChanged(previous, next) {\n        if (next && !this.updatingItems) {\n            DOM.queueUpdate(() => this.setStops());\n        }\n    }\n    /**\n     * destroys the instance's resize observer\n     * @internal\n     */\n    disconnectResizeDetector() {\n        if (this.resizeDetector) {\n            this.resizeDetector.disconnect();\n            this.resizeDetector = null;\n        }\n    }\n    /**\n     * initializes the instance's resize observer\n     * @internal\n     */\n    initializeResizeDetector() {\n        this.disconnectResizeDetector();\n        this.resizeDetector = new window.ResizeObserver(this.resized.bind(this));\n        this.resizeDetector.observe(this);\n    }\n    /**\n     * Looks for slots and uses child nodes instead\n     * @internal\n     */\n    updateScrollStops() {\n        this.updatingItems = true;\n        const updatedItems = this.scrollItems.reduce((scrollItems, scrollItem) => {\n            if (scrollItem instanceof HTMLSlotElement) {\n                return scrollItems.concat(scrollItem.assignedElements());\n            }\n            scrollItems.push(scrollItem);\n            return scrollItems;\n        }, []);\n        this.scrollItems = updatedItems;\n        this.updatingItems = false;\n    }\n    /**\n     * Finds all of the scroll stops between elements\n     * @internal\n     */\n    setStops() {\n        this.updateScrollStops();\n        const { scrollContainer: container } = this;\n        const { scrollLeft } = container;\n        const { width: containerWidth, left: containerLeft, } = container.getBoundingClientRect();\n        this.width = containerWidth;\n        let lastStop = 0;\n        let stops = this.scrollItems\n            .map((item, index) => {\n            const { left, width } = item.getBoundingClientRect();\n            const leftPosition = Math.round(left + scrollLeft - containerLeft);\n            const right = Math.round(leftPosition + width);\n            if (this.isRtl) {\n                return -right;\n            }\n            lastStop = right;\n            return index === 0 ? 0 : leftPosition;\n        })\n            .concat(lastStop);\n        /* Fixes a FireFox bug where it doesn't scroll to the start */\n        stops = this.fixScrollMisalign(stops);\n        /* Sort to zero */\n        stops.sort((a, b) => Math.abs(a) - Math.abs(b));\n        this.scrollStops = stops;\n        this.setFlippers();\n    }\n    /**\n     *\n     */\n    fixScrollMisalign(stops) {\n        if (this.isRtl && stops.some(stop => stop > 0)) {\n            stops.sort((a, b) => b - a);\n            const offset = stops[0];\n            stops = stops.map(stop => stop - offset);\n        }\n        return stops;\n    }\n    /**\n     * Sets the controls view if enabled\n     * @internal\n     */\n    setFlippers() {\n        var _a, _b;\n        const position = this.scrollContainer.scrollLeft;\n        (_a = this.previousFlipperContainer) === null || _a === void 0 ? void 0 : _a.classList.toggle(\"disabled\", position === 0);\n        if (this.scrollStops) {\n            const lastStop = Math.abs(this.scrollStops[this.scrollStops.length - 1]);\n            (_b = this.nextFlipperContainer) === null || _b === void 0 ? void 0 : _b.classList.toggle(\"disabled\", Math.abs(position) + this.width >= lastStop);\n        }\n    }\n    /**\n     * Function that can scroll an item into view.\n     * @param item - An item index, a scroll item or a child of one of the scroll items\n     * @param padding - Padding of the viewport where the active item shouldn't be\n     * @param rightPadding - Optional right padding. Uses the padding if not defined\n     *\n     * @public\n     */\n    scrollInView(item, padding = 0, rightPadding) {\n        var _a;\n        if (typeof item !== \"number\" && item) {\n            item = this.scrollItems.findIndex(scrollItem => scrollItem === item || scrollItem.contains(item));\n        }\n        if (item !== undefined) {\n            rightPadding = rightPadding !== null && rightPadding !== void 0 ? rightPadding : padding;\n            const { scrollContainer: container, scrollStops, scrollItems: items } = this;\n            const { scrollLeft } = this.scrollContainer;\n            const { width: containerWidth } = container.getBoundingClientRect();\n            const itemStart = scrollStops[item];\n            const { width } = items[item].getBoundingClientRect();\n            const itemEnd = itemStart + width;\n            const isBefore = scrollLeft + padding > itemStart;\n            if (isBefore || scrollLeft + containerWidth - rightPadding < itemEnd) {\n                const stops = [...scrollStops].sort((a, b) => (isBefore ? b - a : a - b));\n                const scrollTo = (_a = stops.find(position => isBefore\n                    ? position + padding < itemStart\n                    : position + containerWidth - (rightPadding !== null && rightPadding !== void 0 ? rightPadding : 0) > itemEnd)) !== null && _a !== void 0 ? _a : 0;\n                this.scrollToPosition(scrollTo);\n            }\n        }\n    }\n    /**\n     * Lets the user arrow left and right through the horizontal scroll\n     * @param e - Keyboard event\n     * @public\n     */\n    keyupHandler(e) {\n        const key = e.key;\n        switch (key) {\n            case \"ArrowLeft\":\n                this.scrollToPrevious();\n                break;\n            case \"ArrowRight\":\n                this.scrollToNext();\n                break;\n        }\n    }\n    /**\n     * Scrolls items to the left\n     * @public\n     */\n    scrollToPrevious() {\n        const scrollPosition = this.scrollContainer.scrollLeft;\n        const current = this.scrollStops.findIndex((stop, index) => stop >= scrollPosition &&\n            (this.isRtl ||\n                index === this.scrollStops.length - 1 ||\n                this.scrollStops[index + 1] > scrollPosition));\n        const right = Math.abs(this.scrollStops[current + 1]);\n        let nextIndex = this.scrollStops.findIndex(stop => Math.abs(stop) + this.width > right);\n        if (nextIndex >= current || nextIndex === -1) {\n            nextIndex = current > 0 ? current - 1 : 0;\n        }\n        this.scrollToPosition(this.scrollStops[nextIndex], scrollPosition);\n    }\n    /**\n     * Scrolls items to the right\n     * @public\n     */\n    scrollToNext() {\n        const scrollPosition = this.scrollContainer.scrollLeft;\n        const current = this.scrollStops.findIndex(stop => Math.abs(stop) >= Math.abs(scrollPosition));\n        const outOfView = this.scrollStops.findIndex(stop => Math.abs(scrollPosition) + this.width <= Math.abs(stop));\n        let nextIndex = current;\n        if (outOfView > current + 2) {\n            nextIndex = outOfView - 2;\n        }\n        else if (current < this.scrollStops.length - 2) {\n            nextIndex = current + 1;\n        }\n        this.scrollToPosition(this.scrollStops[nextIndex], scrollPosition);\n    }\n    /**\n     * Handles scrolling with easing\n     * @param position - starting position\n     * @param newPosition - position to scroll to\n     * @public\n     */\n    scrollToPosition(newPosition, position = this.scrollContainer.scrollLeft) {\n        var _a;\n        if (this.scrolling) {\n            return;\n        }\n        this.scrolling = true;\n        const seconds = (_a = this.duration) !== null && _a !== void 0 ? _a : `${Math.abs(newPosition - position) / this.speed}s`;\n        this.content.style.setProperty(\"transition-duration\", seconds);\n        const computedDuration = parseFloat(getComputedStyle(this.content).getPropertyValue(\"transition-duration\"));\n        const transitionendHandler = (e) => {\n            if (e && e.target !== e.currentTarget) {\n                return;\n            }\n            this.content.style.setProperty(\"transition-duration\", \"0s\");\n            this.content.style.removeProperty(\"transform\");\n            this.scrollContainer.style.setProperty(\"scroll-behavior\", \"auto\");\n            this.scrollContainer.scrollLeft = newPosition;\n            this.setFlippers();\n            this.content.removeEventListener(\"transitionend\", transitionendHandler);\n            this.scrolling = false;\n        };\n        if (computedDuration === 0) {\n            transitionendHandler();\n            return;\n        }\n        this.content.addEventListener(\"transitionend\", transitionendHandler);\n        const maxScrollValue = this.scrollContainer.scrollWidth - this.scrollContainer.clientWidth;\n        let transitionStop = this.scrollContainer.scrollLeft - Math.min(newPosition, maxScrollValue);\n        if (this.isRtl) {\n            transitionStop =\n                this.scrollContainer.scrollLeft +\n                    Math.min(Math.abs(newPosition), maxScrollValue);\n        }\n        this.content.style.setProperty(\"transition-property\", \"transform\");\n        this.content.style.setProperty(\"transition-timing-function\", this.easing);\n        this.content.style.setProperty(\"transform\", `translateX(${transitionStop}px)`);\n    }\n    /**\n     * Monitors resize event on the horizontal-scroll element\n     * @public\n     */\n    resized() {\n        if (this.resizeTimeout) {\n            this.resizeTimeout = clearTimeout(this.resizeTimeout);\n        }\n        this.resizeTimeout = setTimeout(() => {\n            this.width = this.scrollContainer.offsetWidth;\n            this.setFlippers();\n        }, this.frameTime);\n    }\n    /**\n     * Monitors scrolled event on the content container\n     * @public\n     */\n    scrolled() {\n        if (this.scrollTimeout) {\n            this.scrollTimeout = clearTimeout(this.scrollTimeout);\n        }\n        this.scrollTimeout = setTimeout(() => {\n            this.setFlippers();\n        }, this.frameTime);\n    }\n}\n__decorate([\n    attr({ converter: nullableNumberConverter })\n], HorizontalScroll.prototype, \"speed\", void 0);\n__decorate([\n    attr\n], HorizontalScroll.prototype, \"duration\", void 0);\n__decorate([\n    attr\n], HorizontalScroll.prototype, \"easing\", void 0);\n__decorate([\n    attr({ attribute: \"flippers-hidden-from-at\", converter: booleanConverter })\n], HorizontalScroll.prototype, \"flippersHiddenFromAT\", void 0);\n__decorate([\n    observable\n], HorizontalScroll.prototype, \"scrolling\", void 0);\n__decorate([\n    observable\n], HorizontalScroll.prototype, \"scrollItems\", void 0);\n__decorate([\n    attr({ attribute: \"view\" })\n], HorizontalScroll.prototype, \"view\", void 0);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}