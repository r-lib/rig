{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { attr, DOM, observable, RepeatDirective } from \"@microsoft/fast-element\";\nimport { eventFocus, eventFocusOut, eventKeyDown, keyArrowDown, keyArrowUp, keyEnd, keyHome, keyPageDown, keyPageUp } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\nimport { DataGridRowTypes, GenerateHeaderOptions } from \"./data-grid.options.js\";\nexport { DataGridRowTypes, GenerateHeaderOptions };\n/**\n * A Data Grid Custom HTML Element.\n *\n * @slot - The default slot for custom row elements\n * @public\n */\n\nexport class DataGrid extends FoundationElement {\n  constructor() {\n    super();\n    /**\n     * When true the component will not add itself to the tab queue.\n     * Default is false.\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: no-tabbing\n     */\n\n    this.noTabbing = false;\n    /**\n     *  Whether the grid should automatically generate a header row and its type\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: generate-header\n     */\n\n    this.generateHeader = GenerateHeaderOptions.default;\n    /**\n     * The data being displayed in the grid\n     *\n     * @public\n     */\n\n    this.rowsData = [];\n    /**\n     * The column definitions of the grid\n     *\n     * @public\n     */\n\n    this.columnDefinitions = null;\n    /**\n     * The index of the row that will receive focus the next time the\n     * grid is focused. This value changes as focus moves to different\n     * rows within the grid.  Changing this value when focus is already\n     * within the grid moves focus to the specified row.\n     *\n     * @public\n     */\n\n    this.focusRowIndex = 0;\n    /**\n     * The index of the column that will receive focus the next time the\n     * grid is focused. This value changes as focus moves to different rows\n     * within the grid.  Changing this value when focus is already within\n     * the grid moves focus to the specified column.\n     *\n     * @public\n     */\n\n    this.focusColumnIndex = 0;\n    this.rowsPlaceholder = null;\n    this.generatedHeader = null;\n    this.isUpdatingFocus = false;\n    this.pendingFocusUpdate = false;\n    this.rowindexUpdateQueued = false;\n    this.columnDefinitionsStale = true;\n    this.generatedGridTemplateColumns = \"\";\n\n    this.focusOnCell = (rowIndex, columnIndex, scrollIntoView) => {\n      if (this.rowElements.length === 0) {\n        this.focusRowIndex = 0;\n        this.focusColumnIndex = 0;\n        return;\n      }\n\n      const focusRowIndex = Math.max(0, Math.min(this.rowElements.length - 1, rowIndex));\n      const focusRow = this.rowElements[focusRowIndex];\n      const cells = focusRow.querySelectorAll('[role=\"cell\"], [role=\"gridcell\"], [role=\"columnheader\"], [role=\"rowheader\"]');\n      const focusColumnIndex = Math.max(0, Math.min(cells.length - 1, columnIndex));\n      const focusTarget = cells[focusColumnIndex];\n\n      if (scrollIntoView && this.scrollHeight !== this.clientHeight && (focusRowIndex < this.focusRowIndex && this.scrollTop > 0 || focusRowIndex > this.focusRowIndex && this.scrollTop < this.scrollHeight - this.clientHeight)) {\n        focusTarget.scrollIntoView({\n          block: \"center\",\n          inline: \"center\"\n        });\n      }\n\n      focusTarget.focus();\n    };\n\n    this.onChildListChange = (mutations,\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    observer) => {\n      if (mutations && mutations.length) {\n        mutations.forEach(mutation => {\n          mutation.addedNodes.forEach(newNode => {\n            if (newNode.nodeType === 1 && newNode.getAttribute(\"role\") === \"row\") {\n              newNode.columnDefinitions = this.columnDefinitions;\n            }\n          });\n        });\n        this.queueRowIndexUpdate();\n      }\n    };\n\n    this.queueRowIndexUpdate = () => {\n      if (!this.rowindexUpdateQueued) {\n        this.rowindexUpdateQueued = true;\n        DOM.queueUpdate(this.updateRowIndexes);\n      }\n    };\n\n    this.updateRowIndexes = () => {\n      let newGridTemplateColumns = this.gridTemplateColumns;\n\n      if (newGridTemplateColumns === undefined) {\n        // try to generate columns based on manual rows\n        if (this.generatedGridTemplateColumns === \"\" && this.rowElements.length > 0) {\n          const firstRow = this.rowElements[0];\n          this.generatedGridTemplateColumns = new Array(firstRow.cellElements.length).fill(\"1fr\").join(\" \");\n        }\n\n        newGridTemplateColumns = this.generatedGridTemplateColumns;\n      }\n\n      this.rowElements.forEach((element, index) => {\n        const thisRow = element;\n        thisRow.rowIndex = index;\n        thisRow.gridTemplateColumns = newGridTemplateColumns;\n\n        if (this.columnDefinitionsStale) {\n          thisRow.columnDefinitions = this.columnDefinitions;\n        }\n      });\n      this.rowindexUpdateQueued = false;\n      this.columnDefinitionsStale = false;\n    };\n  }\n  /**\n   *  generates a gridTemplateColumns based on columndata array\n   */\n\n\n  static generateTemplateColumns(columnDefinitions) {\n    let templateColumns = \"\";\n    columnDefinitions.forEach(column => {\n      templateColumns = `${templateColumns}${templateColumns === \"\" ? \"\" : \" \"}${\"1fr\"}`;\n    });\n    return templateColumns;\n  }\n\n  noTabbingChanged() {\n    if (this.$fastController.isConnected) {\n      if (this.noTabbing) {\n        this.setAttribute(\"tabIndex\", \"-1\");\n      } else {\n        this.setAttribute(\"tabIndex\", this.contains(document.activeElement) || this === document.activeElement ? \"-1\" : \"0\");\n      }\n    }\n  }\n\n  generateHeaderChanged() {\n    if (this.$fastController.isConnected) {\n      this.toggleGeneratedHeader();\n    }\n  }\n\n  gridTemplateColumnsChanged() {\n    if (this.$fastController.isConnected) {\n      this.updateRowIndexes();\n    }\n  }\n\n  rowsDataChanged() {\n    if (this.columnDefinitions === null && this.rowsData.length > 0) {\n      this.columnDefinitions = DataGrid.generateColumns(this.rowsData[0]);\n    }\n\n    if (this.$fastController.isConnected) {\n      this.toggleGeneratedHeader();\n    }\n  }\n\n  columnDefinitionsChanged() {\n    if (this.columnDefinitions === null) {\n      this.generatedGridTemplateColumns = \"\";\n      return;\n    }\n\n    this.generatedGridTemplateColumns = DataGrid.generateTemplateColumns(this.columnDefinitions);\n\n    if (this.$fastController.isConnected) {\n      this.columnDefinitionsStale = true;\n      this.queueRowIndexUpdate();\n    }\n  }\n\n  headerCellItemTemplateChanged() {\n    if (this.$fastController.isConnected) {\n      if (this.generatedHeader !== null) {\n        this.generatedHeader.headerCellItemTemplate = this.headerCellItemTemplate;\n      }\n    }\n  }\n\n  focusRowIndexChanged() {\n    if (this.$fastController.isConnected) {\n      this.queueFocusUpdate();\n    }\n  }\n\n  focusColumnIndexChanged() {\n    if (this.$fastController.isConnected) {\n      this.queueFocusUpdate();\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    if (this.rowItemTemplate === undefined) {\n      this.rowItemTemplate = this.defaultRowItemTemplate;\n    }\n\n    this.rowsPlaceholder = document.createComment(\"\");\n    this.appendChild(this.rowsPlaceholder);\n    this.toggleGeneratedHeader();\n    this.rowsRepeatBehavior = new RepeatDirective(x => x.rowsData, x => x.rowItemTemplate, {\n      positioning: true\n    }).createBehavior(this.rowsPlaceholder);\n    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n\n    this.$fastController.addBehaviors([this.rowsRepeatBehavior]);\n    this.addEventListener(\"row-focused\", this.handleRowFocus);\n    this.addEventListener(eventFocus, this.handleFocus);\n    this.addEventListener(eventKeyDown, this.handleKeydown);\n    this.addEventListener(eventFocusOut, this.handleFocusOut);\n    this.observer = new MutationObserver(this.onChildListChange); // only observe if nodes are added or removed\n\n    this.observer.observe(this, {\n      childList: true\n    });\n\n    if (this.noTabbing) {\n      this.setAttribute(\"tabindex\", \"-1\");\n    }\n\n    DOM.queueUpdate(this.queueRowIndexUpdate);\n  }\n  /**\n   * @internal\n   */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.removeEventListener(\"row-focused\", this.handleRowFocus);\n    this.removeEventListener(eventFocus, this.handleFocus);\n    this.removeEventListener(eventKeyDown, this.handleKeydown);\n    this.removeEventListener(eventFocusOut, this.handleFocusOut); // disconnect observer\n\n    this.observer.disconnect();\n    this.rowsPlaceholder = null;\n    this.generatedHeader = null;\n  }\n  /**\n   * @internal\n   */\n\n\n  handleRowFocus(e) {\n    this.isUpdatingFocus = true;\n    const focusRow = e.target;\n    this.focusRowIndex = this.rowElements.indexOf(focusRow);\n    this.focusColumnIndex = focusRow.focusColumnIndex;\n    this.setAttribute(\"tabIndex\", \"-1\");\n    this.isUpdatingFocus = false;\n  }\n  /**\n   * @internal\n   */\n\n\n  handleFocus(e) {\n    this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, true);\n  }\n  /**\n   * @internal\n   */\n\n\n  handleFocusOut(e) {\n    if (e.relatedTarget === null || !this.contains(e.relatedTarget)) {\n      this.setAttribute(\"tabIndex\", this.noTabbing ? \"-1\" : \"0\");\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  handleKeydown(e) {\n    if (e.defaultPrevented) {\n      return;\n    }\n\n    let newFocusRowIndex;\n    const maxIndex = this.rowElements.length - 1;\n    const currentGridBottom = this.offsetHeight + this.scrollTop;\n    const lastRow = this.rowElements[maxIndex];\n\n    switch (e.key) {\n      case keyArrowUp:\n        e.preventDefault(); // focus up one row\n\n        this.focusOnCell(this.focusRowIndex - 1, this.focusColumnIndex, true);\n        break;\n\n      case keyArrowDown:\n        e.preventDefault(); // focus down one row\n\n        this.focusOnCell(this.focusRowIndex + 1, this.focusColumnIndex, true);\n        break;\n\n      case keyPageUp:\n        e.preventDefault();\n\n        if (this.rowElements.length === 0) {\n          this.focusOnCell(0, 0, false);\n          break;\n        }\n\n        if (this.focusRowIndex === 0) {\n          this.focusOnCell(0, this.focusColumnIndex, false);\n          return;\n        }\n\n        newFocusRowIndex = this.focusRowIndex - 1;\n\n        for (newFocusRowIndex; newFocusRowIndex >= 0; newFocusRowIndex--) {\n          const thisRow = this.rowElements[newFocusRowIndex];\n\n          if (thisRow.offsetTop < this.scrollTop) {\n            this.scrollTop = thisRow.offsetTop + thisRow.clientHeight - this.clientHeight;\n            break;\n          }\n        }\n\n        this.focusOnCell(newFocusRowIndex, this.focusColumnIndex, false);\n        break;\n\n      case keyPageDown:\n        e.preventDefault();\n\n        if (this.rowElements.length === 0) {\n          this.focusOnCell(0, 0, false);\n          break;\n        } // focus down one \"page\"\n\n\n        if (this.focusRowIndex >= maxIndex || lastRow.offsetTop + lastRow.offsetHeight <= currentGridBottom) {\n          this.focusOnCell(maxIndex, this.focusColumnIndex, false);\n          return;\n        }\n\n        newFocusRowIndex = this.focusRowIndex + 1;\n\n        for (newFocusRowIndex; newFocusRowIndex <= maxIndex; newFocusRowIndex++) {\n          const thisRow = this.rowElements[newFocusRowIndex];\n\n          if (thisRow.offsetTop + thisRow.offsetHeight > currentGridBottom) {\n            let stickyHeaderOffset = 0;\n\n            if (this.generateHeader === GenerateHeaderOptions.sticky && this.generatedHeader !== null) {\n              stickyHeaderOffset = this.generatedHeader.clientHeight;\n            }\n\n            this.scrollTop = thisRow.offsetTop - stickyHeaderOffset;\n            break;\n          }\n        }\n\n        this.focusOnCell(newFocusRowIndex, this.focusColumnIndex, false);\n        break;\n\n      case keyHome:\n        if (e.ctrlKey) {\n          e.preventDefault(); // focus first cell of first row\n\n          this.focusOnCell(0, 0, true);\n        }\n\n        break;\n\n      case keyEnd:\n        if (e.ctrlKey && this.columnDefinitions !== null) {\n          e.preventDefault(); // focus last cell of last row\n\n          this.focusOnCell(this.rowElements.length - 1, this.columnDefinitions.length - 1, true);\n        }\n\n        break;\n    }\n  }\n\n  queueFocusUpdate() {\n    if (this.isUpdatingFocus && (this.contains(document.activeElement) || this === document.activeElement)) {\n      return;\n    }\n\n    if (this.pendingFocusUpdate === false) {\n      this.pendingFocusUpdate = true;\n      DOM.queueUpdate(() => this.updateFocus());\n    }\n  }\n\n  updateFocus() {\n    this.pendingFocusUpdate = false;\n    this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, true);\n  }\n\n  toggleGeneratedHeader() {\n    if (this.generatedHeader !== null) {\n      this.removeChild(this.generatedHeader);\n      this.generatedHeader = null;\n    }\n\n    if (this.generateHeader !== GenerateHeaderOptions.none && this.rowsData.length > 0) {\n      const generatedHeaderElement = document.createElement(this.rowElementTag);\n      this.generatedHeader = generatedHeaderElement;\n      this.generatedHeader.columnDefinitions = this.columnDefinitions;\n      this.generatedHeader.gridTemplateColumns = this.gridTemplateColumns;\n      this.generatedHeader.rowType = this.generateHeader === GenerateHeaderOptions.sticky ? DataGridRowTypes.stickyHeader : DataGridRowTypes.header;\n\n      if (this.firstChild !== null || this.rowsPlaceholder !== null) {\n        this.insertBefore(generatedHeaderElement, this.firstChild !== null ? this.firstChild : this.rowsPlaceholder);\n      }\n\n      return;\n    }\n  }\n\n}\n/**\n *  generates a basic column definition by examining sample row data\n */\n\nDataGrid.generateColumns = row => {\n  return Object.getOwnPropertyNames(row).map((property, index) => {\n    return {\n      columnDataKey: property,\n      gridColumn: `${index}`\n    };\n  });\n};\n\n__decorate([attr({\n  attribute: \"no-tabbing\",\n  mode: \"boolean\"\n})], DataGrid.prototype, \"noTabbing\", void 0);\n\n__decorate([attr({\n  attribute: \"generate-header\"\n})], DataGrid.prototype, \"generateHeader\", void 0);\n\n__decorate([attr({\n  attribute: \"grid-template-columns\"\n})], DataGrid.prototype, \"gridTemplateColumns\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"rowsData\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"columnDefinitions\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"rowItemTemplate\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"cellItemTemplate\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"headerCellItemTemplate\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"focusRowIndex\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"focusColumnIndex\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"defaultRowItemTemplate\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"rowElementTag\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"rowElements\", void 0);","map":{"version":3,"names":["__decorate","attr","DOM","observable","RepeatDirective","eventFocus","eventFocusOut","eventKeyDown","keyArrowDown","keyArrowUp","keyEnd","keyHome","keyPageDown","keyPageUp","FoundationElement","DataGridRowTypes","GenerateHeaderOptions","DataGrid","constructor","noTabbing","generateHeader","default","rowsData","columnDefinitions","focusRowIndex","focusColumnIndex","rowsPlaceholder","generatedHeader","isUpdatingFocus","pendingFocusUpdate","rowindexUpdateQueued","columnDefinitionsStale","generatedGridTemplateColumns","focusOnCell","rowIndex","columnIndex","scrollIntoView","rowElements","length","Math","max","min","focusRow","cells","querySelectorAll","focusTarget","scrollHeight","clientHeight","scrollTop","block","inline","focus","onChildListChange","mutations","observer","forEach","mutation","addedNodes","newNode","nodeType","getAttribute","queueRowIndexUpdate","queueUpdate","updateRowIndexes","newGridTemplateColumns","gridTemplateColumns","undefined","firstRow","Array","cellElements","fill","join","element","index","thisRow","generateTemplateColumns","templateColumns","column","noTabbingChanged","$fastController","isConnected","setAttribute","contains","document","activeElement","generateHeaderChanged","toggleGeneratedHeader","gridTemplateColumnsChanged","rowsDataChanged","generateColumns","columnDefinitionsChanged","headerCellItemTemplateChanged","headerCellItemTemplate","focusRowIndexChanged","queueFocusUpdate","focusColumnIndexChanged","connectedCallback","rowItemTemplate","defaultRowItemTemplate","createComment","appendChild","rowsRepeatBehavior","x","positioning","createBehavior","addBehaviors","addEventListener","handleRowFocus","handleFocus","handleKeydown","handleFocusOut","MutationObserver","observe","childList","disconnectedCallback","removeEventListener","disconnect","e","target","indexOf","relatedTarget","defaultPrevented","newFocusRowIndex","maxIndex","currentGridBottom","offsetHeight","lastRow","key","preventDefault","offsetTop","stickyHeaderOffset","sticky","ctrlKey","updateFocus","removeChild","none","generatedHeaderElement","createElement","rowElementTag","rowType","stickyHeader","header","firstChild","insertBefore","row","Object","getOwnPropertyNames","map","property","columnDataKey","gridColumn","attribute","mode","prototype"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { attr, DOM, observable, RepeatDirective, } from \"@microsoft/fast-element\";\nimport { eventFocus, eventFocusOut, eventKeyDown, keyArrowDown, keyArrowUp, keyEnd, keyHome, keyPageDown, keyPageUp, } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\nimport { DataGridRowTypes, GenerateHeaderOptions } from \"./data-grid.options.js\";\nexport { DataGridRowTypes, GenerateHeaderOptions };\n/**\n * A Data Grid Custom HTML Element.\n *\n * @slot - The default slot for custom row elements\n * @public\n */\nexport class DataGrid extends FoundationElement {\n    constructor() {\n        super();\n        /**\n         * When true the component will not add itself to the tab queue.\n         * Default is false.\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: no-tabbing\n         */\n        this.noTabbing = false;\n        /**\n         *  Whether the grid should automatically generate a header row and its type\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: generate-header\n         */\n        this.generateHeader = GenerateHeaderOptions.default;\n        /**\n         * The data being displayed in the grid\n         *\n         * @public\n         */\n        this.rowsData = [];\n        /**\n         * The column definitions of the grid\n         *\n         * @public\n         */\n        this.columnDefinitions = null;\n        /**\n         * The index of the row that will receive focus the next time the\n         * grid is focused. This value changes as focus moves to different\n         * rows within the grid.  Changing this value when focus is already\n         * within the grid moves focus to the specified row.\n         *\n         * @public\n         */\n        this.focusRowIndex = 0;\n        /**\n         * The index of the column that will receive focus the next time the\n         * grid is focused. This value changes as focus moves to different rows\n         * within the grid.  Changing this value when focus is already within\n         * the grid moves focus to the specified column.\n         *\n         * @public\n         */\n        this.focusColumnIndex = 0;\n        this.rowsPlaceholder = null;\n        this.generatedHeader = null;\n        this.isUpdatingFocus = false;\n        this.pendingFocusUpdate = false;\n        this.rowindexUpdateQueued = false;\n        this.columnDefinitionsStale = true;\n        this.generatedGridTemplateColumns = \"\";\n        this.focusOnCell = (rowIndex, columnIndex, scrollIntoView) => {\n            if (this.rowElements.length === 0) {\n                this.focusRowIndex = 0;\n                this.focusColumnIndex = 0;\n                return;\n            }\n            const focusRowIndex = Math.max(0, Math.min(this.rowElements.length - 1, rowIndex));\n            const focusRow = this.rowElements[focusRowIndex];\n            const cells = focusRow.querySelectorAll('[role=\"cell\"], [role=\"gridcell\"], [role=\"columnheader\"], [role=\"rowheader\"]');\n            const focusColumnIndex = Math.max(0, Math.min(cells.length - 1, columnIndex));\n            const focusTarget = cells[focusColumnIndex];\n            if (scrollIntoView &&\n                this.scrollHeight !== this.clientHeight &&\n                ((focusRowIndex < this.focusRowIndex && this.scrollTop > 0) ||\n                    (focusRowIndex > this.focusRowIndex &&\n                        this.scrollTop < this.scrollHeight - this.clientHeight))) {\n                focusTarget.scrollIntoView({ block: \"center\", inline: \"center\" });\n            }\n            focusTarget.focus();\n        };\n        this.onChildListChange = (mutations, \n        /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n        observer) => {\n            if (mutations && mutations.length) {\n                mutations.forEach((mutation) => {\n                    mutation.addedNodes.forEach((newNode) => {\n                        if (newNode.nodeType === 1 &&\n                            newNode.getAttribute(\"role\") === \"row\") {\n                            newNode.columnDefinitions = this.columnDefinitions;\n                        }\n                    });\n                });\n                this.queueRowIndexUpdate();\n            }\n        };\n        this.queueRowIndexUpdate = () => {\n            if (!this.rowindexUpdateQueued) {\n                this.rowindexUpdateQueued = true;\n                DOM.queueUpdate(this.updateRowIndexes);\n            }\n        };\n        this.updateRowIndexes = () => {\n            let newGridTemplateColumns = this.gridTemplateColumns;\n            if (newGridTemplateColumns === undefined) {\n                // try to generate columns based on manual rows\n                if (this.generatedGridTemplateColumns === \"\" && this.rowElements.length > 0) {\n                    const firstRow = this.rowElements[0];\n                    this.generatedGridTemplateColumns = new Array(firstRow.cellElements.length)\n                        .fill(\"1fr\")\n                        .join(\" \");\n                }\n                newGridTemplateColumns = this.generatedGridTemplateColumns;\n            }\n            this.rowElements.forEach((element, index) => {\n                const thisRow = element;\n                thisRow.rowIndex = index;\n                thisRow.gridTemplateColumns = newGridTemplateColumns;\n                if (this.columnDefinitionsStale) {\n                    thisRow.columnDefinitions = this.columnDefinitions;\n                }\n            });\n            this.rowindexUpdateQueued = false;\n            this.columnDefinitionsStale = false;\n        };\n    }\n    /**\n     *  generates a gridTemplateColumns based on columndata array\n     */\n    static generateTemplateColumns(columnDefinitions) {\n        let templateColumns = \"\";\n        columnDefinitions.forEach((column) => {\n            templateColumns = `${templateColumns}${templateColumns === \"\" ? \"\" : \" \"}${\"1fr\"}`;\n        });\n        return templateColumns;\n    }\n    noTabbingChanged() {\n        if (this.$fastController.isConnected) {\n            if (this.noTabbing) {\n                this.setAttribute(\"tabIndex\", \"-1\");\n            }\n            else {\n                this.setAttribute(\"tabIndex\", this.contains(document.activeElement) ||\n                    this === document.activeElement\n                    ? \"-1\"\n                    : \"0\");\n            }\n        }\n    }\n    generateHeaderChanged() {\n        if (this.$fastController.isConnected) {\n            this.toggleGeneratedHeader();\n        }\n    }\n    gridTemplateColumnsChanged() {\n        if (this.$fastController.isConnected) {\n            this.updateRowIndexes();\n        }\n    }\n    rowsDataChanged() {\n        if (this.columnDefinitions === null && this.rowsData.length > 0) {\n            this.columnDefinitions = DataGrid.generateColumns(this.rowsData[0]);\n        }\n        if (this.$fastController.isConnected) {\n            this.toggleGeneratedHeader();\n        }\n    }\n    columnDefinitionsChanged() {\n        if (this.columnDefinitions === null) {\n            this.generatedGridTemplateColumns = \"\";\n            return;\n        }\n        this.generatedGridTemplateColumns = DataGrid.generateTemplateColumns(this.columnDefinitions);\n        if (this.$fastController.isConnected) {\n            this.columnDefinitionsStale = true;\n            this.queueRowIndexUpdate();\n        }\n    }\n    headerCellItemTemplateChanged() {\n        if (this.$fastController.isConnected) {\n            if (this.generatedHeader !== null) {\n                this.generatedHeader.headerCellItemTemplate = this.headerCellItemTemplate;\n            }\n        }\n    }\n    focusRowIndexChanged() {\n        if (this.$fastController.isConnected) {\n            this.queueFocusUpdate();\n        }\n    }\n    focusColumnIndexChanged() {\n        if (this.$fastController.isConnected) {\n            this.queueFocusUpdate();\n        }\n    }\n    /**\n     * @internal\n     */\n    connectedCallback() {\n        super.connectedCallback();\n        if (this.rowItemTemplate === undefined) {\n            this.rowItemTemplate = this.defaultRowItemTemplate;\n        }\n        this.rowsPlaceholder = document.createComment(\"\");\n        this.appendChild(this.rowsPlaceholder);\n        this.toggleGeneratedHeader();\n        this.rowsRepeatBehavior = new RepeatDirective(x => x.rowsData, x => x.rowItemTemplate, { positioning: true }).createBehavior(this.rowsPlaceholder);\n        /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n        this.$fastController.addBehaviors([this.rowsRepeatBehavior]);\n        this.addEventListener(\"row-focused\", this.handleRowFocus);\n        this.addEventListener(eventFocus, this.handleFocus);\n        this.addEventListener(eventKeyDown, this.handleKeydown);\n        this.addEventListener(eventFocusOut, this.handleFocusOut);\n        this.observer = new MutationObserver(this.onChildListChange);\n        // only observe if nodes are added or removed\n        this.observer.observe(this, { childList: true });\n        if (this.noTabbing) {\n            this.setAttribute(\"tabindex\", \"-1\");\n        }\n        DOM.queueUpdate(this.queueRowIndexUpdate);\n    }\n    /**\n     * @internal\n     */\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.removeEventListener(\"row-focused\", this.handleRowFocus);\n        this.removeEventListener(eventFocus, this.handleFocus);\n        this.removeEventListener(eventKeyDown, this.handleKeydown);\n        this.removeEventListener(eventFocusOut, this.handleFocusOut);\n        // disconnect observer\n        this.observer.disconnect();\n        this.rowsPlaceholder = null;\n        this.generatedHeader = null;\n    }\n    /**\n     * @internal\n     */\n    handleRowFocus(e) {\n        this.isUpdatingFocus = true;\n        const focusRow = e.target;\n        this.focusRowIndex = this.rowElements.indexOf(focusRow);\n        this.focusColumnIndex = focusRow.focusColumnIndex;\n        this.setAttribute(\"tabIndex\", \"-1\");\n        this.isUpdatingFocus = false;\n    }\n    /**\n     * @internal\n     */\n    handleFocus(e) {\n        this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, true);\n    }\n    /**\n     * @internal\n     */\n    handleFocusOut(e) {\n        if (e.relatedTarget === null || !this.contains(e.relatedTarget)) {\n            this.setAttribute(\"tabIndex\", this.noTabbing ? \"-1\" : \"0\");\n        }\n    }\n    /**\n     * @internal\n     */\n    handleKeydown(e) {\n        if (e.defaultPrevented) {\n            return;\n        }\n        let newFocusRowIndex;\n        const maxIndex = this.rowElements.length - 1;\n        const currentGridBottom = this.offsetHeight + this.scrollTop;\n        const lastRow = this.rowElements[maxIndex];\n        switch (e.key) {\n            case keyArrowUp:\n                e.preventDefault();\n                // focus up one row\n                this.focusOnCell(this.focusRowIndex - 1, this.focusColumnIndex, true);\n                break;\n            case keyArrowDown:\n                e.preventDefault();\n                // focus down one row\n                this.focusOnCell(this.focusRowIndex + 1, this.focusColumnIndex, true);\n                break;\n            case keyPageUp:\n                e.preventDefault();\n                if (this.rowElements.length === 0) {\n                    this.focusOnCell(0, 0, false);\n                    break;\n                }\n                if (this.focusRowIndex === 0) {\n                    this.focusOnCell(0, this.focusColumnIndex, false);\n                    return;\n                }\n                newFocusRowIndex = this.focusRowIndex - 1;\n                for (newFocusRowIndex; newFocusRowIndex >= 0; newFocusRowIndex--) {\n                    const thisRow = this.rowElements[newFocusRowIndex];\n                    if (thisRow.offsetTop < this.scrollTop) {\n                        this.scrollTop =\n                            thisRow.offsetTop + thisRow.clientHeight - this.clientHeight;\n                        break;\n                    }\n                }\n                this.focusOnCell(newFocusRowIndex, this.focusColumnIndex, false);\n                break;\n            case keyPageDown:\n                e.preventDefault();\n                if (this.rowElements.length === 0) {\n                    this.focusOnCell(0, 0, false);\n                    break;\n                }\n                // focus down one \"page\"\n                if (this.focusRowIndex >= maxIndex ||\n                    lastRow.offsetTop + lastRow.offsetHeight <= currentGridBottom) {\n                    this.focusOnCell(maxIndex, this.focusColumnIndex, false);\n                    return;\n                }\n                newFocusRowIndex = this.focusRowIndex + 1;\n                for (newFocusRowIndex; newFocusRowIndex <= maxIndex; newFocusRowIndex++) {\n                    const thisRow = this.rowElements[newFocusRowIndex];\n                    if (thisRow.offsetTop + thisRow.offsetHeight > currentGridBottom) {\n                        let stickyHeaderOffset = 0;\n                        if (this.generateHeader === GenerateHeaderOptions.sticky &&\n                            this.generatedHeader !== null) {\n                            stickyHeaderOffset = this.generatedHeader.clientHeight;\n                        }\n                        this.scrollTop = thisRow.offsetTop - stickyHeaderOffset;\n                        break;\n                    }\n                }\n                this.focusOnCell(newFocusRowIndex, this.focusColumnIndex, false);\n                break;\n            case keyHome:\n                if (e.ctrlKey) {\n                    e.preventDefault();\n                    // focus first cell of first row\n                    this.focusOnCell(0, 0, true);\n                }\n                break;\n            case keyEnd:\n                if (e.ctrlKey && this.columnDefinitions !== null) {\n                    e.preventDefault();\n                    // focus last cell of last row\n                    this.focusOnCell(this.rowElements.length - 1, this.columnDefinitions.length - 1, true);\n                }\n                break;\n        }\n    }\n    queueFocusUpdate() {\n        if (this.isUpdatingFocus &&\n            (this.contains(document.activeElement) || this === document.activeElement)) {\n            return;\n        }\n        if (this.pendingFocusUpdate === false) {\n            this.pendingFocusUpdate = true;\n            DOM.queueUpdate(() => this.updateFocus());\n        }\n    }\n    updateFocus() {\n        this.pendingFocusUpdate = false;\n        this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, true);\n    }\n    toggleGeneratedHeader() {\n        if (this.generatedHeader !== null) {\n            this.removeChild(this.generatedHeader);\n            this.generatedHeader = null;\n        }\n        if (this.generateHeader !== GenerateHeaderOptions.none &&\n            this.rowsData.length > 0) {\n            const generatedHeaderElement = document.createElement(this.rowElementTag);\n            this.generatedHeader = generatedHeaderElement;\n            this.generatedHeader.columnDefinitions = this.columnDefinitions;\n            this.generatedHeader.gridTemplateColumns = this.gridTemplateColumns;\n            this.generatedHeader.rowType =\n                this.generateHeader === GenerateHeaderOptions.sticky\n                    ? DataGridRowTypes.stickyHeader\n                    : DataGridRowTypes.header;\n            if (this.firstChild !== null || this.rowsPlaceholder !== null) {\n                this.insertBefore(generatedHeaderElement, this.firstChild !== null ? this.firstChild : this.rowsPlaceholder);\n            }\n            return;\n        }\n    }\n}\n/**\n *  generates a basic column definition by examining sample row data\n */\nDataGrid.generateColumns = (row) => {\n    return Object.getOwnPropertyNames(row).map((property, index) => {\n        return {\n            columnDataKey: property,\n            gridColumn: `${index}`,\n        };\n    });\n};\n__decorate([\n    attr({ attribute: \"no-tabbing\", mode: \"boolean\" })\n], DataGrid.prototype, \"noTabbing\", void 0);\n__decorate([\n    attr({ attribute: \"generate-header\" })\n], DataGrid.prototype, \"generateHeader\", void 0);\n__decorate([\n    attr({ attribute: \"grid-template-columns\" })\n], DataGrid.prototype, \"gridTemplateColumns\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"rowsData\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"columnDefinitions\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"rowItemTemplate\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"cellItemTemplate\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"headerCellItemTemplate\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"focusRowIndex\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"focusColumnIndex\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"defaultRowItemTemplate\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"rowElementTag\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"rowElements\", void 0);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}