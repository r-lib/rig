{"ast":null,"code":"import _classCallCheck from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { $global } from \"@microsoft/fast-element\";\n/**\n *  A service to batch intersection event callbacks so multiple elements can share a single observer\n *\n * @public\n */\n\nexport var IntersectionService = function IntersectionService() {\n  var _this = this;\n\n  _classCallCheck(this, IntersectionService);\n\n  this.intersectionDetector = null;\n  this.observedElements = new Map();\n  /**\n   * Request the position of a target element\n   *\n   * @internal\n   */\n\n  this.requestPosition = function (target, callback) {\n    var _a;\n\n    if (_this.intersectionDetector === null) {\n      return;\n    }\n\n    if (_this.observedElements.has(target)) {\n      (_a = _this.observedElements.get(target)) === null || _a === void 0 ? void 0 : _a.push(callback);\n      return;\n    }\n\n    _this.observedElements.set(target, [callback]);\n\n    _this.intersectionDetector.observe(target);\n  };\n  /**\n   * Cancel a position request\n   *\n   * @internal\n   */\n\n\n  this.cancelRequestPosition = function (target, callback) {\n    var callbacks = _this.observedElements.get(target);\n\n    if (callbacks !== undefined) {\n      var callBackIndex = callbacks.indexOf(callback);\n\n      if (callBackIndex !== -1) {\n        callbacks.splice(callBackIndex, 1);\n      }\n    }\n  };\n  /**\n   * initialize intersection detector\n   */\n\n\n  this.initializeIntersectionDetector = function () {\n    if (!$global.IntersectionObserver) {\n      //intersection observer not supported\n      return;\n    }\n\n    _this.intersectionDetector = new IntersectionObserver(_this.handleIntersection, {\n      root: null,\n      rootMargin: \"0px\",\n      threshold: [0, 1]\n    });\n  };\n  /**\n   *  Handle intersections\n   */\n\n\n  this.handleIntersection = function (entries) {\n    if (_this.intersectionDetector === null) {\n      return;\n    }\n\n    var pendingCallbacks = [];\n    var pendingCallbackParams = []; // go through the entries to build a list of callbacks and params for each\n\n    entries.forEach(function (entry) {\n      var _a; // stop watching this element until we get new update requests for it\n\n\n      (_a = _this.intersectionDetector) === null || _a === void 0 ? void 0 : _a.unobserve(entry.target);\n\n      var thisElementCallbacks = _this.observedElements.get(entry.target);\n\n      if (thisElementCallbacks !== undefined) {\n        thisElementCallbacks.forEach(function (callback) {\n          var targetCallbackIndex = pendingCallbacks.indexOf(callback);\n\n          if (targetCallbackIndex === -1) {\n            targetCallbackIndex = pendingCallbacks.length;\n            pendingCallbacks.push(callback);\n            pendingCallbackParams.push([]);\n          }\n\n          pendingCallbackParams[targetCallbackIndex].push(entry);\n        });\n\n        _this.observedElements.delete(entry.target);\n      }\n    }); // execute callbacks\n\n    pendingCallbacks.forEach(function (callback, index) {\n      callback(pendingCallbackParams[index]);\n    });\n  };\n\n  this.initializeIntersectionDetector();\n};","map":{"version":3,"names":["$global","IntersectionService","intersectionDetector","observedElements","Map","requestPosition","target","callback","_a","has","get","push","set","observe","cancelRequestPosition","callbacks","undefined","callBackIndex","indexOf","splice","initializeIntersectionDetector","IntersectionObserver","handleIntersection","root","rootMargin","threshold","entries","pendingCallbacks","pendingCallbackParams","forEach","entry","unobserve","thisElementCallbacks","targetCallbackIndex","length","delete","index"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/utilities/intersection-service.js"],"sourcesContent":["import { $global } from \"@microsoft/fast-element\";\n/**\n *  A service to batch intersection event callbacks so multiple elements can share a single observer\n *\n * @public\n */\nexport class IntersectionService {\n    constructor() {\n        this.intersectionDetector = null;\n        this.observedElements = new Map();\n        /**\n         * Request the position of a target element\n         *\n         * @internal\n         */\n        this.requestPosition = (target, callback) => {\n            var _a;\n            if (this.intersectionDetector === null) {\n                return;\n            }\n            if (this.observedElements.has(target)) {\n                (_a = this.observedElements.get(target)) === null || _a === void 0 ? void 0 : _a.push(callback);\n                return;\n            }\n            this.observedElements.set(target, [callback]);\n            this.intersectionDetector.observe(target);\n        };\n        /**\n         * Cancel a position request\n         *\n         * @internal\n         */\n        this.cancelRequestPosition = (target, callback) => {\n            const callbacks = this.observedElements.get(target);\n            if (callbacks !== undefined) {\n                const callBackIndex = callbacks.indexOf(callback);\n                if (callBackIndex !== -1) {\n                    callbacks.splice(callBackIndex, 1);\n                }\n            }\n        };\n        /**\n         * initialize intersection detector\n         */\n        this.initializeIntersectionDetector = () => {\n            if (!$global.IntersectionObserver) {\n                //intersection observer not supported\n                return;\n            }\n            this.intersectionDetector = new IntersectionObserver(this.handleIntersection, {\n                root: null,\n                rootMargin: \"0px\",\n                threshold: [0, 1],\n            });\n        };\n        /**\n         *  Handle intersections\n         */\n        this.handleIntersection = (entries) => {\n            if (this.intersectionDetector === null) {\n                return;\n            }\n            const pendingCallbacks = [];\n            const pendingCallbackParams = [];\n            // go through the entries to build a list of callbacks and params for each\n            entries.forEach((entry) => {\n                var _a;\n                // stop watching this element until we get new update requests for it\n                (_a = this.intersectionDetector) === null || _a === void 0 ? void 0 : _a.unobserve(entry.target);\n                const thisElementCallbacks = this.observedElements.get(entry.target);\n                if (thisElementCallbacks !== undefined) {\n                    thisElementCallbacks.forEach((callback) => {\n                        let targetCallbackIndex = pendingCallbacks.indexOf(callback);\n                        if (targetCallbackIndex === -1) {\n                            targetCallbackIndex = pendingCallbacks.length;\n                            pendingCallbacks.push(callback);\n                            pendingCallbackParams.push([]);\n                        }\n                        pendingCallbackParams[targetCallbackIndex].push(entry);\n                    });\n                    this.observedElements.delete(entry.target);\n                }\n            });\n            // execute callbacks\n            pendingCallbacks.forEach((callback, index) => {\n                callback(pendingCallbackParams[index]);\n            });\n        };\n        this.initializeIntersectionDetector();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}