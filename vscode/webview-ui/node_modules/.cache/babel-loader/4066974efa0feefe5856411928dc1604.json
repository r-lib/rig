{"ast":null,"code":"import _classCallCheck from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { _interpolationEnd, _interpolationStart, DOM } from \"../dom.js\";\nimport { HTMLBindingDirective } from \"./binding.js\";\nvar sharedContext = null;\n\nvar CompilationContext = /*#__PURE__*/function () {\n  function CompilationContext() {\n    _classCallCheck(this, CompilationContext);\n  }\n\n  _createClass(CompilationContext, [{\n    key: \"addFactory\",\n    value: function addFactory(factory) {\n      factory.targetIndex = this.targetIndex;\n      this.behaviorFactories.push(factory);\n    }\n  }, {\n    key: \"captureContentBinding\",\n    value: function captureContentBinding(directive) {\n      directive.targetAtContent();\n      this.addFactory(directive);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.behaviorFactories = [];\n      this.targetIndex = -1;\n    }\n  }, {\n    key: \"release\",\n    value: function release() {\n      /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n      sharedContext = this;\n    }\n  }], [{\n    key: \"borrow\",\n    value: function borrow(directives) {\n      var shareable = sharedContext || new CompilationContext();\n      shareable.directives = directives;\n      shareable.reset();\n      sharedContext = null;\n      return shareable;\n    }\n  }]);\n\n  return CompilationContext;\n}();\n\nfunction createAggregateBinding(parts) {\n  if (parts.length === 1) {\n    return parts[0];\n  }\n\n  var targetName;\n  var partCount = parts.length;\n  var finalParts = parts.map(function (x) {\n    if (typeof x === \"string\") {\n      return function () {\n        return x;\n      };\n    }\n\n    targetName = x.targetName || targetName;\n    return x.binding;\n  });\n\n  var binding = function binding(scope, context) {\n    var output = \"\";\n\n    for (var i = 0; i < partCount; ++i) {\n      output += finalParts[i](scope, context);\n    }\n\n    return output;\n  };\n\n  var directive = new HTMLBindingDirective(binding);\n  directive.targetName = targetName;\n  return directive;\n}\n\nvar interpolationEndLength = _interpolationEnd.length;\n\nfunction parseContent(context, value) {\n  var valueParts = value.split(_interpolationStart);\n\n  if (valueParts.length === 1) {\n    return null;\n  }\n\n  var bindingParts = [];\n\n  for (var i = 0, ii = valueParts.length; i < ii; ++i) {\n    var current = valueParts[i];\n    var index = current.indexOf(_interpolationEnd);\n    var literal = void 0;\n\n    if (index === -1) {\n      literal = current;\n    } else {\n      var directiveIndex = parseInt(current.substring(0, index));\n      bindingParts.push(context.directives[directiveIndex]);\n      literal = current.substring(index + interpolationEndLength);\n    }\n\n    if (literal !== \"\") {\n      bindingParts.push(literal);\n    }\n  }\n\n  return bindingParts;\n}\n\nfunction compileAttributes(context, node) {\n  var includeBasicValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var attributes = node.attributes;\n\n  var _loop = function _loop(_i, _ii) {\n    var attr = attributes[_i];\n    var attrValue = attr.value;\n    var parseResult = parseContent(context, attrValue);\n    var result = null;\n\n    if (parseResult === null) {\n      if (includeBasicValues) {\n        result = new HTMLBindingDirective(function () {\n          return attrValue;\n        });\n        result.targetName = attr.name;\n      }\n    } else {\n      result = createAggregateBinding(parseResult);\n    }\n\n    if (result !== null) {\n      node.removeAttributeNode(attr);\n      _i--;\n      _ii--;\n      context.addFactory(result);\n    }\n\n    i = _i;\n    ii = _ii;\n  };\n\n  for (var i = 0, ii = attributes.length; i < ii; ++i) {\n    _loop(i, ii);\n  }\n}\n\nfunction compileContent(context, node, walker) {\n  var parseResult = parseContent(context, node.textContent);\n\n  if (parseResult !== null) {\n    var lastNode = node;\n\n    for (var _i2 = 0, _ii2 = parseResult.length; _i2 < _ii2; ++_i2) {\n      var currentPart = parseResult[_i2];\n      var currentNode = _i2 === 0 ? node : lastNode.parentNode.insertBefore(document.createTextNode(\"\"), lastNode.nextSibling);\n\n      if (typeof currentPart === \"string\") {\n        currentNode.textContent = currentPart;\n      } else {\n        currentNode.textContent = \" \";\n        context.captureContentBinding(currentPart);\n      }\n\n      lastNode = currentNode;\n      context.targetIndex++;\n\n      if (currentNode !== node) {\n        walker.nextNode();\n      }\n    }\n\n    context.targetIndex--;\n  }\n}\n/**\n * Compiles a template and associated directives into a raw compilation\n * result which include a cloneable DocumentFragment and factories capable\n * of attaching runtime behavior to nodes within the fragment.\n * @param template - The template to compile.\n * @param directives - The directives referenced by the template.\n * @remarks\n * The template that is provided for compilation is altered in-place\n * and cannot be compiled again. If the original template must be preserved,\n * it is recommended that you clone the original and pass the clone to this API.\n * @public\n */\n\n\nexport function compileTemplate(template, directives) {\n  var fragment = template.content; // https://bugs.chromium.org/p/chromium/issues/detail?id=1111864\n\n  document.adoptNode(fragment);\n  var context = CompilationContext.borrow(directives);\n  compileAttributes(context, template, true);\n  var hostBehaviorFactories = context.behaviorFactories;\n  context.reset();\n  var walker = DOM.createTemplateWalker(fragment);\n  var node;\n\n  while (node = walker.nextNode()) {\n    context.targetIndex++;\n\n    switch (node.nodeType) {\n      case 1:\n        // element node\n        compileAttributes(context, node);\n        break;\n\n      case 3:\n        // text node\n        compileContent(context, node, walker);\n        break;\n\n      case 8:\n        // comment\n        if (DOM.isMarker(node)) {\n          context.addFactory(directives[DOM.extractDirectiveIndexFromMarker(node)]);\n        }\n\n    }\n  }\n\n  var targetOffset = 0;\n\n  if ( // If the first node in a fragment is a marker, that means it's an unstable first node,\n  // because something like a when, repeat, etc. could add nodes before the marker.\n  // To mitigate this, we insert a stable first node. However, if we insert a node,\n  // that will alter the result of the TreeWalker. So, we also need to offset the target index.\n  DOM.isMarker(fragment.firstChild) || // Or if there is only one node and a directive, it means the template's content\n  // is *only* the directive. In that case, HTMLView.dispose() misses any nodes inserted by\n  // the directive. Inserting a new node ensures proper disposal of nodes added by the directive.\n  fragment.childNodes.length === 1 && directives.length) {\n    fragment.insertBefore(document.createComment(\"\"), fragment.firstChild);\n    targetOffset = -1;\n  }\n\n  var viewBehaviorFactories = context.behaviorFactories;\n  context.release();\n  return {\n    fragment: fragment,\n    viewBehaviorFactories: viewBehaviorFactories,\n    hostBehaviorFactories: hostBehaviorFactories,\n    targetOffset: targetOffset\n  };\n}","map":{"version":3,"names":["_interpolationEnd","_interpolationStart","DOM","HTMLBindingDirective","sharedContext","CompilationContext","factory","targetIndex","behaviorFactories","push","directive","targetAtContent","addFactory","directives","shareable","reset","createAggregateBinding","parts","length","targetName","partCount","finalParts","map","x","binding","scope","context","output","i","interpolationEndLength","parseContent","value","valueParts","split","bindingParts","ii","current","index","indexOf","literal","directiveIndex","parseInt","substring","compileAttributes","node","includeBasicValues","attributes","attr","attrValue","parseResult","result","name","removeAttributeNode","compileContent","walker","textContent","lastNode","currentPart","currentNode","parentNode","insertBefore","document","createTextNode","nextSibling","captureContentBinding","nextNode","compileTemplate","template","fragment","content","adoptNode","borrow","hostBehaviorFactories","createTemplateWalker","nodeType","isMarker","extractDirectiveIndexFromMarker","targetOffset","firstChild","childNodes","createComment","viewBehaviorFactories","release"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-element/dist/esm/templating/compiler.js"],"sourcesContent":["import { _interpolationEnd, _interpolationStart, DOM } from \"../dom.js\";\nimport { HTMLBindingDirective } from \"./binding.js\";\nlet sharedContext = null;\nclass CompilationContext {\n    addFactory(factory) {\n        factory.targetIndex = this.targetIndex;\n        this.behaviorFactories.push(factory);\n    }\n    captureContentBinding(directive) {\n        directive.targetAtContent();\n        this.addFactory(directive);\n    }\n    reset() {\n        this.behaviorFactories = [];\n        this.targetIndex = -1;\n    }\n    release() {\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n        sharedContext = this;\n    }\n    static borrow(directives) {\n        const shareable = sharedContext || new CompilationContext();\n        shareable.directives = directives;\n        shareable.reset();\n        sharedContext = null;\n        return shareable;\n    }\n}\nfunction createAggregateBinding(parts) {\n    if (parts.length === 1) {\n        return parts[0];\n    }\n    let targetName;\n    const partCount = parts.length;\n    const finalParts = parts.map((x) => {\n        if (typeof x === \"string\") {\n            return () => x;\n        }\n        targetName = x.targetName || targetName;\n        return x.binding;\n    });\n    const binding = (scope, context) => {\n        let output = \"\";\n        for (let i = 0; i < partCount; ++i) {\n            output += finalParts[i](scope, context);\n        }\n        return output;\n    };\n    const directive = new HTMLBindingDirective(binding);\n    directive.targetName = targetName;\n    return directive;\n}\nconst interpolationEndLength = _interpolationEnd.length;\nfunction parseContent(context, value) {\n    const valueParts = value.split(_interpolationStart);\n    if (valueParts.length === 1) {\n        return null;\n    }\n    const bindingParts = [];\n    for (let i = 0, ii = valueParts.length; i < ii; ++i) {\n        const current = valueParts[i];\n        const index = current.indexOf(_interpolationEnd);\n        let literal;\n        if (index === -1) {\n            literal = current;\n        }\n        else {\n            const directiveIndex = parseInt(current.substring(0, index));\n            bindingParts.push(context.directives[directiveIndex]);\n            literal = current.substring(index + interpolationEndLength);\n        }\n        if (literal !== \"\") {\n            bindingParts.push(literal);\n        }\n    }\n    return bindingParts;\n}\nfunction compileAttributes(context, node, includeBasicValues = false) {\n    const attributes = node.attributes;\n    for (let i = 0, ii = attributes.length; i < ii; ++i) {\n        const attr = attributes[i];\n        const attrValue = attr.value;\n        const parseResult = parseContent(context, attrValue);\n        let result = null;\n        if (parseResult === null) {\n            if (includeBasicValues) {\n                result = new HTMLBindingDirective(() => attrValue);\n                result.targetName = attr.name;\n            }\n        }\n        else {\n            result = createAggregateBinding(parseResult);\n        }\n        if (result !== null) {\n            node.removeAttributeNode(attr);\n            i--;\n            ii--;\n            context.addFactory(result);\n        }\n    }\n}\nfunction compileContent(context, node, walker) {\n    const parseResult = parseContent(context, node.textContent);\n    if (parseResult !== null) {\n        let lastNode = node;\n        for (let i = 0, ii = parseResult.length; i < ii; ++i) {\n            const currentPart = parseResult[i];\n            const currentNode = i === 0\n                ? node\n                : lastNode.parentNode.insertBefore(document.createTextNode(\"\"), lastNode.nextSibling);\n            if (typeof currentPart === \"string\") {\n                currentNode.textContent = currentPart;\n            }\n            else {\n                currentNode.textContent = \" \";\n                context.captureContentBinding(currentPart);\n            }\n            lastNode = currentNode;\n            context.targetIndex++;\n            if (currentNode !== node) {\n                walker.nextNode();\n            }\n        }\n        context.targetIndex--;\n    }\n}\n/**\n * Compiles a template and associated directives into a raw compilation\n * result which include a cloneable DocumentFragment and factories capable\n * of attaching runtime behavior to nodes within the fragment.\n * @param template - The template to compile.\n * @param directives - The directives referenced by the template.\n * @remarks\n * The template that is provided for compilation is altered in-place\n * and cannot be compiled again. If the original template must be preserved,\n * it is recommended that you clone the original and pass the clone to this API.\n * @public\n */\nexport function compileTemplate(template, directives) {\n    const fragment = template.content;\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1111864\n    document.adoptNode(fragment);\n    const context = CompilationContext.borrow(directives);\n    compileAttributes(context, template, true);\n    const hostBehaviorFactories = context.behaviorFactories;\n    context.reset();\n    const walker = DOM.createTemplateWalker(fragment);\n    let node;\n    while ((node = walker.nextNode())) {\n        context.targetIndex++;\n        switch (node.nodeType) {\n            case 1: // element node\n                compileAttributes(context, node);\n                break;\n            case 3: // text node\n                compileContent(context, node, walker);\n                break;\n            case 8: // comment\n                if (DOM.isMarker(node)) {\n                    context.addFactory(directives[DOM.extractDirectiveIndexFromMarker(node)]);\n                }\n        }\n    }\n    let targetOffset = 0;\n    if (\n    // If the first node in a fragment is a marker, that means it's an unstable first node,\n    // because something like a when, repeat, etc. could add nodes before the marker.\n    // To mitigate this, we insert a stable first node. However, if we insert a node,\n    // that will alter the result of the TreeWalker. So, we also need to offset the target index.\n    DOM.isMarker(fragment.firstChild) ||\n        // Or if there is only one node and a directive, it means the template's content\n        // is *only* the directive. In that case, HTMLView.dispose() misses any nodes inserted by\n        // the directive. Inserting a new node ensures proper disposal of nodes added by the directive.\n        (fragment.childNodes.length === 1 && directives.length)) {\n        fragment.insertBefore(document.createComment(\"\"), fragment.firstChild);\n        targetOffset = -1;\n    }\n    const viewBehaviorFactories = context.behaviorFactories;\n    context.release();\n    return {\n        fragment,\n        viewBehaviorFactories,\n        hostBehaviorFactories,\n        targetOffset,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}