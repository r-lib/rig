{"ast":null,"code":"import _classCallCheck from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __decorate } from \"tslib\";\nimport { attr, DOM, observable } from \"@microsoft/fast-element\";\nimport { Direction, eventResize, eventScroll } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\nimport { getDirection } from \"../utilities/direction.js\";\nimport { IntersectionService } from \"../utilities/intersection-service.js\";\n/**\n * An anchored region Custom HTML Element.\n *\n * @slot - The default slot for the content\n * @fires loaded - Fires a custom 'loaded' event when the region is loaded and visible\n * @fires positionchange - Fires a custom 'positionchange' event when the position has changed\n *\n * @public\n */\n\nexport var AnchoredRegion = /*#__PURE__*/function (_FoundationElement) {\n  _inherits(AnchoredRegion, _FoundationElement);\n\n  var _super = _createSuper(AnchoredRegion);\n\n  function AnchoredRegion() {\n    var _this;\n\n    _classCallCheck(this, AnchoredRegion);\n\n    _this = _super.apply(this, arguments);\n    /**\n     * The HTML ID of the anchor element this region is positioned relative to\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: anchor\n     */\n\n    _this.anchor = \"\";\n    /**\n     * The HTML ID of the viewport element this region is positioned relative to\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: anchor\n     */\n\n    _this.viewport = \"\";\n    /**\n     * Sets what logic the component uses to determine horizontal placement.\n     * 'locktodefault' forces the default position\n     * 'dynamic' decides placement based on available space\n     * 'uncontrolled' does not control placement on the horizontal axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-positioning-mode\n     */\n\n    _this.horizontalPositioningMode = \"uncontrolled\";\n    /**\n     * The default horizontal position of the region relative to the anchor element\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-default-position\n     */\n\n    _this.horizontalDefaultPosition = \"unset\";\n    /**\n     * Whether the region remains in the viewport (ie. detaches from the anchor) on the horizontal axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-viewport-lock\n     */\n\n    _this.horizontalViewportLock = false;\n    /**\n     * Whether the region overlaps the anchor on the horizontal axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-inset\n     */\n\n    _this.horizontalInset = false;\n    /**\n     * Defines how the width of the region is calculated\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-scaling\n     */\n\n    _this.horizontalScaling = \"content\";\n    /**\n     * Sets what logic the component uses to determine vertical placement.\n     * 'locktodefault' forces the default position\n     * 'dynamic' decides placement based on available space\n     * 'uncontrolled' does not control placement on the vertical axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-positioning-mode\n     */\n\n    _this.verticalPositioningMode = \"uncontrolled\";\n    /**\n     * The default vertical position of the region relative to the anchor element\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-default-position\n     */\n\n    _this.verticalDefaultPosition = \"unset\";\n    /**\n     * Whether the region remains in the viewport (ie. detaches from the anchor) on the vertical axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-viewport-lock\n     */\n\n    _this.verticalViewportLock = false;\n    /**\n     * Whether the region overlaps the anchor on the vertical axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-inset\n     */\n\n    _this.verticalInset = false;\n    /**\n     * Defines how the height of the region is calculated\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-scaling\n     */\n\n    _this.verticalScaling = \"content\";\n    /**\n     * Whether the region is positioned using css \"position: fixed\".\n     * Otherwise the region uses \"position: absolute\".\n     * Fixed placement allows the region to break out of parent containers,\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: fixed-placement\n     */\n\n    _this.fixedPlacement = false;\n    /**\n     * Defines what triggers the anchored region to revaluate positioning\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: auto-update-mode\n     */\n\n    _this.autoUpdateMode = \"anchor\";\n    /**\n     * The HTML element being used as the anchor\n     *\n     * @public\n     */\n\n    _this.anchorElement = null;\n    /**\n     * The HTML element being used as the viewport\n     *\n     * @public\n     */\n\n    _this.viewportElement = null;\n    /**\n     * indicates that an initial positioning pass on layout has completed\n     *\n     * @internal\n     */\n\n    _this.initialLayoutComplete = false;\n    _this.resizeDetector = null;\n    /**\n     * base offsets between the positioner's base position and the anchor's\n     */\n\n    _this.baseHorizontalOffset = 0;\n    _this.baseVerticalOffset = 0;\n    _this.pendingPositioningUpdate = false;\n    _this.pendingReset = false;\n    _this.currentDirection = Direction.ltr;\n    _this.regionVisible = false; // indicates that a layout update should occur even if geometry has not changed\n    // used to ensure some attribute changes are applied\n\n    _this.forceUpdate = false; // defines how big a difference in pixels there must be between states to\n    // justify a layout update that affects the dom (prevents repeated sub-pixel corrections)\n\n    _this.updateThreshold = 0.5;\n    /**\n     * update position\n     */\n\n    _this.update = function () {\n      if (!_this.pendingPositioningUpdate) {\n        _this.requestPositionUpdates();\n      }\n    };\n    /**\n     * starts observers\n     */\n\n\n    _this.startObservers = function () {\n      _this.stopObservers();\n\n      if (_this.anchorElement === null) {\n        return;\n      }\n\n      _this.requestPositionUpdates();\n\n      if (_this.resizeDetector !== null) {\n        _this.resizeDetector.observe(_this.anchorElement);\n\n        _this.resizeDetector.observe(_assertThisInitialized(_this));\n      }\n    };\n    /**\n     * get position updates\n     */\n\n\n    _this.requestPositionUpdates = function () {\n      if (_this.anchorElement === null || _this.pendingPositioningUpdate) {\n        return;\n      }\n\n      AnchoredRegion.intersectionService.requestPosition(_assertThisInitialized(_this), _this.handleIntersection);\n      AnchoredRegion.intersectionService.requestPosition(_this.anchorElement, _this.handleIntersection);\n\n      if (_this.viewportElement !== null) {\n        AnchoredRegion.intersectionService.requestPosition(_this.viewportElement, _this.handleIntersection);\n      }\n\n      _this.pendingPositioningUpdate = true;\n    };\n    /**\n     * stops observers\n     */\n\n\n    _this.stopObservers = function () {\n      if (_this.pendingPositioningUpdate) {\n        _this.pendingPositioningUpdate = false;\n        AnchoredRegion.intersectionService.cancelRequestPosition(_assertThisInitialized(_this), _this.handleIntersection);\n\n        if (_this.anchorElement !== null) {\n          AnchoredRegion.intersectionService.cancelRequestPosition(_this.anchorElement, _this.handleIntersection);\n        }\n\n        if (_this.viewportElement !== null) {\n          AnchoredRegion.intersectionService.cancelRequestPosition(_this.viewportElement, _this.handleIntersection);\n        }\n      }\n\n      if (_this.resizeDetector !== null) {\n        _this.resizeDetector.disconnect();\n      }\n    };\n    /**\n     * Gets the viewport element by id, or defaults to document root\n     */\n\n\n    _this.getViewport = function () {\n      if (typeof _this.viewport !== \"string\" || _this.viewport === \"\") {\n        return document.documentElement;\n      }\n\n      return document.getElementById(_this.viewport);\n    };\n    /**\n     *  Gets the anchor element by id\n     */\n\n\n    _this.getAnchor = function () {\n      return document.getElementById(_this.anchor);\n    };\n    /**\n     *  Handle intersections\n     */\n\n\n    _this.handleIntersection = function (entries) {\n      if (!_this.pendingPositioningUpdate) {\n        return;\n      }\n\n      _this.pendingPositioningUpdate = false;\n\n      if (!_this.applyIntersectionEntries(entries)) {\n        return;\n      }\n\n      _this.updateLayout();\n    };\n    /**\n     *  iterate through intersection entries and apply data\n     */\n\n\n    _this.applyIntersectionEntries = function (entries) {\n      var regionEntry = entries.find(function (x) {\n        return x.target === _assertThisInitialized(_this);\n      });\n      var anchorEntry = entries.find(function (x) {\n        return x.target === _this.anchorElement;\n      });\n      var viewportEntry = entries.find(function (x) {\n        return x.target === _this.viewportElement;\n      });\n\n      if (regionEntry === undefined || viewportEntry === undefined || anchorEntry === undefined) {\n        return false;\n      } // don't update the dom unless there is a significant difference in rect positions\n\n\n      if (!_this.regionVisible || _this.forceUpdate || _this.regionRect === undefined || _this.anchorRect === undefined || _this.viewportRect === undefined || _this.isRectDifferent(_this.anchorRect, anchorEntry.boundingClientRect) || _this.isRectDifferent(_this.viewportRect, viewportEntry.boundingClientRect) || _this.isRectDifferent(_this.regionRect, regionEntry.boundingClientRect)) {\n        _this.regionRect = regionEntry.boundingClientRect;\n        _this.anchorRect = anchorEntry.boundingClientRect;\n\n        if (_this.viewportElement === document.documentElement) {\n          _this.viewportRect = new DOMRectReadOnly(viewportEntry.boundingClientRect.x + document.documentElement.scrollLeft, viewportEntry.boundingClientRect.y + document.documentElement.scrollTop, viewportEntry.boundingClientRect.width, viewportEntry.boundingClientRect.height);\n        } else {\n          _this.viewportRect = viewportEntry.boundingClientRect;\n        }\n\n        _this.updateRegionOffset();\n\n        _this.forceUpdate = false;\n        return true;\n      }\n\n      return false;\n    };\n    /**\n     *  Update the offset values\n     */\n\n\n    _this.updateRegionOffset = function () {\n      if (_this.anchorRect && _this.regionRect) {\n        _this.baseHorizontalOffset = _this.baseHorizontalOffset + (_this.anchorRect.left - _this.regionRect.left) + (_this.translateX - _this.baseHorizontalOffset);\n        _this.baseVerticalOffset = _this.baseVerticalOffset + (_this.anchorRect.top - _this.regionRect.top) + (_this.translateY - _this.baseVerticalOffset);\n      }\n    };\n    /**\n     *  compare rects to see if there is enough change to justify a DOM update\n     */\n\n\n    _this.isRectDifferent = function (rectA, rectB) {\n      if (Math.abs(rectA.top - rectB.top) > _this.updateThreshold || Math.abs(rectA.right - rectB.right) > _this.updateThreshold || Math.abs(rectA.bottom - rectB.bottom) > _this.updateThreshold || Math.abs(rectA.left - rectB.left) > _this.updateThreshold) {\n        return true;\n      }\n\n      return false;\n    };\n    /**\n     *  Handle resize events\n     */\n\n\n    _this.handleResize = function (entries) {\n      _this.update();\n    };\n    /**\n     * resets the component\n     */\n\n\n    _this.reset = function () {\n      if (!_this.pendingReset) {\n        return;\n      }\n\n      _this.pendingReset = false;\n\n      if (_this.anchorElement === null) {\n        _this.anchorElement = _this.getAnchor();\n      }\n\n      if (_this.viewportElement === null) {\n        _this.viewportElement = _this.getViewport();\n      }\n\n      _this.currentDirection = getDirection(_assertThisInitialized(_this));\n\n      _this.startObservers();\n    };\n    /**\n     *  Recalculate layout related state values\n     */\n\n\n    _this.updateLayout = function () {\n      var desiredVerticalPosition = undefined;\n      var desiredHorizontalPosition = undefined;\n\n      if (_this.horizontalPositioningMode !== \"uncontrolled\") {\n        var horizontalOptions = _this.getPositioningOptions(_this.horizontalInset);\n\n        if (_this.horizontalDefaultPosition === \"center\") {\n          desiredHorizontalPosition = \"center\";\n        } else if (_this.horizontalDefaultPosition !== \"unset\") {\n          var dirCorrectedHorizontalDefaultPosition = _this.horizontalDefaultPosition;\n\n          if (dirCorrectedHorizontalDefaultPosition === \"start\" || dirCorrectedHorizontalDefaultPosition === \"end\") {\n            // if direction changes we reset the layout\n            var newDirection = getDirection(_assertThisInitialized(_this));\n\n            if (newDirection !== _this.currentDirection) {\n              _this.currentDirection = newDirection;\n\n              _this.initialize();\n\n              return;\n            }\n\n            if (_this.currentDirection === Direction.ltr) {\n              dirCorrectedHorizontalDefaultPosition = dirCorrectedHorizontalDefaultPosition === \"start\" ? \"left\" : \"right\";\n            } else {\n              dirCorrectedHorizontalDefaultPosition = dirCorrectedHorizontalDefaultPosition === \"start\" ? \"right\" : \"left\";\n            }\n          }\n\n          switch (dirCorrectedHorizontalDefaultPosition) {\n            case \"left\":\n              desiredHorizontalPosition = _this.horizontalInset ? \"insetStart\" : \"start\";\n              break;\n\n            case \"right\":\n              desiredHorizontalPosition = _this.horizontalInset ? \"insetEnd\" : \"end\";\n              break;\n          }\n        }\n\n        var horizontalThreshold = _this.horizontalThreshold !== undefined ? _this.horizontalThreshold : _this.regionRect !== undefined ? _this.regionRect.width : 0;\n        var anchorLeft = _this.anchorRect !== undefined ? _this.anchorRect.left : 0;\n        var anchorRight = _this.anchorRect !== undefined ? _this.anchorRect.right : 0;\n        var anchorWidth = _this.anchorRect !== undefined ? _this.anchorRect.width : 0;\n        var viewportLeft = _this.viewportRect !== undefined ? _this.viewportRect.left : 0;\n        var viewportRight = _this.viewportRect !== undefined ? _this.viewportRect.right : 0;\n\n        if (desiredHorizontalPosition === undefined || !(_this.horizontalPositioningMode === \"locktodefault\") && _this.getAvailableSpace(desiredHorizontalPosition, anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) < horizontalThreshold) {\n          desiredHorizontalPosition = _this.getAvailableSpace(horizontalOptions[0], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) > _this.getAvailableSpace(horizontalOptions[1], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) ? horizontalOptions[0] : horizontalOptions[1];\n        }\n      }\n\n      if (_this.verticalPositioningMode !== \"uncontrolled\") {\n        var verticalOptions = _this.getPositioningOptions(_this.verticalInset);\n\n        if (_this.verticalDefaultPosition === \"center\") {\n          desiredVerticalPosition = \"center\";\n        } else if (_this.verticalDefaultPosition !== \"unset\") {\n          switch (_this.verticalDefaultPosition) {\n            case \"top\":\n              desiredVerticalPosition = _this.verticalInset ? \"insetStart\" : \"start\";\n              break;\n\n            case \"bottom\":\n              desiredVerticalPosition = _this.verticalInset ? \"insetEnd\" : \"end\";\n              break;\n          }\n        }\n\n        var verticalThreshold = _this.verticalThreshold !== undefined ? _this.verticalThreshold : _this.regionRect !== undefined ? _this.regionRect.height : 0;\n        var anchorTop = _this.anchorRect !== undefined ? _this.anchorRect.top : 0;\n        var anchorBottom = _this.anchorRect !== undefined ? _this.anchorRect.bottom : 0;\n        var anchorHeight = _this.anchorRect !== undefined ? _this.anchorRect.height : 0;\n        var viewportTop = _this.viewportRect !== undefined ? _this.viewportRect.top : 0;\n        var viewportBottom = _this.viewportRect !== undefined ? _this.viewportRect.bottom : 0;\n\n        if (desiredVerticalPosition === undefined || !(_this.verticalPositioningMode === \"locktodefault\") && _this.getAvailableSpace(desiredVerticalPosition, anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) < verticalThreshold) {\n          desiredVerticalPosition = _this.getAvailableSpace(verticalOptions[0], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) > _this.getAvailableSpace(verticalOptions[1], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) ? verticalOptions[0] : verticalOptions[1];\n        }\n      }\n\n      var nextPositionerDimension = _this.getNextRegionDimension(desiredHorizontalPosition, desiredVerticalPosition);\n\n      var positionChanged = _this.horizontalPosition !== desiredHorizontalPosition || _this.verticalPosition !== desiredVerticalPosition;\n\n      _this.setHorizontalPosition(desiredHorizontalPosition, nextPositionerDimension);\n\n      _this.setVerticalPosition(desiredVerticalPosition, nextPositionerDimension);\n\n      _this.updateRegionStyle();\n\n      if (!_this.initialLayoutComplete) {\n        _this.initialLayoutComplete = true;\n\n        _this.requestPositionUpdates();\n\n        return;\n      }\n\n      if (!_this.regionVisible) {\n        _this.regionVisible = true;\n\n        _this.style.removeProperty(\"pointer-events\");\n\n        _this.style.removeProperty(\"opacity\");\n\n        _this.classList.toggle(\"loaded\", true);\n\n        _this.$emit(\"loaded\", _assertThisInitialized(_this), {\n          bubbles: false\n        });\n      }\n\n      _this.updatePositionClasses();\n\n      if (positionChanged) {\n        // emit change event\n        _this.$emit(\"positionchange\", _assertThisInitialized(_this), {\n          bubbles: false\n        });\n      }\n    };\n    /**\n     *  Updates the style string applied to the region element as well as the css classes attached\n     *  to the root element\n     */\n\n\n    _this.updateRegionStyle = function () {\n      _this.style.width = _this.regionWidth;\n      _this.style.height = _this.regionHeight;\n      _this.style.transform = \"translate(\".concat(_this.translateX, \"px, \").concat(_this.translateY, \"px)\");\n    };\n    /**\n     *  Updates the css classes that reflect the current position of the element\n     */\n\n\n    _this.updatePositionClasses = function () {\n      _this.classList.toggle(\"top\", _this.verticalPosition === \"start\");\n\n      _this.classList.toggle(\"bottom\", _this.verticalPosition === \"end\");\n\n      _this.classList.toggle(\"inset-top\", _this.verticalPosition === \"insetStart\");\n\n      _this.classList.toggle(\"inset-bottom\", _this.verticalPosition === \"insetEnd\");\n\n      _this.classList.toggle(\"vertical-center\", _this.verticalPosition === \"center\");\n\n      _this.classList.toggle(\"left\", _this.horizontalPosition === \"start\");\n\n      _this.classList.toggle(\"right\", _this.horizontalPosition === \"end\");\n\n      _this.classList.toggle(\"inset-left\", _this.horizontalPosition === \"insetStart\");\n\n      _this.classList.toggle(\"inset-right\", _this.horizontalPosition === \"insetEnd\");\n\n      _this.classList.toggle(\"horizontal-center\", _this.horizontalPosition === \"center\");\n    };\n    /**\n     * Get horizontal positioning state based on desired position\n     */\n\n\n    _this.setHorizontalPosition = function (desiredHorizontalPosition, nextPositionerDimension) {\n      if (desiredHorizontalPosition === undefined || _this.regionRect === undefined || _this.anchorRect === undefined || _this.viewportRect === undefined) {\n        return;\n      }\n\n      var nextRegionWidth = 0;\n\n      switch (_this.horizontalScaling) {\n        case \"anchor\":\n        case \"fill\":\n          nextRegionWidth = _this.horizontalViewportLock ? _this.viewportRect.width : nextPositionerDimension.width;\n          _this.regionWidth = \"\".concat(nextRegionWidth, \"px\");\n          break;\n\n        case \"content\":\n          nextRegionWidth = _this.regionRect.width;\n          _this.regionWidth = \"unset\";\n          break;\n      }\n\n      var sizeDelta = 0;\n\n      switch (desiredHorizontalPosition) {\n        case \"start\":\n          _this.translateX = _this.baseHorizontalOffset - nextRegionWidth;\n\n          if (_this.horizontalViewportLock && _this.anchorRect.left > _this.viewportRect.right) {\n            _this.translateX = _this.translateX - (_this.anchorRect.left - _this.viewportRect.right);\n          }\n\n          break;\n\n        case \"insetStart\":\n          _this.translateX = _this.baseHorizontalOffset - nextRegionWidth + _this.anchorRect.width;\n\n          if (_this.horizontalViewportLock && _this.anchorRect.right > _this.viewportRect.right) {\n            _this.translateX = _this.translateX - (_this.anchorRect.right - _this.viewportRect.right);\n          }\n\n          break;\n\n        case \"insetEnd\":\n          _this.translateX = _this.baseHorizontalOffset;\n\n          if (_this.horizontalViewportLock && _this.anchorRect.left < _this.viewportRect.left) {\n            _this.translateX = _this.translateX - (_this.anchorRect.left - _this.viewportRect.left);\n          }\n\n          break;\n\n        case \"end\":\n          _this.translateX = _this.baseHorizontalOffset + _this.anchorRect.width;\n\n          if (_this.horizontalViewportLock && _this.anchorRect.right < _this.viewportRect.left) {\n            _this.translateX = _this.translateX - (_this.anchorRect.right - _this.viewportRect.left);\n          }\n\n          break;\n\n        case \"center\":\n          sizeDelta = (_this.anchorRect.width - nextRegionWidth) / 2;\n          _this.translateX = _this.baseHorizontalOffset + sizeDelta;\n\n          if (_this.horizontalViewportLock) {\n            var regionLeft = _this.anchorRect.left + sizeDelta;\n            var regionRight = _this.anchorRect.right - sizeDelta;\n\n            if (regionLeft < _this.viewportRect.left && !(regionRight > _this.viewportRect.right)) {\n              _this.translateX = _this.translateX - (regionLeft - _this.viewportRect.left);\n            } else if (regionRight > _this.viewportRect.right && !(regionLeft < _this.viewportRect.left)) {\n              _this.translateX = _this.translateX - (regionRight - _this.viewportRect.right);\n            }\n          }\n\n          break;\n      }\n\n      _this.horizontalPosition = desiredHorizontalPosition;\n    };\n    /**\n     * Set vertical positioning state based on desired position\n     */\n\n\n    _this.setVerticalPosition = function (desiredVerticalPosition, nextPositionerDimension) {\n      if (desiredVerticalPosition === undefined || _this.regionRect === undefined || _this.anchorRect === undefined || _this.viewportRect === undefined) {\n        return;\n      }\n\n      var nextRegionHeight = 0;\n\n      switch (_this.verticalScaling) {\n        case \"anchor\":\n        case \"fill\":\n          nextRegionHeight = _this.verticalViewportLock ? _this.viewportRect.height : nextPositionerDimension.height;\n          _this.regionHeight = \"\".concat(nextRegionHeight, \"px\");\n          break;\n\n        case \"content\":\n          nextRegionHeight = _this.regionRect.height;\n          _this.regionHeight = \"unset\";\n          break;\n      }\n\n      var sizeDelta = 0;\n\n      switch (desiredVerticalPosition) {\n        case \"start\":\n          _this.translateY = _this.baseVerticalOffset - nextRegionHeight;\n\n          if (_this.verticalViewportLock && _this.anchorRect.top > _this.viewportRect.bottom) {\n            _this.translateY = _this.translateY - (_this.anchorRect.top - _this.viewportRect.bottom);\n          }\n\n          break;\n\n        case \"insetStart\":\n          _this.translateY = _this.baseVerticalOffset - nextRegionHeight + _this.anchorRect.height;\n\n          if (_this.verticalViewportLock && _this.anchorRect.bottom > _this.viewportRect.bottom) {\n            _this.translateY = _this.translateY - (_this.anchorRect.bottom - _this.viewportRect.bottom);\n          }\n\n          break;\n\n        case \"insetEnd\":\n          _this.translateY = _this.baseVerticalOffset;\n\n          if (_this.verticalViewportLock && _this.anchorRect.top < _this.viewportRect.top) {\n            _this.translateY = _this.translateY - (_this.anchorRect.top - _this.viewportRect.top);\n          }\n\n          break;\n\n        case \"end\":\n          _this.translateY = _this.baseVerticalOffset + _this.anchorRect.height;\n\n          if (_this.verticalViewportLock && _this.anchorRect.bottom < _this.viewportRect.top) {\n            _this.translateY = _this.translateY - (_this.anchorRect.bottom - _this.viewportRect.top);\n          }\n\n          break;\n\n        case \"center\":\n          sizeDelta = (_this.anchorRect.height - nextRegionHeight) / 2;\n          _this.translateY = _this.baseVerticalOffset + sizeDelta;\n\n          if (_this.verticalViewportLock) {\n            var regionTop = _this.anchorRect.top + sizeDelta;\n            var regionBottom = _this.anchorRect.bottom - sizeDelta;\n\n            if (regionTop < _this.viewportRect.top && !(regionBottom > _this.viewportRect.bottom)) {\n              _this.translateY = _this.translateY - (regionTop - _this.viewportRect.top);\n            } else if (regionBottom > _this.viewportRect.bottom && !(regionTop < _this.viewportRect.top)) {\n              _this.translateY = _this.translateY - (regionBottom - _this.viewportRect.bottom);\n            }\n          }\n\n      }\n\n      _this.verticalPosition = desiredVerticalPosition;\n    };\n    /**\n     *  Get available positions based on positioning mode\n     */\n\n\n    _this.getPositioningOptions = function (inset) {\n      if (inset) {\n        return [\"insetStart\", \"insetEnd\"];\n      }\n\n      return [\"start\", \"end\"];\n    };\n    /**\n     *  Get the space available for a particular relative position\n     */\n\n\n    _this.getAvailableSpace = function (positionOption, anchorStart, anchorEnd, anchorSpan, viewportStart, viewportEnd) {\n      var spaceStart = anchorStart - viewportStart;\n      var spaceEnd = viewportEnd - (anchorStart + anchorSpan);\n\n      switch (positionOption) {\n        case \"start\":\n          return spaceStart;\n\n        case \"insetStart\":\n          return spaceStart + anchorSpan;\n\n        case \"insetEnd\":\n          return spaceEnd + anchorSpan;\n\n        case \"end\":\n          return spaceEnd;\n\n        case \"center\":\n          return Math.min(spaceStart, spaceEnd) * 2 + anchorSpan;\n      }\n    };\n    /**\n     * Get region dimensions\n     */\n\n\n    _this.getNextRegionDimension = function (desiredHorizontalPosition, desiredVerticalPosition) {\n      var newRegionDimension = {\n        height: _this.regionRect !== undefined ? _this.regionRect.height : 0,\n        width: _this.regionRect !== undefined ? _this.regionRect.width : 0\n      };\n\n      if (desiredHorizontalPosition !== undefined && _this.horizontalScaling === \"fill\") {\n        newRegionDimension.width = _this.getAvailableSpace(desiredHorizontalPosition, _this.anchorRect !== undefined ? _this.anchorRect.left : 0, _this.anchorRect !== undefined ? _this.anchorRect.right : 0, _this.anchorRect !== undefined ? _this.anchorRect.width : 0, _this.viewportRect !== undefined ? _this.viewportRect.left : 0, _this.viewportRect !== undefined ? _this.viewportRect.right : 0);\n      } else if (_this.horizontalScaling === \"anchor\") {\n        newRegionDimension.width = _this.anchorRect !== undefined ? _this.anchorRect.width : 0;\n      }\n\n      if (desiredVerticalPosition !== undefined && _this.verticalScaling === \"fill\") {\n        newRegionDimension.height = _this.getAvailableSpace(desiredVerticalPosition, _this.anchorRect !== undefined ? _this.anchorRect.top : 0, _this.anchorRect !== undefined ? _this.anchorRect.bottom : 0, _this.anchorRect !== undefined ? _this.anchorRect.height : 0, _this.viewportRect !== undefined ? _this.viewportRect.top : 0, _this.viewportRect !== undefined ? _this.viewportRect.bottom : 0);\n      } else if (_this.verticalScaling === \"anchor\") {\n        newRegionDimension.height = _this.anchorRect !== undefined ? _this.anchorRect.height : 0;\n      }\n\n      return newRegionDimension;\n    };\n    /**\n     * starts event listeners that can trigger auto updating\n     */\n\n\n    _this.startAutoUpdateEventListeners = function () {\n      window.addEventListener(eventResize, _this.update, {\n        passive: true\n      });\n      window.addEventListener(eventScroll, _this.update, {\n        passive: true,\n        capture: true\n      });\n\n      if (_this.resizeDetector !== null && _this.viewportElement !== null) {\n        _this.resizeDetector.observe(_this.viewportElement);\n      }\n    };\n    /**\n     * stops event listeners that can trigger auto updating\n     */\n\n\n    _this.stopAutoUpdateEventListeners = function () {\n      window.removeEventListener(eventResize, _this.update);\n      window.removeEventListener(eventScroll, _this.update);\n\n      if (_this.resizeDetector !== null && _this.viewportElement !== null) {\n        _this.resizeDetector.unobserve(_this.viewportElement);\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(AnchoredRegion, [{\n    key: \"anchorChanged\",\n    value: function anchorChanged() {\n      if (this.initialLayoutComplete) {\n        this.anchorElement = this.getAnchor();\n      }\n    }\n  }, {\n    key: \"viewportChanged\",\n    value: function viewportChanged() {\n      if (this.initialLayoutComplete) {\n        this.viewportElement = this.getViewport();\n      }\n    }\n  }, {\n    key: \"horizontalPositioningModeChanged\",\n    value: function horizontalPositioningModeChanged() {\n      this.requestReset();\n    }\n  }, {\n    key: \"horizontalDefaultPositionChanged\",\n    value: function horizontalDefaultPositionChanged() {\n      this.updateForAttributeChange();\n    }\n  }, {\n    key: \"horizontalViewportLockChanged\",\n    value: function horizontalViewportLockChanged() {\n      this.updateForAttributeChange();\n    }\n  }, {\n    key: \"horizontalInsetChanged\",\n    value: function horizontalInsetChanged() {\n      this.updateForAttributeChange();\n    }\n  }, {\n    key: \"horizontalThresholdChanged\",\n    value: function horizontalThresholdChanged() {\n      this.updateForAttributeChange();\n    }\n  }, {\n    key: \"horizontalScalingChanged\",\n    value: function horizontalScalingChanged() {\n      this.updateForAttributeChange();\n    }\n  }, {\n    key: \"verticalPositioningModeChanged\",\n    value: function verticalPositioningModeChanged() {\n      this.requestReset();\n    }\n  }, {\n    key: \"verticalDefaultPositionChanged\",\n    value: function verticalDefaultPositionChanged() {\n      this.updateForAttributeChange();\n    }\n  }, {\n    key: \"verticalViewportLockChanged\",\n    value: function verticalViewportLockChanged() {\n      this.updateForAttributeChange();\n    }\n  }, {\n    key: \"verticalInsetChanged\",\n    value: function verticalInsetChanged() {\n      this.updateForAttributeChange();\n    }\n  }, {\n    key: \"verticalThresholdChanged\",\n    value: function verticalThresholdChanged() {\n      this.updateForAttributeChange();\n    }\n  }, {\n    key: \"verticalScalingChanged\",\n    value: function verticalScalingChanged() {\n      this.updateForAttributeChange();\n    }\n  }, {\n    key: \"fixedPlacementChanged\",\n    value: function fixedPlacementChanged() {\n      if (this.$fastController.isConnected && this.initialLayoutComplete) {\n        this.initialize();\n      }\n    }\n  }, {\n    key: \"autoUpdateModeChanged\",\n    value: function autoUpdateModeChanged(prevMode, newMode) {\n      if (this.$fastController.isConnected && this.initialLayoutComplete) {\n        if (prevMode === \"auto\") {\n          this.stopAutoUpdateEventListeners();\n        }\n\n        if (newMode === \"auto\") {\n          this.startAutoUpdateEventListeners();\n        }\n      }\n    }\n  }, {\n    key: \"anchorElementChanged\",\n    value: function anchorElementChanged() {\n      this.requestReset();\n    }\n  }, {\n    key: \"viewportElementChanged\",\n    value: function viewportElementChanged() {\n      if (this.$fastController.isConnected && this.initialLayoutComplete) {\n        this.initialize();\n      }\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(AnchoredRegion.prototype), \"connectedCallback\", this).call(this);\n\n      if (this.autoUpdateMode === \"auto\") {\n        this.startAutoUpdateEventListeners();\n      }\n\n      this.initialize();\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      _get(_getPrototypeOf(AnchoredRegion.prototype), \"disconnectedCallback\", this).call(this);\n\n      if (this.autoUpdateMode === \"auto\") {\n        this.stopAutoUpdateEventListeners();\n      }\n\n      this.stopObservers();\n      this.disconnectResizeDetector();\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"adoptedCallback\",\n    value: function adoptedCallback() {\n      this.initialize();\n    }\n    /**\n     * destroys the instance's resize observer\n     */\n\n  }, {\n    key: \"disconnectResizeDetector\",\n    value: function disconnectResizeDetector() {\n      if (this.resizeDetector !== null) {\n        this.resizeDetector.disconnect();\n        this.resizeDetector = null;\n      }\n    }\n    /**\n     * initializes the instance's resize observer\n     */\n\n  }, {\n    key: \"initializeResizeDetector\",\n    value: function initializeResizeDetector() {\n      this.disconnectResizeDetector();\n      this.resizeDetector = new window.ResizeObserver(this.handleResize);\n    }\n    /**\n     * react to attribute changes that don't require a reset\n     */\n\n  }, {\n    key: \"updateForAttributeChange\",\n    value: function updateForAttributeChange() {\n      if (this.$fastController.isConnected && this.initialLayoutComplete) {\n        this.forceUpdate = true;\n        this.update();\n      }\n    }\n    /**\n     * fully initializes the component\n     */\n\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      this.initializeResizeDetector();\n\n      if (this.anchorElement === null) {\n        this.anchorElement = this.getAnchor();\n      }\n\n      this.requestReset();\n    }\n    /**\n     * Request a reset if there are currently no open requests\n     */\n\n  }, {\n    key: \"requestReset\",\n    value: function requestReset() {\n      var _this2 = this;\n\n      if (this.$fastController.isConnected && this.pendingReset === false) {\n        this.setInitialState();\n        DOM.queueUpdate(function () {\n          return _this2.reset();\n        });\n        this.pendingReset = true;\n      }\n    }\n    /**\n     * sets the starting configuration for component internal values\n     */\n\n  }, {\n    key: \"setInitialState\",\n    value: function setInitialState() {\n      this.initialLayoutComplete = false;\n      this.regionVisible = false;\n      this.translateX = 0;\n      this.translateY = 0;\n      this.baseHorizontalOffset = 0;\n      this.baseVerticalOffset = 0;\n      this.viewportRect = undefined;\n      this.regionRect = undefined;\n      this.anchorRect = undefined;\n      this.verticalPosition = undefined;\n      this.horizontalPosition = undefined;\n      this.style.opacity = \"0\";\n      this.style.pointerEvents = \"none\";\n      this.forceUpdate = false;\n      this.style.position = this.fixedPlacement ? \"fixed\" : \"absolute\";\n      this.updatePositionClasses();\n      this.updateRegionStyle();\n    }\n  }]);\n\n  return AnchoredRegion;\n}(FoundationElement);\nAnchoredRegion.intersectionService = new IntersectionService();\n\n__decorate([attr], AnchoredRegion.prototype, \"anchor\", void 0);\n\n__decorate([attr], AnchoredRegion.prototype, \"viewport\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-positioning-mode\"\n})], AnchoredRegion.prototype, \"horizontalPositioningMode\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-default-position\"\n})], AnchoredRegion.prototype, \"horizontalDefaultPosition\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-viewport-lock\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"horizontalViewportLock\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-inset\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"horizontalInset\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-threshold\"\n})], AnchoredRegion.prototype, \"horizontalThreshold\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-scaling\"\n})], AnchoredRegion.prototype, \"horizontalScaling\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-positioning-mode\"\n})], AnchoredRegion.prototype, \"verticalPositioningMode\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-default-position\"\n})], AnchoredRegion.prototype, \"verticalDefaultPosition\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-viewport-lock\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"verticalViewportLock\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-inset\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"verticalInset\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-threshold\"\n})], AnchoredRegion.prototype, \"verticalThreshold\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-scaling\"\n})], AnchoredRegion.prototype, \"verticalScaling\", void 0);\n\n__decorate([attr({\n  attribute: \"fixed-placement\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"fixedPlacement\", void 0);\n\n__decorate([attr({\n  attribute: \"auto-update-mode\"\n})], AnchoredRegion.prototype, \"autoUpdateMode\", void 0);\n\n__decorate([observable], AnchoredRegion.prototype, \"anchorElement\", void 0);\n\n__decorate([observable], AnchoredRegion.prototype, \"viewportElement\", void 0);\n\n__decorate([observable], AnchoredRegion.prototype, \"initialLayoutComplete\", void 0);","map":{"version":3,"names":["__decorate","attr","DOM","observable","Direction","eventResize","eventScroll","FoundationElement","getDirection","IntersectionService","AnchoredRegion","arguments","anchor","viewport","horizontalPositioningMode","horizontalDefaultPosition","horizontalViewportLock","horizontalInset","horizontalScaling","verticalPositioningMode","verticalDefaultPosition","verticalViewportLock","verticalInset","verticalScaling","fixedPlacement","autoUpdateMode","anchorElement","viewportElement","initialLayoutComplete","resizeDetector","baseHorizontalOffset","baseVerticalOffset","pendingPositioningUpdate","pendingReset","currentDirection","ltr","regionVisible","forceUpdate","updateThreshold","update","requestPositionUpdates","startObservers","stopObservers","observe","intersectionService","requestPosition","handleIntersection","cancelRequestPosition","disconnect","getViewport","document","documentElement","getElementById","getAnchor","entries","applyIntersectionEntries","updateLayout","regionEntry","find","x","target","anchorEntry","viewportEntry","undefined","regionRect","anchorRect","viewportRect","isRectDifferent","boundingClientRect","DOMRectReadOnly","scrollLeft","y","scrollTop","width","height","updateRegionOffset","left","translateX","top","translateY","rectA","rectB","Math","abs","right","bottom","handleResize","reset","desiredVerticalPosition","desiredHorizontalPosition","horizontalOptions","getPositioningOptions","dirCorrectedHorizontalDefaultPosition","newDirection","initialize","horizontalThreshold","anchorLeft","anchorRight","anchorWidth","viewportLeft","viewportRight","getAvailableSpace","verticalOptions","verticalThreshold","anchorTop","anchorBottom","anchorHeight","viewportTop","viewportBottom","nextPositionerDimension","getNextRegionDimension","positionChanged","horizontalPosition","verticalPosition","setHorizontalPosition","setVerticalPosition","updateRegionStyle","style","removeProperty","classList","toggle","$emit","bubbles","updatePositionClasses","regionWidth","regionHeight","transform","nextRegionWidth","sizeDelta","regionLeft","regionRight","nextRegionHeight","regionTop","regionBottom","inset","positionOption","anchorStart","anchorEnd","anchorSpan","viewportStart","viewportEnd","spaceStart","spaceEnd","min","newRegionDimension","startAutoUpdateEventListeners","window","addEventListener","passive","capture","stopAutoUpdateEventListeners","removeEventListener","unobserve","requestReset","updateForAttributeChange","$fastController","isConnected","prevMode","newMode","disconnectResizeDetector","ResizeObserver","initializeResizeDetector","setInitialState","queueUpdate","opacity","pointerEvents","position","prototype","attribute","mode"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { attr, DOM, observable } from \"@microsoft/fast-element\";\nimport { Direction, eventResize, eventScroll } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\nimport { getDirection } from \"../utilities/direction.js\";\nimport { IntersectionService } from \"../utilities/intersection-service.js\";\n/**\n * An anchored region Custom HTML Element.\n *\n * @slot - The default slot for the content\n * @fires loaded - Fires a custom 'loaded' event when the region is loaded and visible\n * @fires positionchange - Fires a custom 'positionchange' event when the position has changed\n *\n * @public\n */\nexport class AnchoredRegion extends FoundationElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * The HTML ID of the anchor element this region is positioned relative to\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: anchor\n         */\n        this.anchor = \"\";\n        /**\n         * The HTML ID of the viewport element this region is positioned relative to\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: anchor\n         */\n        this.viewport = \"\";\n        /**\n         * Sets what logic the component uses to determine horizontal placement.\n         * 'locktodefault' forces the default position\n         * 'dynamic' decides placement based on available space\n         * 'uncontrolled' does not control placement on the horizontal axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-positioning-mode\n         */\n        this.horizontalPositioningMode = \"uncontrolled\";\n        /**\n         * The default horizontal position of the region relative to the anchor element\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-default-position\n         */\n        this.horizontalDefaultPosition = \"unset\";\n        /**\n         * Whether the region remains in the viewport (ie. detaches from the anchor) on the horizontal axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-viewport-lock\n         */\n        this.horizontalViewportLock = false;\n        /**\n         * Whether the region overlaps the anchor on the horizontal axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-inset\n         */\n        this.horizontalInset = false;\n        /**\n         * Defines how the width of the region is calculated\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-scaling\n         */\n        this.horizontalScaling = \"content\";\n        /**\n         * Sets what logic the component uses to determine vertical placement.\n         * 'locktodefault' forces the default position\n         * 'dynamic' decides placement based on available space\n         * 'uncontrolled' does not control placement on the vertical axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-positioning-mode\n         */\n        this.verticalPositioningMode = \"uncontrolled\";\n        /**\n         * The default vertical position of the region relative to the anchor element\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-default-position\n         */\n        this.verticalDefaultPosition = \"unset\";\n        /**\n         * Whether the region remains in the viewport (ie. detaches from the anchor) on the vertical axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-viewport-lock\n         */\n        this.verticalViewportLock = false;\n        /**\n         * Whether the region overlaps the anchor on the vertical axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-inset\n         */\n        this.verticalInset = false;\n        /**\n         * Defines how the height of the region is calculated\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-scaling\n         */\n        this.verticalScaling = \"content\";\n        /**\n         * Whether the region is positioned using css \"position: fixed\".\n         * Otherwise the region uses \"position: absolute\".\n         * Fixed placement allows the region to break out of parent containers,\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: fixed-placement\n         */\n        this.fixedPlacement = false;\n        /**\n         * Defines what triggers the anchored region to revaluate positioning\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: auto-update-mode\n         */\n        this.autoUpdateMode = \"anchor\";\n        /**\n         * The HTML element being used as the anchor\n         *\n         * @public\n         */\n        this.anchorElement = null;\n        /**\n         * The HTML element being used as the viewport\n         *\n         * @public\n         */\n        this.viewportElement = null;\n        /**\n         * indicates that an initial positioning pass on layout has completed\n         *\n         * @internal\n         */\n        this.initialLayoutComplete = false;\n        this.resizeDetector = null;\n        /**\n         * base offsets between the positioner's base position and the anchor's\n         */\n        this.baseHorizontalOffset = 0;\n        this.baseVerticalOffset = 0;\n        this.pendingPositioningUpdate = false;\n        this.pendingReset = false;\n        this.currentDirection = Direction.ltr;\n        this.regionVisible = false;\n        // indicates that a layout update should occur even if geometry has not changed\n        // used to ensure some attribute changes are applied\n        this.forceUpdate = false;\n        // defines how big a difference in pixels there must be between states to\n        // justify a layout update that affects the dom (prevents repeated sub-pixel corrections)\n        this.updateThreshold = 0.5;\n        /**\n         * update position\n         */\n        this.update = () => {\n            if (!this.pendingPositioningUpdate) {\n                this.requestPositionUpdates();\n            }\n        };\n        /**\n         * starts observers\n         */\n        this.startObservers = () => {\n            this.stopObservers();\n            if (this.anchorElement === null) {\n                return;\n            }\n            this.requestPositionUpdates();\n            if (this.resizeDetector !== null) {\n                this.resizeDetector.observe(this.anchorElement);\n                this.resizeDetector.observe(this);\n            }\n        };\n        /**\n         * get position updates\n         */\n        this.requestPositionUpdates = () => {\n            if (this.anchorElement === null || this.pendingPositioningUpdate) {\n                return;\n            }\n            AnchoredRegion.intersectionService.requestPosition(this, this.handleIntersection);\n            AnchoredRegion.intersectionService.requestPosition(this.anchorElement, this.handleIntersection);\n            if (this.viewportElement !== null) {\n                AnchoredRegion.intersectionService.requestPosition(this.viewportElement, this.handleIntersection);\n            }\n            this.pendingPositioningUpdate = true;\n        };\n        /**\n         * stops observers\n         */\n        this.stopObservers = () => {\n            if (this.pendingPositioningUpdate) {\n                this.pendingPositioningUpdate = false;\n                AnchoredRegion.intersectionService.cancelRequestPosition(this, this.handleIntersection);\n                if (this.anchorElement !== null) {\n                    AnchoredRegion.intersectionService.cancelRequestPosition(this.anchorElement, this.handleIntersection);\n                }\n                if (this.viewportElement !== null) {\n                    AnchoredRegion.intersectionService.cancelRequestPosition(this.viewportElement, this.handleIntersection);\n                }\n            }\n            if (this.resizeDetector !== null) {\n                this.resizeDetector.disconnect();\n            }\n        };\n        /**\n         * Gets the viewport element by id, or defaults to document root\n         */\n        this.getViewport = () => {\n            if (typeof this.viewport !== \"string\" || this.viewport === \"\") {\n                return document.documentElement;\n            }\n            return document.getElementById(this.viewport);\n        };\n        /**\n         *  Gets the anchor element by id\n         */\n        this.getAnchor = () => {\n            return document.getElementById(this.anchor);\n        };\n        /**\n         *  Handle intersections\n         */\n        this.handleIntersection = (entries) => {\n            if (!this.pendingPositioningUpdate) {\n                return;\n            }\n            this.pendingPositioningUpdate = false;\n            if (!this.applyIntersectionEntries(entries)) {\n                return;\n            }\n            this.updateLayout();\n        };\n        /**\n         *  iterate through intersection entries and apply data\n         */\n        this.applyIntersectionEntries = (entries) => {\n            const regionEntry = entries.find(x => x.target === this);\n            const anchorEntry = entries.find(x => x.target === this.anchorElement);\n            const viewportEntry = entries.find(x => x.target === this.viewportElement);\n            if (regionEntry === undefined ||\n                viewportEntry === undefined ||\n                anchorEntry === undefined) {\n                return false;\n            }\n            // don't update the dom unless there is a significant difference in rect positions\n            if (!this.regionVisible ||\n                this.forceUpdate ||\n                this.regionRect === undefined ||\n                this.anchorRect === undefined ||\n                this.viewportRect === undefined ||\n                this.isRectDifferent(this.anchorRect, anchorEntry.boundingClientRect) ||\n                this.isRectDifferent(this.viewportRect, viewportEntry.boundingClientRect) ||\n                this.isRectDifferent(this.regionRect, regionEntry.boundingClientRect)) {\n                this.regionRect = regionEntry.boundingClientRect;\n                this.anchorRect = anchorEntry.boundingClientRect;\n                if (this.viewportElement === document.documentElement) {\n                    this.viewportRect = new DOMRectReadOnly(viewportEntry.boundingClientRect.x +\n                        document.documentElement.scrollLeft, viewportEntry.boundingClientRect.y +\n                        document.documentElement.scrollTop, viewportEntry.boundingClientRect.width, viewportEntry.boundingClientRect.height);\n                }\n                else {\n                    this.viewportRect = viewportEntry.boundingClientRect;\n                }\n                this.updateRegionOffset();\n                this.forceUpdate = false;\n                return true;\n            }\n            return false;\n        };\n        /**\n         *  Update the offset values\n         */\n        this.updateRegionOffset = () => {\n            if (this.anchorRect && this.regionRect) {\n                this.baseHorizontalOffset =\n                    this.baseHorizontalOffset +\n                        (this.anchorRect.left - this.regionRect.left) +\n                        (this.translateX - this.baseHorizontalOffset);\n                this.baseVerticalOffset =\n                    this.baseVerticalOffset +\n                        (this.anchorRect.top - this.regionRect.top) +\n                        (this.translateY - this.baseVerticalOffset);\n            }\n        };\n        /**\n         *  compare rects to see if there is enough change to justify a DOM update\n         */\n        this.isRectDifferent = (rectA, rectB) => {\n            if (Math.abs(rectA.top - rectB.top) > this.updateThreshold ||\n                Math.abs(rectA.right - rectB.right) > this.updateThreshold ||\n                Math.abs(rectA.bottom - rectB.bottom) > this.updateThreshold ||\n                Math.abs(rectA.left - rectB.left) > this.updateThreshold) {\n                return true;\n            }\n            return false;\n        };\n        /**\n         *  Handle resize events\n         */\n        this.handleResize = (entries) => {\n            this.update();\n        };\n        /**\n         * resets the component\n         */\n        this.reset = () => {\n            if (!this.pendingReset) {\n                return;\n            }\n            this.pendingReset = false;\n            if (this.anchorElement === null) {\n                this.anchorElement = this.getAnchor();\n            }\n            if (this.viewportElement === null) {\n                this.viewportElement = this.getViewport();\n            }\n            this.currentDirection = getDirection(this);\n            this.startObservers();\n        };\n        /**\n         *  Recalculate layout related state values\n         */\n        this.updateLayout = () => {\n            let desiredVerticalPosition = undefined;\n            let desiredHorizontalPosition = undefined;\n            if (this.horizontalPositioningMode !== \"uncontrolled\") {\n                const horizontalOptions = this.getPositioningOptions(this.horizontalInset);\n                if (this.horizontalDefaultPosition === \"center\") {\n                    desiredHorizontalPosition = \"center\";\n                }\n                else if (this.horizontalDefaultPosition !== \"unset\") {\n                    let dirCorrectedHorizontalDefaultPosition = this\n                        .horizontalDefaultPosition;\n                    if (dirCorrectedHorizontalDefaultPosition === \"start\" ||\n                        dirCorrectedHorizontalDefaultPosition === \"end\") {\n                        // if direction changes we reset the layout\n                        const newDirection = getDirection(this);\n                        if (newDirection !== this.currentDirection) {\n                            this.currentDirection = newDirection;\n                            this.initialize();\n                            return;\n                        }\n                        if (this.currentDirection === Direction.ltr) {\n                            dirCorrectedHorizontalDefaultPosition =\n                                dirCorrectedHorizontalDefaultPosition === \"start\"\n                                    ? \"left\"\n                                    : \"right\";\n                        }\n                        else {\n                            dirCorrectedHorizontalDefaultPosition =\n                                dirCorrectedHorizontalDefaultPosition === \"start\"\n                                    ? \"right\"\n                                    : \"left\";\n                        }\n                    }\n                    switch (dirCorrectedHorizontalDefaultPosition) {\n                        case \"left\":\n                            desiredHorizontalPosition = this.horizontalInset\n                                ? \"insetStart\"\n                                : \"start\";\n                            break;\n                        case \"right\":\n                            desiredHorizontalPosition = this.horizontalInset\n                                ? \"insetEnd\"\n                                : \"end\";\n                            break;\n                    }\n                }\n                const horizontalThreshold = this.horizontalThreshold !== undefined\n                    ? this.horizontalThreshold\n                    : this.regionRect !== undefined\n                        ? this.regionRect.width\n                        : 0;\n                const anchorLeft = this.anchorRect !== undefined ? this.anchorRect.left : 0;\n                const anchorRight = this.anchorRect !== undefined ? this.anchorRect.right : 0;\n                const anchorWidth = this.anchorRect !== undefined ? this.anchorRect.width : 0;\n                const viewportLeft = this.viewportRect !== undefined ? this.viewportRect.left : 0;\n                const viewportRight = this.viewportRect !== undefined ? this.viewportRect.right : 0;\n                if (desiredHorizontalPosition === undefined ||\n                    (!(this.horizontalPositioningMode === \"locktodefault\") &&\n                        this.getAvailableSpace(desiredHorizontalPosition, anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) < horizontalThreshold)) {\n                    desiredHorizontalPosition =\n                        this.getAvailableSpace(horizontalOptions[0], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) >\n                            this.getAvailableSpace(horizontalOptions[1], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight)\n                            ? horizontalOptions[0]\n                            : horizontalOptions[1];\n                }\n            }\n            if (this.verticalPositioningMode !== \"uncontrolled\") {\n                const verticalOptions = this.getPositioningOptions(this.verticalInset);\n                if (this.verticalDefaultPosition === \"center\") {\n                    desiredVerticalPosition = \"center\";\n                }\n                else if (this.verticalDefaultPosition !== \"unset\") {\n                    switch (this.verticalDefaultPosition) {\n                        case \"top\":\n                            desiredVerticalPosition = this.verticalInset\n                                ? \"insetStart\"\n                                : \"start\";\n                            break;\n                        case \"bottom\":\n                            desiredVerticalPosition = this.verticalInset ? \"insetEnd\" : \"end\";\n                            break;\n                    }\n                }\n                const verticalThreshold = this.verticalThreshold !== undefined\n                    ? this.verticalThreshold\n                    : this.regionRect !== undefined\n                        ? this.regionRect.height\n                        : 0;\n                const anchorTop = this.anchorRect !== undefined ? this.anchorRect.top : 0;\n                const anchorBottom = this.anchorRect !== undefined ? this.anchorRect.bottom : 0;\n                const anchorHeight = this.anchorRect !== undefined ? this.anchorRect.height : 0;\n                const viewportTop = this.viewportRect !== undefined ? this.viewportRect.top : 0;\n                const viewportBottom = this.viewportRect !== undefined ? this.viewportRect.bottom : 0;\n                if (desiredVerticalPosition === undefined ||\n                    (!(this.verticalPositioningMode === \"locktodefault\") &&\n                        this.getAvailableSpace(desiredVerticalPosition, anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) < verticalThreshold)) {\n                    desiredVerticalPosition =\n                        this.getAvailableSpace(verticalOptions[0], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) >\n                            this.getAvailableSpace(verticalOptions[1], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom)\n                            ? verticalOptions[0]\n                            : verticalOptions[1];\n                }\n            }\n            const nextPositionerDimension = this.getNextRegionDimension(desiredHorizontalPosition, desiredVerticalPosition);\n            const positionChanged = this.horizontalPosition !== desiredHorizontalPosition ||\n                this.verticalPosition !== desiredVerticalPosition;\n            this.setHorizontalPosition(desiredHorizontalPosition, nextPositionerDimension);\n            this.setVerticalPosition(desiredVerticalPosition, nextPositionerDimension);\n            this.updateRegionStyle();\n            if (!this.initialLayoutComplete) {\n                this.initialLayoutComplete = true;\n                this.requestPositionUpdates();\n                return;\n            }\n            if (!this.regionVisible) {\n                this.regionVisible = true;\n                this.style.removeProperty(\"pointer-events\");\n                this.style.removeProperty(\"opacity\");\n                this.classList.toggle(\"loaded\", true);\n                this.$emit(\"loaded\", this, { bubbles: false });\n            }\n            this.updatePositionClasses();\n            if (positionChanged) {\n                // emit change event\n                this.$emit(\"positionchange\", this, { bubbles: false });\n            }\n        };\n        /**\n         *  Updates the style string applied to the region element as well as the css classes attached\n         *  to the root element\n         */\n        this.updateRegionStyle = () => {\n            this.style.width = this.regionWidth;\n            this.style.height = this.regionHeight;\n            this.style.transform = `translate(${this.translateX}px, ${this.translateY}px)`;\n        };\n        /**\n         *  Updates the css classes that reflect the current position of the element\n         */\n        this.updatePositionClasses = () => {\n            this.classList.toggle(\"top\", this.verticalPosition === \"start\");\n            this.classList.toggle(\"bottom\", this.verticalPosition === \"end\");\n            this.classList.toggle(\"inset-top\", this.verticalPosition === \"insetStart\");\n            this.classList.toggle(\"inset-bottom\", this.verticalPosition === \"insetEnd\");\n            this.classList.toggle(\"vertical-center\", this.verticalPosition === \"center\");\n            this.classList.toggle(\"left\", this.horizontalPosition === \"start\");\n            this.classList.toggle(\"right\", this.horizontalPosition === \"end\");\n            this.classList.toggle(\"inset-left\", this.horizontalPosition === \"insetStart\");\n            this.classList.toggle(\"inset-right\", this.horizontalPosition === \"insetEnd\");\n            this.classList.toggle(\"horizontal-center\", this.horizontalPosition === \"center\");\n        };\n        /**\n         * Get horizontal positioning state based on desired position\n         */\n        this.setHorizontalPosition = (desiredHorizontalPosition, nextPositionerDimension) => {\n            if (desiredHorizontalPosition === undefined ||\n                this.regionRect === undefined ||\n                this.anchorRect === undefined ||\n                this.viewportRect === undefined) {\n                return;\n            }\n            let nextRegionWidth = 0;\n            switch (this.horizontalScaling) {\n                case \"anchor\":\n                case \"fill\":\n                    nextRegionWidth = this.horizontalViewportLock\n                        ? this.viewportRect.width\n                        : nextPositionerDimension.width;\n                    this.regionWidth = `${nextRegionWidth}px`;\n                    break;\n                case \"content\":\n                    nextRegionWidth = this.regionRect.width;\n                    this.regionWidth = \"unset\";\n                    break;\n            }\n            let sizeDelta = 0;\n            switch (desiredHorizontalPosition) {\n                case \"start\":\n                    this.translateX = this.baseHorizontalOffset - nextRegionWidth;\n                    if (this.horizontalViewportLock &&\n                        this.anchorRect.left > this.viewportRect.right) {\n                        this.translateX =\n                            this.translateX -\n                                (this.anchorRect.left - this.viewportRect.right);\n                    }\n                    break;\n                case \"insetStart\":\n                    this.translateX =\n                        this.baseHorizontalOffset - nextRegionWidth + this.anchorRect.width;\n                    if (this.horizontalViewportLock &&\n                        this.anchorRect.right > this.viewportRect.right) {\n                        this.translateX =\n                            this.translateX -\n                                (this.anchorRect.right - this.viewportRect.right);\n                    }\n                    break;\n                case \"insetEnd\":\n                    this.translateX = this.baseHorizontalOffset;\n                    if (this.horizontalViewportLock &&\n                        this.anchorRect.left < this.viewportRect.left) {\n                        this.translateX =\n                            this.translateX - (this.anchorRect.left - this.viewportRect.left);\n                    }\n                    break;\n                case \"end\":\n                    this.translateX = this.baseHorizontalOffset + this.anchorRect.width;\n                    if (this.horizontalViewportLock &&\n                        this.anchorRect.right < this.viewportRect.left) {\n                        this.translateX =\n                            this.translateX -\n                                (this.anchorRect.right - this.viewportRect.left);\n                    }\n                    break;\n                case \"center\":\n                    sizeDelta = (this.anchorRect.width - nextRegionWidth) / 2;\n                    this.translateX = this.baseHorizontalOffset + sizeDelta;\n                    if (this.horizontalViewportLock) {\n                        const regionLeft = this.anchorRect.left + sizeDelta;\n                        const regionRight = this.anchorRect.right - sizeDelta;\n                        if (regionLeft < this.viewportRect.left &&\n                            !(regionRight > this.viewportRect.right)) {\n                            this.translateX =\n                                this.translateX - (regionLeft - this.viewportRect.left);\n                        }\n                        else if (regionRight > this.viewportRect.right &&\n                            !(regionLeft < this.viewportRect.left)) {\n                            this.translateX =\n                                this.translateX - (regionRight - this.viewportRect.right);\n                        }\n                    }\n                    break;\n            }\n            this.horizontalPosition = desiredHorizontalPosition;\n        };\n        /**\n         * Set vertical positioning state based on desired position\n         */\n        this.setVerticalPosition = (desiredVerticalPosition, nextPositionerDimension) => {\n            if (desiredVerticalPosition === undefined ||\n                this.regionRect === undefined ||\n                this.anchorRect === undefined ||\n                this.viewportRect === undefined) {\n                return;\n            }\n            let nextRegionHeight = 0;\n            switch (this.verticalScaling) {\n                case \"anchor\":\n                case \"fill\":\n                    nextRegionHeight = this.verticalViewportLock\n                        ? this.viewportRect.height\n                        : nextPositionerDimension.height;\n                    this.regionHeight = `${nextRegionHeight}px`;\n                    break;\n                case \"content\":\n                    nextRegionHeight = this.regionRect.height;\n                    this.regionHeight = \"unset\";\n                    break;\n            }\n            let sizeDelta = 0;\n            switch (desiredVerticalPosition) {\n                case \"start\":\n                    this.translateY = this.baseVerticalOffset - nextRegionHeight;\n                    if (this.verticalViewportLock &&\n                        this.anchorRect.top > this.viewportRect.bottom) {\n                        this.translateY =\n                            this.translateY -\n                                (this.anchorRect.top - this.viewportRect.bottom);\n                    }\n                    break;\n                case \"insetStart\":\n                    this.translateY =\n                        this.baseVerticalOffset - nextRegionHeight + this.anchorRect.height;\n                    if (this.verticalViewportLock &&\n                        this.anchorRect.bottom > this.viewportRect.bottom) {\n                        this.translateY =\n                            this.translateY -\n                                (this.anchorRect.bottom - this.viewportRect.bottom);\n                    }\n                    break;\n                case \"insetEnd\":\n                    this.translateY = this.baseVerticalOffset;\n                    if (this.verticalViewportLock &&\n                        this.anchorRect.top < this.viewportRect.top) {\n                        this.translateY =\n                            this.translateY - (this.anchorRect.top - this.viewportRect.top);\n                    }\n                    break;\n                case \"end\":\n                    this.translateY = this.baseVerticalOffset + this.anchorRect.height;\n                    if (this.verticalViewportLock &&\n                        this.anchorRect.bottom < this.viewportRect.top) {\n                        this.translateY =\n                            this.translateY -\n                                (this.anchorRect.bottom - this.viewportRect.top);\n                    }\n                    break;\n                case \"center\":\n                    sizeDelta = (this.anchorRect.height - nextRegionHeight) / 2;\n                    this.translateY = this.baseVerticalOffset + sizeDelta;\n                    if (this.verticalViewportLock) {\n                        const regionTop = this.anchorRect.top + sizeDelta;\n                        const regionBottom = this.anchorRect.bottom - sizeDelta;\n                        if (regionTop < this.viewportRect.top &&\n                            !(regionBottom > this.viewportRect.bottom)) {\n                            this.translateY =\n                                this.translateY - (regionTop - this.viewportRect.top);\n                        }\n                        else if (regionBottom > this.viewportRect.bottom &&\n                            !(regionTop < this.viewportRect.top)) {\n                            this.translateY =\n                                this.translateY - (regionBottom - this.viewportRect.bottom);\n                        }\n                    }\n            }\n            this.verticalPosition = desiredVerticalPosition;\n        };\n        /**\n         *  Get available positions based on positioning mode\n         */\n        this.getPositioningOptions = (inset) => {\n            if (inset) {\n                return [\"insetStart\", \"insetEnd\"];\n            }\n            return [\"start\", \"end\"];\n        };\n        /**\n         *  Get the space available for a particular relative position\n         */\n        this.getAvailableSpace = (positionOption, anchorStart, anchorEnd, anchorSpan, viewportStart, viewportEnd) => {\n            const spaceStart = anchorStart - viewportStart;\n            const spaceEnd = viewportEnd - (anchorStart + anchorSpan);\n            switch (positionOption) {\n                case \"start\":\n                    return spaceStart;\n                case \"insetStart\":\n                    return spaceStart + anchorSpan;\n                case \"insetEnd\":\n                    return spaceEnd + anchorSpan;\n                case \"end\":\n                    return spaceEnd;\n                case \"center\":\n                    return Math.min(spaceStart, spaceEnd) * 2 + anchorSpan;\n            }\n        };\n        /**\n         * Get region dimensions\n         */\n        this.getNextRegionDimension = (desiredHorizontalPosition, desiredVerticalPosition) => {\n            const newRegionDimension = {\n                height: this.regionRect !== undefined ? this.regionRect.height : 0,\n                width: this.regionRect !== undefined ? this.regionRect.width : 0,\n            };\n            if (desiredHorizontalPosition !== undefined &&\n                this.horizontalScaling === \"fill\") {\n                newRegionDimension.width = this.getAvailableSpace(desiredHorizontalPosition, this.anchorRect !== undefined ? this.anchorRect.left : 0, this.anchorRect !== undefined ? this.anchorRect.right : 0, this.anchorRect !== undefined ? this.anchorRect.width : 0, this.viewportRect !== undefined ? this.viewportRect.left : 0, this.viewportRect !== undefined ? this.viewportRect.right : 0);\n            }\n            else if (this.horizontalScaling === \"anchor\") {\n                newRegionDimension.width =\n                    this.anchorRect !== undefined ? this.anchorRect.width : 0;\n            }\n            if (desiredVerticalPosition !== undefined && this.verticalScaling === \"fill\") {\n                newRegionDimension.height = this.getAvailableSpace(desiredVerticalPosition, this.anchorRect !== undefined ? this.anchorRect.top : 0, this.anchorRect !== undefined ? this.anchorRect.bottom : 0, this.anchorRect !== undefined ? this.anchorRect.height : 0, this.viewportRect !== undefined ? this.viewportRect.top : 0, this.viewportRect !== undefined ? this.viewportRect.bottom : 0);\n            }\n            else if (this.verticalScaling === \"anchor\") {\n                newRegionDimension.height =\n                    this.anchorRect !== undefined ? this.anchorRect.height : 0;\n            }\n            return newRegionDimension;\n        };\n        /**\n         * starts event listeners that can trigger auto updating\n         */\n        this.startAutoUpdateEventListeners = () => {\n            window.addEventListener(eventResize, this.update, { passive: true });\n            window.addEventListener(eventScroll, this.update, {\n                passive: true,\n                capture: true,\n            });\n            if (this.resizeDetector !== null && this.viewportElement !== null) {\n                this.resizeDetector.observe(this.viewportElement);\n            }\n        };\n        /**\n         * stops event listeners that can trigger auto updating\n         */\n        this.stopAutoUpdateEventListeners = () => {\n            window.removeEventListener(eventResize, this.update);\n            window.removeEventListener(eventScroll, this.update);\n            if (this.resizeDetector !== null && this.viewportElement !== null) {\n                this.resizeDetector.unobserve(this.viewportElement);\n            }\n        };\n    }\n    anchorChanged() {\n        if (this.initialLayoutComplete) {\n            this.anchorElement = this.getAnchor();\n        }\n    }\n    viewportChanged() {\n        if (this.initialLayoutComplete) {\n            this.viewportElement = this.getViewport();\n        }\n    }\n    horizontalPositioningModeChanged() {\n        this.requestReset();\n    }\n    horizontalDefaultPositionChanged() {\n        this.updateForAttributeChange();\n    }\n    horizontalViewportLockChanged() {\n        this.updateForAttributeChange();\n    }\n    horizontalInsetChanged() {\n        this.updateForAttributeChange();\n    }\n    horizontalThresholdChanged() {\n        this.updateForAttributeChange();\n    }\n    horizontalScalingChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalPositioningModeChanged() {\n        this.requestReset();\n    }\n    verticalDefaultPositionChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalViewportLockChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalInsetChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalThresholdChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalScalingChanged() {\n        this.updateForAttributeChange();\n    }\n    fixedPlacementChanged() {\n        if (this.$fastController.isConnected &&\n            this.initialLayoutComplete) {\n            this.initialize();\n        }\n    }\n    autoUpdateModeChanged(prevMode, newMode) {\n        if (this.$fastController.isConnected &&\n            this.initialLayoutComplete) {\n            if (prevMode === \"auto\") {\n                this.stopAutoUpdateEventListeners();\n            }\n            if (newMode === \"auto\") {\n                this.startAutoUpdateEventListeners();\n            }\n        }\n    }\n    anchorElementChanged() {\n        this.requestReset();\n    }\n    viewportElementChanged() {\n        if (this.$fastController.isConnected &&\n            this.initialLayoutComplete) {\n            this.initialize();\n        }\n    }\n    /**\n     * @internal\n     */\n    connectedCallback() {\n        super.connectedCallback();\n        if (this.autoUpdateMode === \"auto\") {\n            this.startAutoUpdateEventListeners();\n        }\n        this.initialize();\n    }\n    /**\n     * @internal\n     */\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        if (this.autoUpdateMode === \"auto\") {\n            this.stopAutoUpdateEventListeners();\n        }\n        this.stopObservers();\n        this.disconnectResizeDetector();\n    }\n    /**\n     * @internal\n     */\n    adoptedCallback() {\n        this.initialize();\n    }\n    /**\n     * destroys the instance's resize observer\n     */\n    disconnectResizeDetector() {\n        if (this.resizeDetector !== null) {\n            this.resizeDetector.disconnect();\n            this.resizeDetector = null;\n        }\n    }\n    /**\n     * initializes the instance's resize observer\n     */\n    initializeResizeDetector() {\n        this.disconnectResizeDetector();\n        this.resizeDetector = new window.ResizeObserver(this.handleResize);\n    }\n    /**\n     * react to attribute changes that don't require a reset\n     */\n    updateForAttributeChange() {\n        if (this.$fastController.isConnected &&\n            this.initialLayoutComplete) {\n            this.forceUpdate = true;\n            this.update();\n        }\n    }\n    /**\n     * fully initializes the component\n     */\n    initialize() {\n        this.initializeResizeDetector();\n        if (this.anchorElement === null) {\n            this.anchorElement = this.getAnchor();\n        }\n        this.requestReset();\n    }\n    /**\n     * Request a reset if there are currently no open requests\n     */\n    requestReset() {\n        if (this.$fastController.isConnected &&\n            this.pendingReset === false) {\n            this.setInitialState();\n            DOM.queueUpdate(() => this.reset());\n            this.pendingReset = true;\n        }\n    }\n    /**\n     * sets the starting configuration for component internal values\n     */\n    setInitialState() {\n        this.initialLayoutComplete = false;\n        this.regionVisible = false;\n        this.translateX = 0;\n        this.translateY = 0;\n        this.baseHorizontalOffset = 0;\n        this.baseVerticalOffset = 0;\n        this.viewportRect = undefined;\n        this.regionRect = undefined;\n        this.anchorRect = undefined;\n        this.verticalPosition = undefined;\n        this.horizontalPosition = undefined;\n        this.style.opacity = \"0\";\n        this.style.pointerEvents = \"none\";\n        this.forceUpdate = false;\n        this.style.position = this.fixedPlacement ? \"fixed\" : \"absolute\";\n        this.updatePositionClasses();\n        this.updateRegionStyle();\n    }\n}\nAnchoredRegion.intersectionService = new IntersectionService();\n__decorate([\n    attr\n], AnchoredRegion.prototype, \"anchor\", void 0);\n__decorate([\n    attr\n], AnchoredRegion.prototype, \"viewport\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-positioning-mode\" })\n], AnchoredRegion.prototype, \"horizontalPositioningMode\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-default-position\" })\n], AnchoredRegion.prototype, \"horizontalDefaultPosition\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-viewport-lock\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"horizontalViewportLock\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-inset\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"horizontalInset\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-threshold\" })\n], AnchoredRegion.prototype, \"horizontalThreshold\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-scaling\" })\n], AnchoredRegion.prototype, \"horizontalScaling\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-positioning-mode\" })\n], AnchoredRegion.prototype, \"verticalPositioningMode\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-default-position\" })\n], AnchoredRegion.prototype, \"verticalDefaultPosition\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-viewport-lock\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"verticalViewportLock\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-inset\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"verticalInset\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-threshold\" })\n], AnchoredRegion.prototype, \"verticalThreshold\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-scaling\" })\n], AnchoredRegion.prototype, \"verticalScaling\", void 0);\n__decorate([\n    attr({ attribute: \"fixed-placement\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"fixedPlacement\", void 0);\n__decorate([\n    attr({ attribute: \"auto-update-mode\" })\n], AnchoredRegion.prototype, \"autoUpdateMode\", void 0);\n__decorate([\n    observable\n], AnchoredRegion.prototype, \"anchorElement\", void 0);\n__decorate([\n    observable\n], AnchoredRegion.prototype, \"viewportElement\", void 0);\n__decorate([\n    observable\n], AnchoredRegion.prototype, \"initialLayoutComplete\", void 0);\n"],"mappings":";;;;;;;AAAA,SAASA,UAAT,QAA2B,OAA3B;AACA,SAASC,IAAT,EAAeC,GAAf,EAAoBC,UAApB,QAAsC,yBAAtC;AACA,SAASC,SAAT,EAAoBC,WAApB,EAAiCC,WAAjC,QAAoD,+BAApD;AACA,SAASC,iBAAT,QAAkC,6CAAlC;AACA,SAASC,YAAT,QAA6B,2BAA7B;AACA,SAASC,mBAAT,QAAoC,sCAApC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAaC,cAAb;EAAA;;EAAA;;EACI,0BAAc;IAAA;;IAAA;;IACV,2BAASC,SAAT;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,MAAKC,MAAL,GAAc,EAAd;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,MAAKC,QAAL,GAAgB,EAAhB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACQ,MAAKC,yBAAL,GAAiC,cAAjC;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,MAAKC,yBAAL,GAAiC,OAAjC;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,MAAKC,sBAAL,GAA8B,KAA9B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,MAAKC,eAAL,GAAuB,KAAvB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,MAAKC,iBAAL,GAAyB,SAAzB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACQ,MAAKC,uBAAL,GAA+B,cAA/B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,MAAKC,uBAAL,GAA+B,OAA/B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,MAAKC,oBAAL,GAA4B,KAA5B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,MAAKC,aAAL,GAAqB,KAArB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,MAAKC,eAAL,GAAuB,SAAvB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACQ,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"},"metadata":{},"sourceType":"module"}