{"ast":null,"code":"/**\n * Big thanks to https://github.com/fkleuver and the https://github.com/aurelia/aurelia project\n * for the bulk of this code and many of the associated tests.\n */\nimport { emptyArray, FASTElement } from \"@microsoft/fast-element\"; // Tiny polyfill for TypeScript's Reflect metadata API.\n\nconst metadataByTarget = new Map();\n\nif (!(\"metadata\" in Reflect)) {\n  Reflect.metadata = function (key, value) {\n    return function (target) {\n      Reflect.defineMetadata(key, value, target);\n    };\n  };\n\n  Reflect.defineMetadata = function (key, value, target) {\n    let metadata = metadataByTarget.get(target);\n\n    if (metadata === void 0) {\n      metadataByTarget.set(target, metadata = new Map());\n    }\n\n    metadata.set(key, value);\n  };\n\n  Reflect.getOwnMetadata = function (key, target) {\n    const metadata = metadataByTarget.get(target);\n\n    if (metadata !== void 0) {\n      return metadata.get(key);\n    }\n\n    return void 0;\n  };\n}\n/**\n * A utility class used that constructs and registers resolvers for a dependency\n * injection container. Supports a standard set of object lifetimes.\n * @public\n */\n\n\nexport class ResolverBuilder {\n  /**\n   *\n   * @param container - The container to create resolvers for.\n   * @param key - The key to register resolvers under.\n   */\n  constructor(container, key) {\n    this.container = container;\n    this.key = key;\n  }\n  /**\n   * Creates a resolver for an existing object instance.\n   * @param value - The instance to resolve.\n   * @returns The resolver.\n   */\n\n\n  instance(value) {\n    return this.registerResolver(0\n    /* instance */\n    , value);\n  }\n  /**\n   * Creates a resolver that enforces a singleton lifetime.\n   * @param value - The type to create and cache the singleton for.\n   * @returns The resolver.\n   */\n\n\n  singleton(value) {\n    return this.registerResolver(1\n    /* singleton */\n    , value);\n  }\n  /**\n   * Creates a resolver that creates a new instance for every dependency request.\n   * @param value - The type to create instances of.\n   * @returns - The resolver.\n   */\n\n\n  transient(value) {\n    return this.registerResolver(2\n    /* transient */\n    , value);\n  }\n  /**\n   * Creates a resolver that invokes a callback function for every dependency resolution\n   * request, allowing custom logic to return the dependency.\n   * @param value - The callback to call during resolution.\n   * @returns The resolver.\n   */\n\n\n  callback(value) {\n    return this.registerResolver(3\n    /* callback */\n    , value);\n  }\n  /**\n   * Creates a resolver that invokes a callback function the first time that a dependency\n   * resolution is requested. The returned value is then cached and provided for all\n   * subsequent requests.\n   * @param value - The callback to call during the first resolution.\n   * @returns The resolver.\n   */\n\n\n  cachedCallback(value) {\n    return this.registerResolver(3\n    /* callback */\n    , cacheCallbackResult(value));\n  }\n  /**\n   * Aliases the current key to a different key.\n   * @param destinationKey - The key to point the alias to.\n   * @returns The resolver.\n   */\n\n\n  aliasTo(destinationKey) {\n    return this.registerResolver(5\n    /* alias */\n    , destinationKey);\n  }\n\n  registerResolver(strategy, state) {\n    const {\n      container,\n      key\n    } = this;\n    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n\n    this.container = this.key = void 0;\n    return container.registerResolver(key, new ResolverImpl(key, strategy, state));\n  }\n\n}\n\nfunction cloneArrayWithPossibleProps(source) {\n  const clone = source.slice();\n  const keys = Object.keys(source);\n  const len = keys.length;\n  let key;\n\n  for (let i = 0; i < len; ++i) {\n    key = keys[i];\n\n    if (!isArrayIndex(key)) {\n      clone[key] = source[key];\n    }\n  }\n\n  return clone;\n}\n/**\n * A set of default resolvers useful in configuring a container.\n * @public\n */\n\n\nexport const DefaultResolver = Object.freeze({\n  /**\n   * Disables auto-registration and throws for all un-registered dependencies.\n   * @param key - The key to create the resolver for.\n   */\n  none(key) {\n    throw Error(`${key.toString()} not registered, did you forget to add @singleton()?`);\n  },\n\n  /**\n   * Provides default singleton resolution behavior during auto-registration.\n   * @param key - The key to create the resolver for.\n   * @returns The resolver.\n   */\n  singleton(key) {\n    return new ResolverImpl(key, 1\n    /* singleton */\n    , key);\n  },\n\n  /**\n   * Provides default transient resolution behavior during auto-registration.\n   * @param key - The key to create the resolver for.\n   * @returns The resolver.\n   */\n  transient(key) {\n    return new ResolverImpl(key, 2\n    /* transient */\n    , key);\n  }\n\n});\n/**\n * Configuration for a dependency injection container.\n * @public\n */\n\nexport const ContainerConfiguration = Object.freeze({\n  /**\n   * The default configuration used when creating a DOM-disconnected container.\n   * @remarks\n   * The default creates a root container, with no parent container. It does not handle\n   * owner requests and it uses singleton resolution behavior for auto-registration.\n   */\n  default: Object.freeze({\n    parentLocator: () => null,\n    responsibleForOwnerRequests: false,\n    defaultResolver: DefaultResolver.singleton\n  })\n});\nconst dependencyLookup = new Map();\n\nfunction getParamTypes(key) {\n  return Type => {\n    return Reflect.getOwnMetadata(key, Type);\n  };\n}\n\nlet rootDOMContainer = null;\n/**\n * The gateway to dependency injection APIs.\n * @public\n */\n\nexport const DI = Object.freeze({\n  /**\n   * Creates a new dependency injection container.\n   * @param config - The configuration for the container.\n   * @returns A newly created dependency injection container.\n   */\n  createContainer(config) {\n    return new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config));\n  },\n\n  /**\n   * Finds the dependency injection container responsible for providing dependencies\n   * to the specified node.\n   * @param node - The node to find the responsible container for.\n   * @returns The container responsible for providing dependencies to the node.\n   * @remarks\n   * This will be the same as the parent container if the specified node\n   * does not itself host a container configured with responsibleForOwnerRequests.\n   */\n  findResponsibleContainer(node) {\n    const owned = node.$$container$$;\n\n    if (owned && owned.responsibleForOwnerRequests) {\n      return owned;\n    }\n\n    return DI.findParentContainer(node);\n  },\n\n  /**\n   * Find the dependency injection container up the DOM tree from this node.\n   * @param node - The node to find the parent container for.\n   * @returns The parent container of this node.\n   * @remarks\n   * This will be the same as the responsible container if the specified node\n   * does not itself host a container configured with responsibleForOwnerRequests.\n   */\n  findParentContainer(node) {\n    const event = new CustomEvent(DILocateParentEventType, {\n      bubbles: true,\n      composed: true,\n      cancelable: true,\n      detail: {\n        container: void 0\n      }\n    });\n    node.dispatchEvent(event);\n    return event.detail.container || DI.getOrCreateDOMContainer();\n  },\n\n  /**\n   * Returns a dependency injection container if one is explicitly owned by the specified\n   * node. If one is not owned, then a new container is created and assigned to the node.\n   * @param node - The node to find or create the container for.\n   * @param config - The configuration for the container if one needs to be created.\n   * @returns The located or created container.\n   * @remarks\n   * This API does not search for a responsible or parent container. It looks only for a container\n   * directly defined on the specified node and creates one at that location if one does not\n   * already exist.\n   */\n  getOrCreateDOMContainer(node, config) {\n    if (!node) {\n      return rootDOMContainer || (rootDOMContainer = new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config, {\n        parentLocator: () => null\n      })));\n    }\n\n    return node.$$container$$ || new ContainerImpl(node, Object.assign({}, ContainerConfiguration.default, config, {\n      parentLocator: DI.findParentContainer\n    }));\n  },\n\n  /**\n   * Gets the \"design:paramtypes\" metadata for the specified type.\n   * @param Type - The type to get the metadata for.\n   * @returns The metadata array or undefined if no metadata is found.\n   */\n  getDesignParamtypes: getParamTypes(\"design:paramtypes\"),\n\n  /**\n   * Gets the \"di:paramtypes\" metadata for the specified type.\n   * @param Type - The type to get the metadata for.\n   * @returns The metadata array or undefined if no metadata is found.\n   */\n  getAnnotationParamtypes: getParamTypes(\"di:paramtypes\"),\n\n  /**\n   *\n   * @param Type - Gets the \"di:paramtypes\" metadata for the specified type. If none is found,\n   * an empty metadata array is created and added.\n   * @returns The metadata array.\n   */\n  getOrCreateAnnotationParamTypes(Type) {\n    let annotationParamtypes = this.getAnnotationParamtypes(Type);\n\n    if (annotationParamtypes === void 0) {\n      Reflect.defineMetadata(\"di:paramtypes\", annotationParamtypes = [], Type);\n    }\n\n    return annotationParamtypes;\n  },\n\n  /**\n   * Gets the dependency keys representing what is needed to instantiate the specified type.\n   * @param Type - The type to get the dependencies for.\n   * @returns An array of dependency keys.\n   */\n  getDependencies(Type) {\n    // Note: Every detail of this getDependencies method is pretty deliberate at the moment, and probably not yet 100% tested from every possible angle,\n    // so be careful with making changes here as it can have a huge impact on complex end user apps.\n    // Preferably, only make changes to the dependency resolution process via a RFC.\n    let dependencies = dependencyLookup.get(Type);\n\n    if (dependencies === void 0) {\n      // Type.length is the number of constructor parameters. If this is 0, it could mean the class has an empty constructor\n      // but it could also mean the class has no constructor at all (in which case it inherits the constructor from the prototype).\n      // Non-zero constructor length + no paramtypes means emitDecoratorMetadata is off, or the class has no decorator.\n      // We're not doing anything with the above right now, but it's good to keep in mind for any future issues.\n      const inject = Type.inject;\n\n      if (inject === void 0) {\n        // design:paramtypes is set by tsc when emitDecoratorMetadata is enabled.\n        const designParamtypes = DI.getDesignParamtypes(Type); // di:paramtypes is set by the parameter decorator from DI.createInterface or by @inject\n\n        const annotationParamtypes = DI.getAnnotationParamtypes(Type);\n\n        if (designParamtypes === void 0) {\n          if (annotationParamtypes === void 0) {\n            // Only go up the prototype if neither static inject nor any of the paramtypes is defined, as\n            // there is no sound way to merge a type's deps with its prototype's deps\n            const Proto = Object.getPrototypeOf(Type);\n\n            if (typeof Proto === \"function\" && Proto !== Function.prototype) {\n              dependencies = cloneArrayWithPossibleProps(DI.getDependencies(Proto));\n            } else {\n              dependencies = [];\n            }\n          } else {\n            // No design:paramtypes so just use the di:paramtypes\n            dependencies = cloneArrayWithPossibleProps(annotationParamtypes);\n          }\n        } else if (annotationParamtypes === void 0) {\n          // No di:paramtypes so just use the design:paramtypes\n          dependencies = cloneArrayWithPossibleProps(designParamtypes);\n        } else {\n          // We've got both, so merge them (in case of conflict on same index, di:paramtypes take precedence)\n          dependencies = cloneArrayWithPossibleProps(designParamtypes);\n          let len = annotationParamtypes.length;\n          let auAnnotationParamtype;\n\n          for (let i = 0; i < len; ++i) {\n            auAnnotationParamtype = annotationParamtypes[i];\n\n            if (auAnnotationParamtype !== void 0) {\n              dependencies[i] = auAnnotationParamtype;\n            }\n          }\n\n          const keys = Object.keys(annotationParamtypes);\n          len = keys.length;\n          let key;\n\n          for (let i = 0; i < len; ++i) {\n            key = keys[i];\n\n            if (!isArrayIndex(key)) {\n              dependencies[key] = annotationParamtypes[key];\n            }\n          }\n        }\n      } else {\n        // Ignore paramtypes if we have static inject\n        dependencies = cloneArrayWithPossibleProps(inject);\n      }\n\n      dependencyLookup.set(Type, dependencies);\n    }\n\n    return dependencies;\n  },\n\n  /**\n   * Defines a property on a web component class. The value of this property will\n   * be resolved from the dependency injection container responsible for the element\n   * instance, based on where it is connected in the DOM.\n   * @param target - The target to define the property on.\n   * @param propertyName - The name of the property to define.\n   * @param key - The dependency injection key.\n   * @param respectConnection - Indicates whether or not to update the property value if the\n   * hosting component is disconnected and then re-connected at a different location in the DOM.\n   * @remarks\n   * The respectConnection option is only applicable to elements that descend from FASTElement.\n   */\n  defineProperty(target, propertyName, key) {\n    let respectConnection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const diPropertyKey = `$di_${propertyName}`;\n    Reflect.defineProperty(target, propertyName, {\n      get: function () {\n        let value = this[diPropertyKey];\n\n        if (value === void 0) {\n          const container = this instanceof HTMLElement ? DI.findResponsibleContainer(this) : DI.getOrCreateDOMContainer();\n          value = container.get(key);\n          this[diPropertyKey] = value;\n\n          if (respectConnection && this instanceof FASTElement) {\n            const notifier = this.$fastController;\n\n            const handleChange = () => {\n              const newContainer = DI.findResponsibleContainer(this);\n              const newValue = newContainer.get(key);\n              const oldValue = this[diPropertyKey];\n\n              if (newValue !== oldValue) {\n                this[diPropertyKey] = value;\n                notifier.notify(propertyName);\n              }\n            };\n\n            notifier.subscribe({\n              handleChange\n            }, \"isConnected\");\n          }\n        }\n\n        return value;\n      }\n    });\n  },\n\n  /**\n   * Creates a dependency injection key.\n   * @param nameConfigOrCallback - A friendly name for the key or a lambda that configures a\n   * default resolution for the dependency.\n   * @param configuror - If a friendly name was provided for the first parameter, then an optional\n   * lambda that configures a default resolution for the dependency can be provided second.\n   * @returns The created key.\n   * @remarks\n   * The created key can be used as a property decorator or constructor parameter decorator,\n   * in addition to its standard use in an inject array or through direct container APIs.\n   */\n  createInterface(nameConfigOrCallback, configuror) {\n    const configure = typeof nameConfigOrCallback === \"function\" ? nameConfigOrCallback : configuror;\n    const friendlyName = typeof nameConfigOrCallback === \"string\" ? nameConfigOrCallback : nameConfigOrCallback && \"friendlyName\" in nameConfigOrCallback ? nameConfigOrCallback.friendlyName || defaultFriendlyName : defaultFriendlyName;\n    const respectConnection = typeof nameConfigOrCallback === \"string\" ? false : nameConfigOrCallback && \"respectConnection\" in nameConfigOrCallback ? nameConfigOrCallback.respectConnection || false : false;\n\n    const Interface = function (target, property, index) {\n      if (target == null || new.target !== undefined) {\n        throw new Error(`No registration for interface: '${Interface.friendlyName}'`);\n      }\n\n      if (property) {\n        DI.defineProperty(target, property, Interface, respectConnection);\n      } else {\n        const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);\n        annotationParamtypes[index] = Interface;\n      }\n    };\n\n    Interface.$isInterface = true;\n    Interface.friendlyName = friendlyName == null ? \"(anonymous)\" : friendlyName;\n\n    if (configure != null) {\n      Interface.register = function (container, key) {\n        return configure(new ResolverBuilder(container, key !== null && key !== void 0 ? key : Interface));\n      };\n    }\n\n    Interface.toString = function toString() {\n      return `InterfaceSymbol<${Interface.friendlyName}>`;\n    };\n\n    return Interface;\n  },\n\n  /**\n   * A decorator that specifies what to inject into its target.\n   * @param dependencies - The dependencies to inject.\n   * @returns The decorator to be applied to the target class.\n   * @remarks\n   * The decorator can be used to decorate a class, listing all of the classes dependencies.\n   * Or it can be used to decorate a constructor paramter, indicating what to inject for that\n   * parameter.\n   * Or it can be used for a web component property, indicating what that property should resolve to.\n   */\n  inject() {\n    for (var _len = arguments.length, dependencies = new Array(_len), _key = 0; _key < _len; _key++) {\n      dependencies[_key] = arguments[_key];\n    }\n\n    return function (target, key, descriptor) {\n      if (typeof descriptor === \"number\") {\n        // It's a parameter decorator.\n        const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);\n        const dep = dependencies[0];\n\n        if (dep !== void 0) {\n          annotationParamtypes[descriptor] = dep;\n        }\n      } else if (key) {\n        DI.defineProperty(target, key, dependencies[0]);\n      } else {\n        const annotationParamtypes = descriptor ? DI.getOrCreateAnnotationParamTypes(descriptor.value) : DI.getOrCreateAnnotationParamTypes(target);\n        let dep;\n\n        for (let i = 0; i < dependencies.length; ++i) {\n          dep = dependencies[i];\n\n          if (dep !== void 0) {\n            annotationParamtypes[i] = dep;\n          }\n        }\n      }\n    };\n  },\n\n  /**\n   * Registers the `target` class as a transient dependency; each time the dependency is resolved\n   * a new instance will be created.\n   *\n   * @param target - The class / constructor function to register as transient.\n   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n   *\n   * @example\n   * On an existing class\n   * ```ts\n   * class Foo { }\n   * DI.transient(Foo);\n   * ```\n   *\n   * @example\n   * Inline declaration\n   *\n   * ```ts\n   * const Foo = DI.transient(class { });\n   * // Foo is now strongly typed with register\n   * Foo.register(container);\n   * ```\n   *\n   * @public\n   */\n  transient(target) {\n    target.register = function register(container) {\n      const registration = Registration.transient(target, target);\n      return registration.register(container);\n    };\n\n    target.registerInRequestor = false;\n    return target;\n  },\n\n  /**\n   * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n   * consecutive time the dependency is resolved, the same instance will be returned.\n   *\n   * @param target - The class / constructor function to register as a singleton.\n   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n   * @example\n   * On an existing class\n   * ```ts\n   * class Foo { }\n   * DI.singleton(Foo);\n   * ```\n   *\n   * @example\n   * Inline declaration\n   * ```ts\n   * const Foo = DI.singleton(class { });\n   * // Foo is now strongly typed with register\n   * Foo.register(container);\n   * ```\n   *\n   * @public\n   */\n  singleton(target) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultSingletonOptions;\n\n    target.register = function register(container) {\n      const registration = Registration.singleton(target, target);\n      return registration.register(container);\n    };\n\n    target.registerInRequestor = options.scoped;\n    return target;\n  }\n\n});\n/**\n * The interface key that resolves the dependency injection container itself.\n * @public\n */\n\nexport const Container = DI.createInterface(\"Container\");\n/**\n * The interface key that resolves the service locator itself.\n * @public\n */\n\nexport const ServiceLocator = Container;\n\nfunction createResolver(getter) {\n  return function (key) {\n    const resolver = function (target, property, descriptor) {\n      DI.inject(resolver)(target, property, descriptor);\n    };\n\n    resolver.$isResolver = true;\n\n    resolver.resolve = function (handler, requestor) {\n      return getter(key, handler, requestor);\n    };\n\n    return resolver;\n  };\n}\n/**\n * A decorator that specifies what to inject into its target.\n * @param dependencies - The dependencies to inject.\n * @returns The decorator to be applied to the target class.\n * @remarks\n * The decorator can be used to decorate a class, listing all of the classes dependencies.\n * Or it can be used to decorate a constructor paramter, indicating what to inject for that\n * parameter.\n * Or it can be used for a web component property, indicating what that property should resolve to.\n *\n * @public\n */\n\n\nexport const inject = DI.inject;\n\nfunction transientDecorator(target) {\n  return DI.transient(target);\n}\n\nexport function transient(target) {\n  return target == null ? transientDecorator : transientDecorator(target);\n}\nconst defaultSingletonOptions = {\n  scoped: false\n};\n\nfunction singletonDecorator(target) {\n  return DI.singleton(target);\n}\n/**\n * @public\n */\n\n\nexport function singleton(targetOrOptions) {\n  if (typeof targetOrOptions === \"function\") {\n    return DI.singleton(targetOrOptions);\n  }\n\n  return function ($target) {\n    return DI.singleton($target, targetOrOptions);\n  };\n}\n\nfunction createAllResolver(getter) {\n  return function (key, searchAncestors) {\n    searchAncestors = !!searchAncestors;\n\n    const resolver = function (target, property, descriptor) {\n      DI.inject(resolver)(target, property, descriptor);\n    };\n\n    resolver.$isResolver = true;\n\n    resolver.resolve = function (handler, requestor) {\n      /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n      return getter(key, handler, requestor, searchAncestors);\n    };\n\n    return resolver;\n  };\n}\n/**\n * A decorator and DI resolver that will resolve an array of all dependencies\n * registered with the specified key.\n * @param key - The key to resolve all dependencies for.\n * @param searchAncestors - [optional] Indicates whether to search ancestor containers.\n * @public\n */\n\n\nexport const all = createAllResolver((key, handler, requestor, searchAncestors) => requestor.getAll(key, searchAncestors));\n/**\n * A decorator that lazily injects a dependency depending on whether the `Key` is present at the time of function call.\n *\n * @example\n * You need to make your argument a function that returns the type, for example\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => number )\n * }\n * const foo = container.get(Foo); // instanceof Foo\n * foo.random(); // throws\n * ```\n * would throw an exception because you haven't registered `'random'` before calling the method.\n * @example\n * This, would give you a new 'Math.random()' number each time.\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => random )\n * }\n * container.register(Registration.callback('random', Math.random ));\n * container.get(Foo).random(); // some random number\n * container.get(Foo).random(); // another random number\n * ```\n *\n * `@lazy` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a\n * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.\n *\n * @param key - The key to lazily resolve.\n * see {@link DI.createInterface} on interactions with interfaces\n *\n * @public\n */\n\nexport const lazy = createResolver((key, handler, requestor) => {\n  return () => requestor.get(key);\n});\n/**\n * A decorator that allows you to optionally inject a dependency depending on whether the [[`Key`]] is present, for example:\n * @example\n * ```ts\n * class Foo {\n *   constructor( @inject('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo); // throws\n * ```\n * would fail\n *\n * @example\n * ```ts\n * class Foo {\n *   constructor( @optional('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo).str // somestring\n * ```\n * if you use it without a default it will inject `undefined`, so remember to mark your input type as\n * possibly `undefined`!\n *\n * @param key - The key to optionally resolve.\n * see {@link DI.createInterface} on interactions with interfaces\n *\n * @public\n */\n\nexport const optional = createResolver((key, handler, requestor) => {\n  if (requestor.has(key, true)) {\n    return requestor.get(key);\n  } else {\n    return undefined;\n  }\n});\n/**\n * A decorator that tells the container not to try to inject a dependency.\n *\n * @public\n */\n\nexport function ignore(target, property, descriptor) {\n  DI.inject(ignore)(target, property, descriptor);\n} // Hack: casting below used to prevent TS from generate a namespace which can't be commented\n// and results in documentation validation errors.\n\nignore.$isResolver = true;\n\nignore.resolve = () => undefined;\n/**\n * A decorator that indicates that a new instance should be injected scoped to the\n * container that requested the instance.\n * @param key - The dependency key for the new instance.\n * @remarks\n * This creates a resolver with an instance strategy pointing to the new instance, effectively\n * making this a singleton, scoped to the container or DOM's subtree.\n *\n * @public\n */\n\n\nexport const newInstanceForScope = createResolver((key, handler, requestor) => {\n  const instance = createNewInstance(key, handler);\n  const resolver = new ResolverImpl(key, 0\n  /* instance */\n  , instance);\n  requestor.registerResolver(key, resolver);\n  return instance;\n});\n/**\n * A decorator that indicates that a new instance should be injected.\n * @param key - The dependency key for the new instance.\n * @remarks\n * The instance is not internally cached with a resolver as newInstanceForScope does.\n *\n * @public\n */\n\nexport const newInstanceOf = createResolver((key, handler, _requestor) => createNewInstance(key, handler));\n\nfunction createNewInstance(key, handler) {\n  /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n  return handler.getFactory(key).construct(handler);\n}\n/** @internal */\n\n\nexport class ResolverImpl {\n  constructor(key, strategy, state) {\n    this.key = key;\n    this.strategy = strategy;\n    this.state = state;\n    this.resolving = false;\n  }\n\n  get $isResolver() {\n    return true;\n  }\n\n  register(container) {\n    return container.registerResolver(this.key, this);\n  }\n\n  resolve(handler, requestor) {\n    switch (this.strategy) {\n      case 0\n      /* instance */\n      :\n        return this.state;\n\n      case 1\n      /* singleton */\n      :\n        {\n          if (this.resolving) {\n            throw new Error(`Cyclic dependency found: ${this.state.name}`);\n          }\n\n          this.resolving = true;\n          this.state = handler.getFactory(this.state).construct(requestor);\n          this.strategy = 0\n          /* instance */\n          ;\n          this.resolving = false;\n          return this.state;\n        }\n\n      case 2\n      /* transient */\n      :\n        {\n          // Always create transients from the requesting container\n          const factory = handler.getFactory(this.state);\n\n          if (factory === null) {\n            throw new Error(`Resolver for ${String(this.key)} returned a null factory`);\n          }\n\n          return factory.construct(requestor);\n        }\n\n      case 3\n      /* callback */\n      :\n        return this.state(handler, requestor, this);\n\n      case 4\n      /* array */\n      :\n        return this.state[0].resolve(handler, requestor);\n\n      case 5\n      /* alias */\n      :\n        return requestor.get(this.state);\n\n      default:\n        throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`);\n    }\n  }\n\n  getFactory(container) {\n    var _a, _b, _c;\n\n    switch (this.strategy) {\n      case 1\n      /* singleton */\n      :\n      case 2\n      /* transient */\n      :\n        return container.getFactory(this.state);\n\n      case 5\n      /* alias */\n      :\n        return (_c = (_b = (_a = container.getResolver(this.state)) === null || _a === void 0 ? void 0 : _a.getFactory) === null || _b === void 0 ? void 0 : _b.call(_a, container)) !== null && _c !== void 0 ? _c : null;\n\n      default:\n        return null;\n    }\n  }\n\n}\n\nfunction containerGetKey(d) {\n  return this.get(d);\n}\n\nfunction transformInstance(inst, transform) {\n  return transform(inst);\n}\n/** @internal */\n\n\nexport class FactoryImpl {\n  constructor(Type, dependencies) {\n    this.Type = Type;\n    this.dependencies = dependencies;\n    this.transformers = null;\n  }\n\n  construct(container, dynamicDependencies) {\n    let instance;\n\n    if (dynamicDependencies === void 0) {\n      instance = new this.Type(...this.dependencies.map(containerGetKey, container));\n    } else {\n      instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies);\n    }\n\n    if (this.transformers == null) {\n      return instance;\n    }\n\n    return this.transformers.reduce(transformInstance, instance);\n  }\n\n  registerTransformer(transformer) {\n    (this.transformers || (this.transformers = [])).push(transformer);\n  }\n\n}\nconst containerResolver = {\n  $isResolver: true,\n\n  resolve(handler, requestor) {\n    return requestor;\n  }\n\n};\n\nfunction isRegistry(obj) {\n  return typeof obj.register === \"function\";\n}\n\nfunction isSelfRegistry(obj) {\n  return isRegistry(obj) && typeof obj.registerInRequestor === \"boolean\";\n}\n\nfunction isRegisterInRequester(obj) {\n  return isSelfRegistry(obj) && obj.registerInRequestor;\n}\n\nfunction isClass(obj) {\n  return obj.prototype !== void 0;\n}\n\nconst InstrinsicTypeNames = new Set([\"Array\", \"ArrayBuffer\", \"Boolean\", \"DataView\", \"Date\", \"Error\", \"EvalError\", \"Float32Array\", \"Float64Array\", \"Function\", \"Int8Array\", \"Int16Array\", \"Int32Array\", \"Map\", \"Number\", \"Object\", \"Promise\", \"RangeError\", \"ReferenceError\", \"RegExp\", \"Set\", \"SharedArrayBuffer\", \"String\", \"SyntaxError\", \"TypeError\", \"Uint8Array\", \"Uint8ClampedArray\", \"Uint16Array\", \"Uint32Array\", \"URIError\", \"WeakMap\", \"WeakSet\"]);\nconst DILocateParentEventType = \"__DI_LOCATE_PARENT__\";\nconst factories = new Map();\n/**\n * @internal\n */\n\nexport class ContainerImpl {\n  constructor(owner, config) {\n    this.owner = owner;\n    this.config = config;\n    this._parent = void 0;\n    this.registerDepth = 0;\n    this.context = null;\n\n    if (owner !== null) {\n      owner.$$container$$ = this;\n    }\n\n    this.resolvers = new Map();\n    this.resolvers.set(Container, containerResolver);\n\n    if (owner instanceof Node) {\n      owner.addEventListener(DILocateParentEventType, e => {\n        if (e.composedPath()[0] !== this.owner) {\n          e.detail.container = this;\n          e.stopImmediatePropagation();\n        }\n      });\n    }\n  }\n\n  get parent() {\n    if (this._parent === void 0) {\n      this._parent = this.config.parentLocator(this.owner);\n    }\n\n    return this._parent;\n  }\n\n  get depth() {\n    return this.parent === null ? 0 : this.parent.depth + 1;\n  }\n\n  get responsibleForOwnerRequests() {\n    return this.config.responsibleForOwnerRequests;\n  }\n\n  registerWithContext(context) {\n    this.context = context;\n\n    for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      params[_key2 - 1] = arguments[_key2];\n    }\n\n    this.register(...params);\n    this.context = null;\n    return this;\n  }\n\n  register() {\n    if (++this.registerDepth === 100) {\n      throw new Error(\"Unable to autoregister dependency\"); // Most likely cause is trying to register a plain object that does not have a\n      // register method and is not a class constructor\n    }\n\n    let current;\n    let keys;\n    let value;\n    let j;\n    let jj;\n    const context = this.context;\n\n    for (let i = 0, ii = arguments.length; i < ii; ++i) {\n      current = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n      if (!isObject(current)) {\n        continue;\n      }\n\n      if (isRegistry(current)) {\n        current.register(this, context);\n      } else if (isClass(current)) {\n        Registration.singleton(current, current).register(this);\n      } else {\n        keys = Object.keys(current);\n        j = 0;\n        jj = keys.length;\n\n        for (; j < jj; ++j) {\n          value = current[keys[j]];\n\n          if (!isObject(value)) {\n            continue;\n          } // note: we could remove this if-branch and call this.register directly\n          // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator\n\n\n          if (isRegistry(value)) {\n            value.register(this, context);\n          } else {\n            this.register(value);\n          }\n        }\n      }\n    }\n\n    --this.registerDepth;\n    return this;\n  }\n\n  registerResolver(key, resolver) {\n    validateKey(key);\n    const resolvers = this.resolvers;\n    const result = resolvers.get(key);\n\n    if (result == null) {\n      resolvers.set(key, resolver);\n    } else if (result instanceof ResolverImpl && result.strategy === 4\n    /* array */\n    ) {\n      result.state.push(resolver);\n    } else {\n      resolvers.set(key, new ResolverImpl(key, 4\n      /* array */\n      , [result, resolver]));\n    }\n\n    return resolver;\n  }\n\n  registerTransformer(key, transformer) {\n    const resolver = this.getResolver(key);\n\n    if (resolver == null) {\n      return false;\n    }\n\n    if (resolver.getFactory) {\n      const factory = resolver.getFactory(this);\n\n      if (factory == null) {\n        return false;\n      } // This type cast is a bit of a hacky one, necessary due to the duplicity of IResolverLike.\n      // Problem is that that interface's type arg can be of type Key, but the getFactory method only works on\n      // type Constructable. So the return type of that optional method has this additional constraint, which\n      // seems to confuse the type checker.\n\n\n      factory.registerTransformer(transformer);\n      return true;\n    }\n\n    return false;\n  }\n\n  getResolver(key) {\n    let autoRegister = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    validateKey(key);\n\n    if (key.resolve !== void 0) {\n      return key;\n    }\n    /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n\n\n    let current = this;\n    let resolver;\n\n    while (current != null) {\n      resolver = current.resolvers.get(key);\n\n      if (resolver == null) {\n        if (current.parent == null) {\n          const handler = isRegisterInRequester(key) ? this : current;\n          return autoRegister ? this.jitRegister(key, handler) : null;\n        }\n\n        current = current.parent;\n      } else {\n        return resolver;\n      }\n    }\n\n    return null;\n  }\n\n  has(key) {\n    let searchAncestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this.resolvers.has(key) ? true : searchAncestors && this.parent != null ? this.parent.has(key, true) : false;\n  }\n\n  get(key) {\n    validateKey(key);\n\n    if (key.$isResolver) {\n      return key.resolve(this, this);\n    }\n    /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n\n\n    let current = this;\n    let resolver;\n\n    while (current != null) {\n      resolver = current.resolvers.get(key);\n\n      if (resolver == null) {\n        if (current.parent == null) {\n          const handler = isRegisterInRequester(key) ? this : current;\n          resolver = this.jitRegister(key, handler);\n          return resolver.resolve(current, this);\n        }\n\n        current = current.parent;\n      } else {\n        return resolver.resolve(current, this);\n      }\n    }\n\n    throw new Error(`Unable to resolve key: ${key}`);\n  }\n\n  getAll(key) {\n    let searchAncestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    validateKey(key);\n    /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n\n    const requestor = this;\n    let current = requestor;\n    let resolver;\n\n    if (searchAncestors) {\n      let resolutions = emptyArray;\n\n      while (current != null) {\n        resolver = current.resolvers.get(key);\n\n        if (resolver != null) {\n          resolutions = resolutions.concat(\n          /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n          buildAllResponse(resolver, current, requestor));\n        }\n\n        current = current.parent;\n      }\n\n      return resolutions;\n    } else {\n      while (current != null) {\n        resolver = current.resolvers.get(key);\n\n        if (resolver == null) {\n          current = current.parent;\n\n          if (current == null) {\n            return emptyArray;\n          }\n        } else {\n          return buildAllResponse(resolver, current, requestor);\n        }\n      }\n    }\n\n    return emptyArray;\n  }\n\n  getFactory(Type) {\n    let factory = factories.get(Type);\n\n    if (factory === void 0) {\n      if (isNativeFunction(Type)) {\n        throw new Error(`${Type.name} is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`);\n      }\n\n      factories.set(Type, factory = new FactoryImpl(Type, DI.getDependencies(Type)));\n    }\n\n    return factory;\n  }\n\n  registerFactory(key, factory) {\n    factories.set(key, factory);\n  }\n\n  createChild(config) {\n    return new ContainerImpl(null, Object.assign({}, this.config, config, {\n      parentLocator: () => this\n    }));\n  }\n\n  jitRegister(keyAsValue, handler) {\n    if (typeof keyAsValue !== \"function\") {\n      throw new Error(`Attempted to jitRegister something that is not a constructor: '${keyAsValue}'. Did you forget to register this dependency?`);\n    }\n\n    if (InstrinsicTypeNames.has(keyAsValue.name)) {\n      throw new Error(`Attempted to jitRegister an intrinsic type: ${keyAsValue.name}. Did you forget to add @inject(Key)`);\n    }\n\n    if (isRegistry(keyAsValue)) {\n      const registrationResolver = keyAsValue.register(handler);\n\n      if (!(registrationResolver instanceof Object) || registrationResolver.resolve == null) {\n        const newResolver = handler.resolvers.get(keyAsValue);\n\n        if (newResolver != void 0) {\n          return newResolver;\n        }\n\n        throw new Error(\"A valid resolver was not returned from the static register method\");\n      }\n\n      return registrationResolver;\n    } else if (keyAsValue.$isInterface) {\n      throw new Error(`Attempted to jitRegister an interface: ${keyAsValue.friendlyName}`);\n    } else {\n      const resolver = this.config.defaultResolver(keyAsValue, handler);\n      handler.resolvers.set(keyAsValue, resolver);\n      return resolver;\n    }\n  }\n\n}\nconst cache = new WeakMap();\n\nfunction cacheCallbackResult(fun) {\n  return function (handler, requestor, resolver) {\n    if (cache.has(resolver)) {\n      return cache.get(resolver);\n    }\n\n    const t = fun(handler, requestor, resolver);\n    cache.set(resolver, t);\n    return t;\n  };\n}\n/**\n * You can use the resulting Registration of any of the factory methods\n * to register with the container.\n *\n * @example\n * ```\n * class Foo {}\n * const container = DI.createContainer();\n * container.register(Registration.instance(Foo, new Foo()));\n * container.get(Foo);\n * ```\n *\n * @public\n */\n\n\nexport const Registration = Object.freeze({\n  /**\n   * Allows you to pass an instance.\n   * Every time you request this {@link Key} you will get this instance back.\n   *\n   * @example\n   * ```\n   * Registration.instance(Foo, new Foo()));\n   * ```\n   *\n   * @param key - The key to register the instance under.\n   * @param value - The instance to return when the key is requested.\n   */\n  instance(key, value) {\n    return new ResolverImpl(key, 0\n    /* instance */\n    , value);\n  },\n\n  /**\n   * Creates an instance from the class.\n   * Every time you request this {@link Key} you will get the same one back.\n   *\n   * @example\n   * ```\n   * Registration.singleton(Foo, Foo);\n   * ```\n   *\n   * @param key - The key to register the singleton under.\n   * @param value - The class to instantiate as a singleton when first requested.\n   */\n  singleton(key, value) {\n    return new ResolverImpl(key, 1\n    /* singleton */\n    , value);\n  },\n\n  /**\n   * Creates an instance from a class.\n   * Every time you request this {@link Key} you will get a new instance.\n   *\n   * @example\n   * ```\n   * Registration.instance(Foo, Foo);\n   * ```\n   *\n   * @param key - The key to register the instance type under.\n   * @param value - The class to instantiate each time the key is requested.\n   */\n  transient(key, value) {\n    return new ResolverImpl(key, 2\n    /* transient */\n    , value);\n  },\n\n  /**\n   * Delegates to a callback function to provide the dependency.\n   * Every time you request this {@link Key} the callback will be invoked to provide\n   * the dependency.\n   *\n   * @example\n   * ```\n   * Registration.callback(Foo, () => new Foo());\n   * Registration.callback(Bar, (c: Container) => new Bar(c.get(Foo)));\n   * ```\n   *\n   * @param key - The key to register the callback for.\n   * @param callback - The function that is expected to return the dependency.\n   */\n  callback(key, callback) {\n    return new ResolverImpl(key, 3\n    /* callback */\n    , callback);\n  },\n\n  /**\n   * Delegates to a callback function to provide the dependency and then caches the\n   * dependency for future requests.\n   *\n   * @example\n   * ```\n   * Registration.cachedCallback(Foo, () => new Foo());\n   * Registration.cachedCallback(Bar, (c: Container) => new Bar(c.get(Foo)));\n   * ```\n   *\n   * @param key - The key to register the callback for.\n   * @param callback - The function that is expected to return the dependency.\n   * @remarks\n   * If you pass the same Registration to another container, the same cached value will be used.\n   * Should all references to the resolver returned be removed, the cache will expire.\n   */\n  cachedCallback(key, callback) {\n    return new ResolverImpl(key, 3\n    /* callback */\n    , cacheCallbackResult(callback));\n  },\n\n  /**\n   * Creates an alternate {@link Key} to retrieve an instance by.\n   *\n   * @example\n   * ```\n   * Register.singleton(Foo, Foo)\n   * Register.aliasTo(Foo, MyFoos);\n   *\n   * container.getAll(MyFoos) // contains an instance of Foo\n   * ```\n   *\n   * @param originalKey - The original key that has been registered.\n   * @param aliasKey - The alias to the original key.\n   */\n  aliasTo(originalKey, aliasKey) {\n    return new ResolverImpl(aliasKey, 5\n    /* alias */\n    , originalKey);\n  }\n\n});\n/** @internal */\n\nexport function validateKey(key) {\n  if (key === null || key === void 0) {\n    throw new Error(\"key/value cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?\");\n  }\n}\n\nfunction buildAllResponse(resolver, handler, requestor) {\n  if (resolver instanceof ResolverImpl && resolver.strategy === 4\n  /* array */\n  ) {\n    const state = resolver.state;\n    let i = state.length;\n    const results = new Array(i);\n\n    while (i--) {\n      results[i] = state[i].resolve(handler, requestor);\n    }\n\n    return results;\n  }\n\n  return [resolver.resolve(handler, requestor)];\n}\n\nconst defaultFriendlyName = \"(anonymous)\";\n\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null || typeof value === \"function\";\n}\n/**\n * Determine whether the value is a native function.\n *\n * @param fn - The function to check.\n * @returns `true` is the function is a native function, otherwise `false`\n */\n\n\nconst isNativeFunction = function () {\n  const lookup = new WeakMap();\n  let isNative = false;\n  let sourceText = \"\";\n  let i = 0;\n  return function (fn) {\n    isNative = lookup.get(fn);\n\n    if (isNative === void 0) {\n      sourceText = fn.toString();\n      i = sourceText.length; // http://www.ecma-international.org/ecma-262/#prod-NativeFunction\n\n      isNative = // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string\n      i >= 29 && // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.\n      i <= 100 && // This whole heuristic *could* be tricked by a comment. Do we need to care about that?\n      sourceText.charCodeAt(i - 1) === 0x7d && // }\n      // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.\n      sourceText.charCodeAt(i - 2) <= 0x20 && // whitespace\n      sourceText.charCodeAt(i - 3) === 0x5d && // ]\n      sourceText.charCodeAt(i - 4) === 0x65 && // e\n      sourceText.charCodeAt(i - 5) === 0x64 && // d\n      sourceText.charCodeAt(i - 6) === 0x6f && // o\n      sourceText.charCodeAt(i - 7) === 0x63 && // c\n      sourceText.charCodeAt(i - 8) === 0x20 && //\n      sourceText.charCodeAt(i - 9) === 0x65 && // e\n      sourceText.charCodeAt(i - 10) === 0x76 && // v\n      sourceText.charCodeAt(i - 11) === 0x69 && // i\n      sourceText.charCodeAt(i - 12) === 0x74 && // t\n      sourceText.charCodeAt(i - 13) === 0x61 && // a\n      sourceText.charCodeAt(i - 14) === 0x6e && // n\n      sourceText.charCodeAt(i - 15) === 0x58; // [\n\n      lookup.set(fn, isNative);\n    }\n\n    return isNative;\n  };\n}();\n\nconst isNumericLookup = {};\n\nfunction isArrayIndex(value) {\n  switch (typeof value) {\n    case \"number\":\n      return value >= 0 && (value | 0) === value;\n\n    case \"string\":\n      {\n        const result = isNumericLookup[value];\n\n        if (result !== void 0) {\n          return result;\n        }\n\n        const length = value.length;\n\n        if (length === 0) {\n          return isNumericLookup[value] = false;\n        }\n\n        let ch = 0;\n\n        for (let i = 0; i < length; ++i) {\n          ch = value.charCodeAt(i);\n\n          if (i === 0 && ch === 0x30 && length > 1\n          /* must not start with 0 */\n          || ch < 0x30\n          /* 0 */\n          || ch > 0x39\n          /* 9 */\n          ) {\n            return isNumericLookup[value] = false;\n          }\n        }\n\n        return isNumericLookup[value] = true;\n      }\n\n    default:\n      return false;\n  }\n}","map":{"version":3,"names":["emptyArray","FASTElement","metadataByTarget","Map","Reflect","metadata","key","value","target","defineMetadata","get","set","getOwnMetadata","ResolverBuilder","constructor","container","instance","registerResolver","singleton","transient","callback","cachedCallback","cacheCallbackResult","aliasTo","destinationKey","strategy","state","ResolverImpl","cloneArrayWithPossibleProps","source","clone","slice","keys","Object","len","length","i","isArrayIndex","DefaultResolver","freeze","none","Error","toString","ContainerConfiguration","default","parentLocator","responsibleForOwnerRequests","defaultResolver","dependencyLookup","getParamTypes","Type","rootDOMContainer","DI","createContainer","config","ContainerImpl","assign","findResponsibleContainer","node","owned","$$container$$","findParentContainer","event","CustomEvent","DILocateParentEventType","bubbles","composed","cancelable","detail","dispatchEvent","getOrCreateDOMContainer","getDesignParamtypes","getAnnotationParamtypes","getOrCreateAnnotationParamTypes","annotationParamtypes","getDependencies","dependencies","inject","designParamtypes","Proto","getPrototypeOf","Function","prototype","auAnnotationParamtype","defineProperty","propertyName","respectConnection","diPropertyKey","HTMLElement","notifier","$fastController","handleChange","newContainer","newValue","oldValue","notify","subscribe","createInterface","nameConfigOrCallback","configuror","configure","friendlyName","defaultFriendlyName","Interface","property","index","new","undefined","$isInterface","register","descriptor","dep","registration","Registration","registerInRequestor","options","defaultSingletonOptions","scoped","Container","ServiceLocator","createResolver","getter","resolver","$isResolver","resolve","handler","requestor","transientDecorator","singletonDecorator","targetOrOptions","$target","createAllResolver","searchAncestors","all","getAll","lazy","optional","has","ignore","newInstanceForScope","createNewInstance","newInstanceOf","_requestor","getFactory","construct","resolving","name","factory","String","_a","_b","_c","getResolver","call","containerGetKey","d","transformInstance","inst","transform","FactoryImpl","transformers","dynamicDependencies","map","reduce","registerTransformer","transformer","push","containerResolver","isRegistry","obj","isSelfRegistry","isRegisterInRequester","isClass","InstrinsicTypeNames","Set","factories","owner","_parent","registerDepth","context","resolvers","Node","addEventListener","e","composedPath","stopImmediatePropagation","parent","depth","registerWithContext","params","current","j","jj","ii","isObject","validateKey","result","autoRegister","jitRegister","resolutions","concat","buildAllResponse","isNativeFunction","registerFactory","createChild","keyAsValue","registrationResolver","newResolver","cache","WeakMap","fun","t","originalKey","aliasKey","results","Array","lookup","isNative","sourceText","fn","charCodeAt","isNumericLookup","ch"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/di/di.js"],"sourcesContent":["/**\n * Big thanks to https://github.com/fkleuver and the https://github.com/aurelia/aurelia project\n * for the bulk of this code and many of the associated tests.\n */\nimport { emptyArray, FASTElement } from \"@microsoft/fast-element\";\n// Tiny polyfill for TypeScript's Reflect metadata API.\nconst metadataByTarget = new Map();\nif (!(\"metadata\" in Reflect)) {\n    Reflect.metadata = function (key, value) {\n        return function (target) {\n            Reflect.defineMetadata(key, value, target);\n        };\n    };\n    Reflect.defineMetadata = function (key, value, target) {\n        let metadata = metadataByTarget.get(target);\n        if (metadata === void 0) {\n            metadataByTarget.set(target, (metadata = new Map()));\n        }\n        metadata.set(key, value);\n    };\n    Reflect.getOwnMetadata = function (key, target) {\n        const metadata = metadataByTarget.get(target);\n        if (metadata !== void 0) {\n            return metadata.get(key);\n        }\n        return void 0;\n    };\n}\n/**\n * A utility class used that constructs and registers resolvers for a dependency\n * injection container. Supports a standard set of object lifetimes.\n * @public\n */\nexport class ResolverBuilder {\n    /**\n     *\n     * @param container - The container to create resolvers for.\n     * @param key - The key to register resolvers under.\n     */\n    constructor(container, key) {\n        this.container = container;\n        this.key = key;\n    }\n    /**\n     * Creates a resolver for an existing object instance.\n     * @param value - The instance to resolve.\n     * @returns The resolver.\n     */\n    instance(value) {\n        return this.registerResolver(0 /* instance */, value);\n    }\n    /**\n     * Creates a resolver that enforces a singleton lifetime.\n     * @param value - The type to create and cache the singleton for.\n     * @returns The resolver.\n     */\n    singleton(value) {\n        return this.registerResolver(1 /* singleton */, value);\n    }\n    /**\n     * Creates a resolver that creates a new instance for every dependency request.\n     * @param value - The type to create instances of.\n     * @returns - The resolver.\n     */\n    transient(value) {\n        return this.registerResolver(2 /* transient */, value);\n    }\n    /**\n     * Creates a resolver that invokes a callback function for every dependency resolution\n     * request, allowing custom logic to return the dependency.\n     * @param value - The callback to call during resolution.\n     * @returns The resolver.\n     */\n    callback(value) {\n        return this.registerResolver(3 /* callback */, value);\n    }\n    /**\n     * Creates a resolver that invokes a callback function the first time that a dependency\n     * resolution is requested. The returned value is then cached and provided for all\n     * subsequent requests.\n     * @param value - The callback to call during the first resolution.\n     * @returns The resolver.\n     */\n    cachedCallback(value) {\n        return this.registerResolver(3 /* callback */, cacheCallbackResult(value));\n    }\n    /**\n     * Aliases the current key to a different key.\n     * @param destinationKey - The key to point the alias to.\n     * @returns The resolver.\n     */\n    aliasTo(destinationKey) {\n        return this.registerResolver(5 /* alias */, destinationKey);\n    }\n    registerResolver(strategy, state) {\n        const { container, key } = this;\n        /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n        this.container = this.key = (void 0);\n        return container.registerResolver(key, new ResolverImpl(key, strategy, state));\n    }\n}\nfunction cloneArrayWithPossibleProps(source) {\n    const clone = source.slice();\n    const keys = Object.keys(source);\n    const len = keys.length;\n    let key;\n    for (let i = 0; i < len; ++i) {\n        key = keys[i];\n        if (!isArrayIndex(key)) {\n            clone[key] = source[key];\n        }\n    }\n    return clone;\n}\n/**\n * A set of default resolvers useful in configuring a container.\n * @public\n */\nexport const DefaultResolver = Object.freeze({\n    /**\n     * Disables auto-registration and throws for all un-registered dependencies.\n     * @param key - The key to create the resolver for.\n     */\n    none(key) {\n        throw Error(`${key.toString()} not registered, did you forget to add @singleton()?`);\n    },\n    /**\n     * Provides default singleton resolution behavior during auto-registration.\n     * @param key - The key to create the resolver for.\n     * @returns The resolver.\n     */\n    singleton(key) {\n        return new ResolverImpl(key, 1 /* singleton */, key);\n    },\n    /**\n     * Provides default transient resolution behavior during auto-registration.\n     * @param key - The key to create the resolver for.\n     * @returns The resolver.\n     */\n    transient(key) {\n        return new ResolverImpl(key, 2 /* transient */, key);\n    },\n});\n/**\n * Configuration for a dependency injection container.\n * @public\n */\nexport const ContainerConfiguration = Object.freeze({\n    /**\n     * The default configuration used when creating a DOM-disconnected container.\n     * @remarks\n     * The default creates a root container, with no parent container. It does not handle\n     * owner requests and it uses singleton resolution behavior for auto-registration.\n     */\n    default: Object.freeze({\n        parentLocator: () => null,\n        responsibleForOwnerRequests: false,\n        defaultResolver: DefaultResolver.singleton,\n    }),\n});\nconst dependencyLookup = new Map();\nfunction getParamTypes(key) {\n    return (Type) => {\n        return Reflect.getOwnMetadata(key, Type);\n    };\n}\nlet rootDOMContainer = null;\n/**\n * The gateway to dependency injection APIs.\n * @public\n */\nexport const DI = Object.freeze({\n    /**\n     * Creates a new dependency injection container.\n     * @param config - The configuration for the container.\n     * @returns A newly created dependency injection container.\n     */\n    createContainer(config) {\n        return new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config));\n    },\n    /**\n     * Finds the dependency injection container responsible for providing dependencies\n     * to the specified node.\n     * @param node - The node to find the responsible container for.\n     * @returns The container responsible for providing dependencies to the node.\n     * @remarks\n     * This will be the same as the parent container if the specified node\n     * does not itself host a container configured with responsibleForOwnerRequests.\n     */\n    findResponsibleContainer(node) {\n        const owned = node.$$container$$;\n        if (owned && owned.responsibleForOwnerRequests) {\n            return owned;\n        }\n        return DI.findParentContainer(node);\n    },\n    /**\n     * Find the dependency injection container up the DOM tree from this node.\n     * @param node - The node to find the parent container for.\n     * @returns The parent container of this node.\n     * @remarks\n     * This will be the same as the responsible container if the specified node\n     * does not itself host a container configured with responsibleForOwnerRequests.\n     */\n    findParentContainer(node) {\n        const event = new CustomEvent(DILocateParentEventType, {\n            bubbles: true,\n            composed: true,\n            cancelable: true,\n            detail: { container: void 0 },\n        });\n        node.dispatchEvent(event);\n        return event.detail.container || DI.getOrCreateDOMContainer();\n    },\n    /**\n     * Returns a dependency injection container if one is explicitly owned by the specified\n     * node. If one is not owned, then a new container is created and assigned to the node.\n     * @param node - The node to find or create the container for.\n     * @param config - The configuration for the container if one needs to be created.\n     * @returns The located or created container.\n     * @remarks\n     * This API does not search for a responsible or parent container. It looks only for a container\n     * directly defined on the specified node and creates one at that location if one does not\n     * already exist.\n     */\n    getOrCreateDOMContainer(node, config) {\n        if (!node) {\n            return (rootDOMContainer ||\n                (rootDOMContainer = new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config, {\n                    parentLocator: () => null,\n                }))));\n        }\n        return (node.$$container$$ ||\n            new ContainerImpl(node, Object.assign({}, ContainerConfiguration.default, config, {\n                parentLocator: DI.findParentContainer,\n            })));\n    },\n    /**\n     * Gets the \"design:paramtypes\" metadata for the specified type.\n     * @param Type - The type to get the metadata for.\n     * @returns The metadata array or undefined if no metadata is found.\n     */\n    getDesignParamtypes: getParamTypes(\"design:paramtypes\"),\n    /**\n     * Gets the \"di:paramtypes\" metadata for the specified type.\n     * @param Type - The type to get the metadata for.\n     * @returns The metadata array or undefined if no metadata is found.\n     */\n    getAnnotationParamtypes: getParamTypes(\"di:paramtypes\"),\n    /**\n     *\n     * @param Type - Gets the \"di:paramtypes\" metadata for the specified type. If none is found,\n     * an empty metadata array is created and added.\n     * @returns The metadata array.\n     */\n    getOrCreateAnnotationParamTypes(Type) {\n        let annotationParamtypes = this.getAnnotationParamtypes(Type);\n        if (annotationParamtypes === void 0) {\n            Reflect.defineMetadata(\"di:paramtypes\", (annotationParamtypes = []), Type);\n        }\n        return annotationParamtypes;\n    },\n    /**\n     * Gets the dependency keys representing what is needed to instantiate the specified type.\n     * @param Type - The type to get the dependencies for.\n     * @returns An array of dependency keys.\n     */\n    getDependencies(Type) {\n        // Note: Every detail of this getDependencies method is pretty deliberate at the moment, and probably not yet 100% tested from every possible angle,\n        // so be careful with making changes here as it can have a huge impact on complex end user apps.\n        // Preferably, only make changes to the dependency resolution process via a RFC.\n        let dependencies = dependencyLookup.get(Type);\n        if (dependencies === void 0) {\n            // Type.length is the number of constructor parameters. If this is 0, it could mean the class has an empty constructor\n            // but it could also mean the class has no constructor at all (in which case it inherits the constructor from the prototype).\n            // Non-zero constructor length + no paramtypes means emitDecoratorMetadata is off, or the class has no decorator.\n            // We're not doing anything with the above right now, but it's good to keep in mind for any future issues.\n            const inject = Type.inject;\n            if (inject === void 0) {\n                // design:paramtypes is set by tsc when emitDecoratorMetadata is enabled.\n                const designParamtypes = DI.getDesignParamtypes(Type);\n                // di:paramtypes is set by the parameter decorator from DI.createInterface or by @inject\n                const annotationParamtypes = DI.getAnnotationParamtypes(Type);\n                if (designParamtypes === void 0) {\n                    if (annotationParamtypes === void 0) {\n                        // Only go up the prototype if neither static inject nor any of the paramtypes is defined, as\n                        // there is no sound way to merge a type's deps with its prototype's deps\n                        const Proto = Object.getPrototypeOf(Type);\n                        if (typeof Proto === \"function\" && Proto !== Function.prototype) {\n                            dependencies = cloneArrayWithPossibleProps(DI.getDependencies(Proto));\n                        }\n                        else {\n                            dependencies = [];\n                        }\n                    }\n                    else {\n                        // No design:paramtypes so just use the di:paramtypes\n                        dependencies = cloneArrayWithPossibleProps(annotationParamtypes);\n                    }\n                }\n                else if (annotationParamtypes === void 0) {\n                    // No di:paramtypes so just use the design:paramtypes\n                    dependencies = cloneArrayWithPossibleProps(designParamtypes);\n                }\n                else {\n                    // We've got both, so merge them (in case of conflict on same index, di:paramtypes take precedence)\n                    dependencies = cloneArrayWithPossibleProps(designParamtypes);\n                    let len = annotationParamtypes.length;\n                    let auAnnotationParamtype;\n                    for (let i = 0; i < len; ++i) {\n                        auAnnotationParamtype = annotationParamtypes[i];\n                        if (auAnnotationParamtype !== void 0) {\n                            dependencies[i] = auAnnotationParamtype;\n                        }\n                    }\n                    const keys = Object.keys(annotationParamtypes);\n                    len = keys.length;\n                    let key;\n                    for (let i = 0; i < len; ++i) {\n                        key = keys[i];\n                        if (!isArrayIndex(key)) {\n                            dependencies[key] = annotationParamtypes[key];\n                        }\n                    }\n                }\n            }\n            else {\n                // Ignore paramtypes if we have static inject\n                dependencies = cloneArrayWithPossibleProps(inject);\n            }\n            dependencyLookup.set(Type, dependencies);\n        }\n        return dependencies;\n    },\n    /**\n     * Defines a property on a web component class. The value of this property will\n     * be resolved from the dependency injection container responsible for the element\n     * instance, based on where it is connected in the DOM.\n     * @param target - The target to define the property on.\n     * @param propertyName - The name of the property to define.\n     * @param key - The dependency injection key.\n     * @param respectConnection - Indicates whether or not to update the property value if the\n     * hosting component is disconnected and then re-connected at a different location in the DOM.\n     * @remarks\n     * The respectConnection option is only applicable to elements that descend from FASTElement.\n     */\n    defineProperty(target, propertyName, key, respectConnection = false) {\n        const diPropertyKey = `$di_${propertyName}`;\n        Reflect.defineProperty(target, propertyName, {\n            get: function () {\n                let value = this[diPropertyKey];\n                if (value === void 0) {\n                    const container = this instanceof HTMLElement\n                        ? DI.findResponsibleContainer(this)\n                        : DI.getOrCreateDOMContainer();\n                    value = container.get(key);\n                    this[diPropertyKey] = value;\n                    if (respectConnection && this instanceof FASTElement) {\n                        const notifier = this.$fastController;\n                        const handleChange = () => {\n                            const newContainer = DI.findResponsibleContainer(this);\n                            const newValue = newContainer.get(key);\n                            const oldValue = this[diPropertyKey];\n                            if (newValue !== oldValue) {\n                                this[diPropertyKey] = value;\n                                notifier.notify(propertyName);\n                            }\n                        };\n                        notifier.subscribe({ handleChange }, \"isConnected\");\n                    }\n                }\n                return value;\n            },\n        });\n    },\n    /**\n     * Creates a dependency injection key.\n     * @param nameConfigOrCallback - A friendly name for the key or a lambda that configures a\n     * default resolution for the dependency.\n     * @param configuror - If a friendly name was provided for the first parameter, then an optional\n     * lambda that configures a default resolution for the dependency can be provided second.\n     * @returns The created key.\n     * @remarks\n     * The created key can be used as a property decorator or constructor parameter decorator,\n     * in addition to its standard use in an inject array or through direct container APIs.\n     */\n    createInterface(nameConfigOrCallback, configuror) {\n        const configure = typeof nameConfigOrCallback === \"function\"\n            ? nameConfigOrCallback\n            : configuror;\n        const friendlyName = typeof nameConfigOrCallback === \"string\"\n            ? nameConfigOrCallback\n            : nameConfigOrCallback && \"friendlyName\" in nameConfigOrCallback\n                ? nameConfigOrCallback.friendlyName || defaultFriendlyName\n                : defaultFriendlyName;\n        const respectConnection = typeof nameConfigOrCallback === \"string\"\n            ? false\n            : nameConfigOrCallback && \"respectConnection\" in nameConfigOrCallback\n                ? nameConfigOrCallback.respectConnection || false\n                : false;\n        const Interface = function (target, property, index) {\n            if (target == null || new.target !== undefined) {\n                throw new Error(`No registration for interface: '${Interface.friendlyName}'`);\n            }\n            if (property) {\n                DI.defineProperty(target, property, Interface, respectConnection);\n            }\n            else {\n                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);\n                annotationParamtypes[index] = Interface;\n            }\n        };\n        Interface.$isInterface = true;\n        Interface.friendlyName = friendlyName == null ? \"(anonymous)\" : friendlyName;\n        if (configure != null) {\n            Interface.register = function (container, key) {\n                return configure(new ResolverBuilder(container, key !== null && key !== void 0 ? key : Interface));\n            };\n        }\n        Interface.toString = function toString() {\n            return `InterfaceSymbol<${Interface.friendlyName}>`;\n        };\n        return Interface;\n    },\n    /**\n     * A decorator that specifies what to inject into its target.\n     * @param dependencies - The dependencies to inject.\n     * @returns The decorator to be applied to the target class.\n     * @remarks\n     * The decorator can be used to decorate a class, listing all of the classes dependencies.\n     * Or it can be used to decorate a constructor paramter, indicating what to inject for that\n     * parameter.\n     * Or it can be used for a web component property, indicating what that property should resolve to.\n     */\n    inject(...dependencies) {\n        return function (target, key, descriptor) {\n            if (typeof descriptor === \"number\") {\n                // It's a parameter decorator.\n                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);\n                const dep = dependencies[0];\n                if (dep !== void 0) {\n                    annotationParamtypes[descriptor] = dep;\n                }\n            }\n            else if (key) {\n                DI.defineProperty(target, key, dependencies[0]);\n            }\n            else {\n                const annotationParamtypes = descriptor\n                    ? DI.getOrCreateAnnotationParamTypes(descriptor.value)\n                    : DI.getOrCreateAnnotationParamTypes(target);\n                let dep;\n                for (let i = 0; i < dependencies.length; ++i) {\n                    dep = dependencies[i];\n                    if (dep !== void 0) {\n                        annotationParamtypes[i] = dep;\n                    }\n                }\n            }\n        };\n    },\n    /**\n     * Registers the `target` class as a transient dependency; each time the dependency is resolved\n     * a new instance will be created.\n     *\n     * @param target - The class / constructor function to register as transient.\n     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n     *\n     * @example\n     * On an existing class\n     * ```ts\n     * class Foo { }\n     * DI.transient(Foo);\n     * ```\n     *\n     * @example\n     * Inline declaration\n     *\n     * ```ts\n     * const Foo = DI.transient(class { });\n     * // Foo is now strongly typed with register\n     * Foo.register(container);\n     * ```\n     *\n     * @public\n     */\n    transient(target) {\n        target.register = function register(container) {\n            const registration = Registration.transient(target, target);\n            return registration.register(container);\n        };\n        target.registerInRequestor = false;\n        return target;\n    },\n    /**\n     * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n     * consecutive time the dependency is resolved, the same instance will be returned.\n     *\n     * @param target - The class / constructor function to register as a singleton.\n     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n     * @example\n     * On an existing class\n     * ```ts\n     * class Foo { }\n     * DI.singleton(Foo);\n     * ```\n     *\n     * @example\n     * Inline declaration\n     * ```ts\n     * const Foo = DI.singleton(class { });\n     * // Foo is now strongly typed with register\n     * Foo.register(container);\n     * ```\n     *\n     * @public\n     */\n    singleton(target, options = defaultSingletonOptions) {\n        target.register = function register(container) {\n            const registration = Registration.singleton(target, target);\n            return registration.register(container);\n        };\n        target.registerInRequestor = options.scoped;\n        return target;\n    },\n});\n/**\n * The interface key that resolves the dependency injection container itself.\n * @public\n */\nexport const Container = DI.createInterface(\"Container\");\n/**\n * The interface key that resolves the service locator itself.\n * @public\n */\nexport const ServiceLocator = Container;\nfunction createResolver(getter) {\n    return function (key) {\n        const resolver = function (target, property, descriptor) {\n            DI.inject(resolver)(target, property, descriptor);\n        };\n        resolver.$isResolver = true;\n        resolver.resolve = function (handler, requestor) {\n            return getter(key, handler, requestor);\n        };\n        return resolver;\n    };\n}\n/**\n * A decorator that specifies what to inject into its target.\n * @param dependencies - The dependencies to inject.\n * @returns The decorator to be applied to the target class.\n * @remarks\n * The decorator can be used to decorate a class, listing all of the classes dependencies.\n * Or it can be used to decorate a constructor paramter, indicating what to inject for that\n * parameter.\n * Or it can be used for a web component property, indicating what that property should resolve to.\n *\n * @public\n */\nexport const inject = DI.inject;\nfunction transientDecorator(target) {\n    return DI.transient(target);\n}\nexport function transient(target) {\n    return target == null ? transientDecorator : transientDecorator(target);\n}\nconst defaultSingletonOptions = { scoped: false };\nfunction singletonDecorator(target) {\n    return DI.singleton(target);\n}\n/**\n * @public\n */\nexport function singleton(targetOrOptions) {\n    if (typeof targetOrOptions === \"function\") {\n        return DI.singleton(targetOrOptions);\n    }\n    return function ($target) {\n        return DI.singleton($target, targetOrOptions);\n    };\n}\nfunction createAllResolver(getter) {\n    return function (key, searchAncestors) {\n        searchAncestors = !!searchAncestors;\n        const resolver = function (target, property, descriptor) {\n            DI.inject(resolver)(target, property, descriptor);\n        };\n        resolver.$isResolver = true;\n        resolver.resolve = function (handler, requestor) {\n            /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n            return getter(key, handler, requestor, searchAncestors);\n        };\n        return resolver;\n    };\n}\n/**\n * A decorator and DI resolver that will resolve an array of all dependencies\n * registered with the specified key.\n * @param key - The key to resolve all dependencies for.\n * @param searchAncestors - [optional] Indicates whether to search ancestor containers.\n * @public\n */\nexport const all = createAllResolver((key, handler, requestor, searchAncestors) => requestor.getAll(key, searchAncestors));\n/**\n * A decorator that lazily injects a dependency depending on whether the `Key` is present at the time of function call.\n *\n * @example\n * You need to make your argument a function that returns the type, for example\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => number )\n * }\n * const foo = container.get(Foo); // instanceof Foo\n * foo.random(); // throws\n * ```\n * would throw an exception because you haven't registered `'random'` before calling the method.\n * @example\n * This, would give you a new 'Math.random()' number each time.\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => random )\n * }\n * container.register(Registration.callback('random', Math.random ));\n * container.get(Foo).random(); // some random number\n * container.get(Foo).random(); // another random number\n * ```\n *\n * `@lazy` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a\n * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.\n *\n * @param key - The key to lazily resolve.\n * see {@link DI.createInterface} on interactions with interfaces\n *\n * @public\n */\nexport const lazy = createResolver((key, handler, requestor) => {\n    return () => requestor.get(key);\n});\n/**\n * A decorator that allows you to optionally inject a dependency depending on whether the [[`Key`]] is present, for example:\n * @example\n * ```ts\n * class Foo {\n *   constructor( @inject('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo); // throws\n * ```\n * would fail\n *\n * @example\n * ```ts\n * class Foo {\n *   constructor( @optional('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo).str // somestring\n * ```\n * if you use it without a default it will inject `undefined`, so remember to mark your input type as\n * possibly `undefined`!\n *\n * @param key - The key to optionally resolve.\n * see {@link DI.createInterface} on interactions with interfaces\n *\n * @public\n */\nexport const optional = createResolver((key, handler, requestor) => {\n    if (requestor.has(key, true)) {\n        return requestor.get(key);\n    }\n    else {\n        return undefined;\n    }\n});\n/**\n * A decorator that tells the container not to try to inject a dependency.\n *\n * @public\n */\nexport function ignore(target, property, descriptor) {\n    DI.inject(ignore)(target, property, descriptor);\n}\n// Hack: casting below used to prevent TS from generate a namespace which can't be commented\n// and results in documentation validation errors.\nignore.$isResolver = true;\nignore.resolve = () => undefined;\n/**\n * A decorator that indicates that a new instance should be injected scoped to the\n * container that requested the instance.\n * @param key - The dependency key for the new instance.\n * @remarks\n * This creates a resolver with an instance strategy pointing to the new instance, effectively\n * making this a singleton, scoped to the container or DOM's subtree.\n *\n * @public\n */\nexport const newInstanceForScope = createResolver((key, handler, requestor) => {\n    const instance = createNewInstance(key, handler);\n    const resolver = new ResolverImpl(key, 0 /* instance */, instance);\n    requestor.registerResolver(key, resolver);\n    return instance;\n});\n/**\n * A decorator that indicates that a new instance should be injected.\n * @param key - The dependency key for the new instance.\n * @remarks\n * The instance is not internally cached with a resolver as newInstanceForScope does.\n *\n * @public\n */\nexport const newInstanceOf = createResolver((key, handler, _requestor) => createNewInstance(key, handler));\nfunction createNewInstance(key, handler) {\n    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n    return handler.getFactory(key).construct(handler);\n}\n/** @internal */\nexport class ResolverImpl {\n    constructor(key, strategy, state) {\n        this.key = key;\n        this.strategy = strategy;\n        this.state = state;\n        this.resolving = false;\n    }\n    get $isResolver() {\n        return true;\n    }\n    register(container) {\n        return container.registerResolver(this.key, this);\n    }\n    resolve(handler, requestor) {\n        switch (this.strategy) {\n            case 0 /* instance */:\n                return this.state;\n            case 1 /* singleton */: {\n                if (this.resolving) {\n                    throw new Error(`Cyclic dependency found: ${this.state.name}`);\n                }\n                this.resolving = true;\n                this.state = handler\n                    .getFactory(this.state)\n                    .construct(requestor);\n                this.strategy = 0 /* instance */;\n                this.resolving = false;\n                return this.state;\n            }\n            case 2 /* transient */: {\n                // Always create transients from the requesting container\n                const factory = handler.getFactory(this.state);\n                if (factory === null) {\n                    throw new Error(`Resolver for ${String(this.key)} returned a null factory`);\n                }\n                return factory.construct(requestor);\n            }\n            case 3 /* callback */:\n                return this.state(handler, requestor, this);\n            case 4 /* array */:\n                return this.state[0].resolve(handler, requestor);\n            case 5 /* alias */:\n                return requestor.get(this.state);\n            default:\n                throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`);\n        }\n    }\n    getFactory(container) {\n        var _a, _b, _c;\n        switch (this.strategy) {\n            case 1 /* singleton */:\n            case 2 /* transient */:\n                return container.getFactory(this.state);\n            case 5 /* alias */:\n                return (_c = (_b = (_a = container.getResolver(this.state)) === null || _a === void 0 ? void 0 : _a.getFactory) === null || _b === void 0 ? void 0 : _b.call(_a, container)) !== null && _c !== void 0 ? _c : null;\n            default:\n                return null;\n        }\n    }\n}\nfunction containerGetKey(d) {\n    return this.get(d);\n}\nfunction transformInstance(inst, transform) {\n    return transform(inst);\n}\n/** @internal */\nexport class FactoryImpl {\n    constructor(Type, dependencies) {\n        this.Type = Type;\n        this.dependencies = dependencies;\n        this.transformers = null;\n    }\n    construct(container, dynamicDependencies) {\n        let instance;\n        if (dynamicDependencies === void 0) {\n            instance = new this.Type(...this.dependencies.map(containerGetKey, container));\n        }\n        else {\n            instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies);\n        }\n        if (this.transformers == null) {\n            return instance;\n        }\n        return this.transformers.reduce(transformInstance, instance);\n    }\n    registerTransformer(transformer) {\n        (this.transformers || (this.transformers = [])).push(transformer);\n    }\n}\nconst containerResolver = {\n    $isResolver: true,\n    resolve(handler, requestor) {\n        return requestor;\n    },\n};\nfunction isRegistry(obj) {\n    return typeof obj.register === \"function\";\n}\nfunction isSelfRegistry(obj) {\n    return isRegistry(obj) && typeof obj.registerInRequestor === \"boolean\";\n}\nfunction isRegisterInRequester(obj) {\n    return isSelfRegistry(obj) && obj.registerInRequestor;\n}\nfunction isClass(obj) {\n    return obj.prototype !== void 0;\n}\nconst InstrinsicTypeNames = new Set([\n    \"Array\",\n    \"ArrayBuffer\",\n    \"Boolean\",\n    \"DataView\",\n    \"Date\",\n    \"Error\",\n    \"EvalError\",\n    \"Float32Array\",\n    \"Float64Array\",\n    \"Function\",\n    \"Int8Array\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Map\",\n    \"Number\",\n    \"Object\",\n    \"Promise\",\n    \"RangeError\",\n    \"ReferenceError\",\n    \"RegExp\",\n    \"Set\",\n    \"SharedArrayBuffer\",\n    \"String\",\n    \"SyntaxError\",\n    \"TypeError\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"URIError\",\n    \"WeakMap\",\n    \"WeakSet\",\n]);\nconst DILocateParentEventType = \"__DI_LOCATE_PARENT__\";\nconst factories = new Map();\n/**\n * @internal\n */\nexport class ContainerImpl {\n    constructor(owner, config) {\n        this.owner = owner;\n        this.config = config;\n        this._parent = void 0;\n        this.registerDepth = 0;\n        this.context = null;\n        if (owner !== null) {\n            owner.$$container$$ = this;\n        }\n        this.resolvers = new Map();\n        this.resolvers.set(Container, containerResolver);\n        if (owner instanceof Node) {\n            owner.addEventListener(DILocateParentEventType, (e) => {\n                if (e.composedPath()[0] !== this.owner) {\n                    e.detail.container = this;\n                    e.stopImmediatePropagation();\n                }\n            });\n        }\n    }\n    get parent() {\n        if (this._parent === void 0) {\n            this._parent = this.config.parentLocator(this.owner);\n        }\n        return this._parent;\n    }\n    get depth() {\n        return this.parent === null ? 0 : this.parent.depth + 1;\n    }\n    get responsibleForOwnerRequests() {\n        return this.config.responsibleForOwnerRequests;\n    }\n    registerWithContext(context, ...params) {\n        this.context = context;\n        this.register(...params);\n        this.context = null;\n        return this;\n    }\n    register(...params) {\n        if (++this.registerDepth === 100) {\n            throw new Error(\"Unable to autoregister dependency\");\n            // Most likely cause is trying to register a plain object that does not have a\n            // register method and is not a class constructor\n        }\n        let current;\n        let keys;\n        let value;\n        let j;\n        let jj;\n        const context = this.context;\n        for (let i = 0, ii = params.length; i < ii; ++i) {\n            current = params[i];\n            if (!isObject(current)) {\n                continue;\n            }\n            if (isRegistry(current)) {\n                current.register(this, context);\n            }\n            else if (isClass(current)) {\n                Registration.singleton(current, current).register(this);\n            }\n            else {\n                keys = Object.keys(current);\n                j = 0;\n                jj = keys.length;\n                for (; j < jj; ++j) {\n                    value = current[keys[j]];\n                    if (!isObject(value)) {\n                        continue;\n                    }\n                    // note: we could remove this if-branch and call this.register directly\n                    // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator\n                    if (isRegistry(value)) {\n                        value.register(this, context);\n                    }\n                    else {\n                        this.register(value);\n                    }\n                }\n            }\n        }\n        --this.registerDepth;\n        return this;\n    }\n    registerResolver(key, resolver) {\n        validateKey(key);\n        const resolvers = this.resolvers;\n        const result = resolvers.get(key);\n        if (result == null) {\n            resolvers.set(key, resolver);\n        }\n        else if (result instanceof ResolverImpl &&\n            result.strategy === 4 /* array */) {\n            result.state.push(resolver);\n        }\n        else {\n            resolvers.set(key, new ResolverImpl(key, 4 /* array */, [result, resolver]));\n        }\n        return resolver;\n    }\n    registerTransformer(key, transformer) {\n        const resolver = this.getResolver(key);\n        if (resolver == null) {\n            return false;\n        }\n        if (resolver.getFactory) {\n            const factory = resolver.getFactory(this);\n            if (factory == null) {\n                return false;\n            }\n            // This type cast is a bit of a hacky one, necessary due to the duplicity of IResolverLike.\n            // Problem is that that interface's type arg can be of type Key, but the getFactory method only works on\n            // type Constructable. So the return type of that optional method has this additional constraint, which\n            // seems to confuse the type checker.\n            factory.registerTransformer(transformer);\n            return true;\n        }\n        return false;\n    }\n    getResolver(key, autoRegister = true) {\n        validateKey(key);\n        if (key.resolve !== void 0) {\n            return key;\n        }\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n        let current = this;\n        let resolver;\n        while (current != null) {\n            resolver = current.resolvers.get(key);\n            if (resolver == null) {\n                if (current.parent == null) {\n                    const handler = isRegisterInRequester(key)\n                        ? this\n                        : current;\n                    return autoRegister ? this.jitRegister(key, handler) : null;\n                }\n                current = current.parent;\n            }\n            else {\n                return resolver;\n            }\n        }\n        return null;\n    }\n    has(key, searchAncestors = false) {\n        return this.resolvers.has(key)\n            ? true\n            : searchAncestors && this.parent != null\n                ? this.parent.has(key, true)\n                : false;\n    }\n    get(key) {\n        validateKey(key);\n        if (key.$isResolver) {\n            return key.resolve(this, this);\n        }\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n        let current = this;\n        let resolver;\n        while (current != null) {\n            resolver = current.resolvers.get(key);\n            if (resolver == null) {\n                if (current.parent == null) {\n                    const handler = isRegisterInRequester(key)\n                        ? this\n                        : current;\n                    resolver = this.jitRegister(key, handler);\n                    return resolver.resolve(current, this);\n                }\n                current = current.parent;\n            }\n            else {\n                return resolver.resolve(current, this);\n            }\n        }\n        throw new Error(`Unable to resolve key: ${key}`);\n    }\n    getAll(key, searchAncestors = false) {\n        validateKey(key);\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n        const requestor = this;\n        let current = requestor;\n        let resolver;\n        if (searchAncestors) {\n            let resolutions = emptyArray;\n            while (current != null) {\n                resolver = current.resolvers.get(key);\n                if (resolver != null) {\n                    resolutions = resolutions.concat(\n                    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n                    buildAllResponse(resolver, current, requestor));\n                }\n                current = current.parent;\n            }\n            return resolutions;\n        }\n        else {\n            while (current != null) {\n                resolver = current.resolvers.get(key);\n                if (resolver == null) {\n                    current = current.parent;\n                    if (current == null) {\n                        return emptyArray;\n                    }\n                }\n                else {\n                    return buildAllResponse(resolver, current, requestor);\n                }\n            }\n        }\n        return emptyArray;\n    }\n    getFactory(Type) {\n        let factory = factories.get(Type);\n        if (factory === void 0) {\n            if (isNativeFunction(Type)) {\n                throw new Error(`${Type.name} is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`);\n            }\n            factories.set(Type, (factory = new FactoryImpl(Type, DI.getDependencies(Type))));\n        }\n        return factory;\n    }\n    registerFactory(key, factory) {\n        factories.set(key, factory);\n    }\n    createChild(config) {\n        return new ContainerImpl(null, Object.assign({}, this.config, config, { parentLocator: () => this }));\n    }\n    jitRegister(keyAsValue, handler) {\n        if (typeof keyAsValue !== \"function\") {\n            throw new Error(`Attempted to jitRegister something that is not a constructor: '${keyAsValue}'. Did you forget to register this dependency?`);\n        }\n        if (InstrinsicTypeNames.has(keyAsValue.name)) {\n            throw new Error(`Attempted to jitRegister an intrinsic type: ${keyAsValue.name}. Did you forget to add @inject(Key)`);\n        }\n        if (isRegistry(keyAsValue)) {\n            const registrationResolver = keyAsValue.register(handler);\n            if (!(registrationResolver instanceof Object) ||\n                registrationResolver.resolve == null) {\n                const newResolver = handler.resolvers.get(keyAsValue);\n                if (newResolver != void 0) {\n                    return newResolver;\n                }\n                throw new Error(\"A valid resolver was not returned from the static register method\");\n            }\n            return registrationResolver;\n        }\n        else if (keyAsValue.$isInterface) {\n            throw new Error(`Attempted to jitRegister an interface: ${keyAsValue.friendlyName}`);\n        }\n        else {\n            const resolver = this.config.defaultResolver(keyAsValue, handler);\n            handler.resolvers.set(keyAsValue, resolver);\n            return resolver;\n        }\n    }\n}\nconst cache = new WeakMap();\nfunction cacheCallbackResult(fun) {\n    return function (handler, requestor, resolver) {\n        if (cache.has(resolver)) {\n            return cache.get(resolver);\n        }\n        const t = fun(handler, requestor, resolver);\n        cache.set(resolver, t);\n        return t;\n    };\n}\n/**\n * You can use the resulting Registration of any of the factory methods\n * to register with the container.\n *\n * @example\n * ```\n * class Foo {}\n * const container = DI.createContainer();\n * container.register(Registration.instance(Foo, new Foo()));\n * container.get(Foo);\n * ```\n *\n * @public\n */\nexport const Registration = Object.freeze({\n    /**\n     * Allows you to pass an instance.\n     * Every time you request this {@link Key} you will get this instance back.\n     *\n     * @example\n     * ```\n     * Registration.instance(Foo, new Foo()));\n     * ```\n     *\n     * @param key - The key to register the instance under.\n     * @param value - The instance to return when the key is requested.\n     */\n    instance(key, value) {\n        return new ResolverImpl(key, 0 /* instance */, value);\n    },\n    /**\n     * Creates an instance from the class.\n     * Every time you request this {@link Key} you will get the same one back.\n     *\n     * @example\n     * ```\n     * Registration.singleton(Foo, Foo);\n     * ```\n     *\n     * @param key - The key to register the singleton under.\n     * @param value - The class to instantiate as a singleton when first requested.\n     */\n    singleton(key, value) {\n        return new ResolverImpl(key, 1 /* singleton */, value);\n    },\n    /**\n     * Creates an instance from a class.\n     * Every time you request this {@link Key} you will get a new instance.\n     *\n     * @example\n     * ```\n     * Registration.instance(Foo, Foo);\n     * ```\n     *\n     * @param key - The key to register the instance type under.\n     * @param value - The class to instantiate each time the key is requested.\n     */\n    transient(key, value) {\n        return new ResolverImpl(key, 2 /* transient */, value);\n    },\n    /**\n     * Delegates to a callback function to provide the dependency.\n     * Every time you request this {@link Key} the callback will be invoked to provide\n     * the dependency.\n     *\n     * @example\n     * ```\n     * Registration.callback(Foo, () => new Foo());\n     * Registration.callback(Bar, (c: Container) => new Bar(c.get(Foo)));\n     * ```\n     *\n     * @param key - The key to register the callback for.\n     * @param callback - The function that is expected to return the dependency.\n     */\n    callback(key, callback) {\n        return new ResolverImpl(key, 3 /* callback */, callback);\n    },\n    /**\n     * Delegates to a callback function to provide the dependency and then caches the\n     * dependency for future requests.\n     *\n     * @example\n     * ```\n     * Registration.cachedCallback(Foo, () => new Foo());\n     * Registration.cachedCallback(Bar, (c: Container) => new Bar(c.get(Foo)));\n     * ```\n     *\n     * @param key - The key to register the callback for.\n     * @param callback - The function that is expected to return the dependency.\n     * @remarks\n     * If you pass the same Registration to another container, the same cached value will be used.\n     * Should all references to the resolver returned be removed, the cache will expire.\n     */\n    cachedCallback(key, callback) {\n        return new ResolverImpl(key, 3 /* callback */, cacheCallbackResult(callback));\n    },\n    /**\n     * Creates an alternate {@link Key} to retrieve an instance by.\n     *\n     * @example\n     * ```\n     * Register.singleton(Foo, Foo)\n     * Register.aliasTo(Foo, MyFoos);\n     *\n     * container.getAll(MyFoos) // contains an instance of Foo\n     * ```\n     *\n     * @param originalKey - The original key that has been registered.\n     * @param aliasKey - The alias to the original key.\n     */\n    aliasTo(originalKey, aliasKey) {\n        return new ResolverImpl(aliasKey, 5 /* alias */, originalKey);\n    },\n});\n/** @internal */\nexport function validateKey(key) {\n    if (key === null || key === void 0) {\n        throw new Error(\"key/value cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?\");\n    }\n}\nfunction buildAllResponse(resolver, handler, requestor) {\n    if (resolver instanceof ResolverImpl &&\n        resolver.strategy === 4 /* array */) {\n        const state = resolver.state;\n        let i = state.length;\n        const results = new Array(i);\n        while (i--) {\n            results[i] = state[i].resolve(handler, requestor);\n        }\n        return results;\n    }\n    return [resolver.resolve(handler, requestor)];\n}\nconst defaultFriendlyName = \"(anonymous)\";\nfunction isObject(value) {\n    return (typeof value === \"object\" && value !== null) || typeof value === \"function\";\n}\n/**\n * Determine whether the value is a native function.\n *\n * @param fn - The function to check.\n * @returns `true` is the function is a native function, otherwise `false`\n */\nconst isNativeFunction = (function () {\n    const lookup = new WeakMap();\n    let isNative = false;\n    let sourceText = \"\";\n    let i = 0;\n    return function (fn) {\n        isNative = lookup.get(fn);\n        if (isNative === void 0) {\n            sourceText = fn.toString();\n            i = sourceText.length;\n            // http://www.ecma-international.org/ecma-262/#prod-NativeFunction\n            isNative =\n                // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string\n                i >= 29 &&\n                    // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.\n                    i <= 100 &&\n                    // This whole heuristic *could* be tricked by a comment. Do we need to care about that?\n                    sourceText.charCodeAt(i - 1) === 0x7d && // }\n                    // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.\n                    sourceText.charCodeAt(i - 2) <= 0x20 && // whitespace\n                    sourceText.charCodeAt(i - 3) === 0x5d && // ]\n                    sourceText.charCodeAt(i - 4) === 0x65 && // e\n                    sourceText.charCodeAt(i - 5) === 0x64 && // d\n                    sourceText.charCodeAt(i - 6) === 0x6f && // o\n                    sourceText.charCodeAt(i - 7) === 0x63 && // c\n                    sourceText.charCodeAt(i - 8) === 0x20 && //\n                    sourceText.charCodeAt(i - 9) === 0x65 && // e\n                    sourceText.charCodeAt(i - 10) === 0x76 && // v\n                    sourceText.charCodeAt(i - 11) === 0x69 && // i\n                    sourceText.charCodeAt(i - 12) === 0x74 && // t\n                    sourceText.charCodeAt(i - 13) === 0x61 && // a\n                    sourceText.charCodeAt(i - 14) === 0x6e && // n\n                    sourceText.charCodeAt(i - 15) === 0x58; // [\n            lookup.set(fn, isNative);\n        }\n        return isNative;\n    };\n})();\nconst isNumericLookup = {};\nfunction isArrayIndex(value) {\n    switch (typeof value) {\n        case \"number\":\n            return value >= 0 && (value | 0) === value;\n        case \"string\": {\n            const result = isNumericLookup[value];\n            if (result !== void 0) {\n                return result;\n            }\n            const length = value.length;\n            if (length === 0) {\n                return (isNumericLookup[value] = false);\n            }\n            let ch = 0;\n            for (let i = 0; i < length; ++i) {\n                ch = value.charCodeAt(i);\n                if ((i === 0 && ch === 0x30 && length > 1) /* must not start with 0 */ ||\n                    ch < 0x30 /* 0 */ ||\n                    ch > 0x39 /* 9 */) {\n                    return (isNumericLookup[value] = false);\n                }\n            }\n            return (isNumericLookup[value] = true);\n        }\n        default:\n            return false;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}