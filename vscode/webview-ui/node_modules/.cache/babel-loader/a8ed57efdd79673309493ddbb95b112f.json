{"ast":null,"code":"import { FASTElementDefinition } from \"@microsoft/fast-element\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\nimport { DI, Registration } from \"../di/di.js\";\nimport { DesignToken } from \"../design-token/design-token.js\";\nimport { ComponentPresentation } from \"./component-presentation.js\";\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\n/**\n * Indicates what to do with an ambiguous (duplicate) element.\n * @public\n */\n\nexport const ElementDisambiguation = Object.freeze({\n  /**\n   * Skip defining the element but still call the provided callback passed\n   * to DesignSystemRegistrationContext.tryDefineElement\n   */\n  definitionCallbackOnly: null,\n\n  /**\n   * Ignore the duplicate element entirely.\n   */\n  ignoreDuplicate: Symbol()\n});\nconst elementTypesByTag = new Map();\nconst elementTagsByType = new Map();\nlet rootDesignSystem = null;\nconst designSystemKey = DI.createInterface(x => x.cachedCallback(handler => {\n  if (rootDesignSystem === null) {\n    rootDesignSystem = new DefaultDesignSystem(null, handler);\n  }\n\n  return rootDesignSystem;\n}));\n/**\n * An API gateway to design system features.\n * @public\n */\n\nexport const DesignSystem = Object.freeze({\n  /**\n   * Returns the HTML element name that the type is defined as.\n   * @param type - The type to lookup.\n   * @public\n   */\n  tagFor(type) {\n    return elementTagsByType.get(type);\n  },\n\n  /**\n   * Searches the DOM hierarchy for the design system that is responsible\n   * for the provided element.\n   * @param element - The element to locate the design system for.\n   * @returns The located design system.\n   * @public\n   */\n  responsibleFor(element) {\n    const owned = element.$$designSystem$$;\n\n    if (owned) {\n      return owned;\n    }\n\n    const container = DI.findResponsibleContainer(element);\n    return container.get(designSystemKey);\n  },\n\n  /**\n   * Gets the DesignSystem if one is explicitly defined on the provided element;\n   * otherwise creates a design system defined directly on the element.\n   * @param element - The element to get or create a design system for.\n   * @returns The design system.\n   * @public\n   */\n  getOrCreate(node) {\n    if (!node) {\n      if (rootDesignSystem === null) {\n        rootDesignSystem = DI.getOrCreateDOMContainer().get(designSystemKey);\n      }\n\n      return rootDesignSystem;\n    }\n\n    const owned = node.$$designSystem$$;\n\n    if (owned) {\n      return owned;\n    }\n\n    const container = DI.getOrCreateDOMContainer(node);\n\n    if (container.has(designSystemKey, false)) {\n      return container.get(designSystemKey);\n    } else {\n      const system = new DefaultDesignSystem(node, container);\n      container.register(Registration.instance(designSystemKey, system));\n      return system;\n    }\n  }\n\n});\n\nfunction extractTryDefineElementParams(params, elementDefinitionType, elementDefinitionCallback) {\n  if (typeof params === \"string\") {\n    return {\n      name: params,\n      type: elementDefinitionType,\n      callback: elementDefinitionCallback\n    };\n  } else {\n    return params;\n  }\n}\n\nclass DefaultDesignSystem {\n  constructor(owner, container) {\n    this.owner = owner;\n    this.container = container;\n    this.designTokensInitialized = false;\n    this.prefix = \"fast\";\n    this.shadowRootMode = undefined;\n\n    this.disambiguate = () => ElementDisambiguation.definitionCallbackOnly;\n\n    if (owner !== null) {\n      owner.$$designSystem$$ = this;\n    }\n  }\n\n  withPrefix(prefix) {\n    this.prefix = prefix;\n    return this;\n  }\n\n  withShadowRootMode(mode) {\n    this.shadowRootMode = mode;\n    return this;\n  }\n\n  withElementDisambiguation(callback) {\n    this.disambiguate = callback;\n    return this;\n  }\n\n  withDesignTokenRoot(root) {\n    this.designTokenRoot = root;\n    return this;\n  }\n\n  register() {\n    const container = this.container;\n    const elementDefinitionEntries = [];\n    const disambiguate = this.disambiguate;\n    const shadowRootMode = this.shadowRootMode;\n    const context = {\n      elementPrefix: this.prefix,\n\n      tryDefineElement(params, elementDefinitionType, elementDefinitionCallback) {\n        const extractedParams = extractTryDefineElementParams(params, elementDefinitionType, elementDefinitionCallback);\n        const {\n          name,\n          callback,\n          baseClass\n        } = extractedParams;\n        let {\n          type\n        } = extractedParams;\n        let elementName = name;\n        let typeFoundByName = elementTypesByTag.get(elementName);\n        let needsDefine = true;\n\n        while (typeFoundByName) {\n          const result = disambiguate(elementName, type, typeFoundByName);\n\n          switch (result) {\n            case ElementDisambiguation.ignoreDuplicate:\n              return;\n\n            case ElementDisambiguation.definitionCallbackOnly:\n              needsDefine = false;\n              typeFoundByName = void 0;\n              break;\n\n            default:\n              elementName = result;\n              typeFoundByName = elementTypesByTag.get(elementName);\n              break;\n          }\n        }\n\n        if (needsDefine) {\n          if (elementTagsByType.has(type) || type === FoundationElement) {\n            type = class extends type {};\n          }\n\n          elementTypesByTag.set(elementName, type);\n          elementTagsByType.set(type, elementName);\n\n          if (baseClass) {\n            elementTagsByType.set(baseClass, elementName);\n          }\n        }\n\n        elementDefinitionEntries.push(new ElementDefinitionEntry(container, elementName, type, shadowRootMode, callback, needsDefine));\n      }\n\n    };\n\n    if (!this.designTokensInitialized) {\n      this.designTokensInitialized = true;\n\n      if (this.designTokenRoot !== null) {\n        DesignToken.registerRoot(this.designTokenRoot);\n      }\n    }\n\n    for (var _len = arguments.length, registrations = new Array(_len), _key = 0; _key < _len; _key++) {\n      registrations[_key] = arguments[_key];\n    }\n\n    container.registerWithContext(context, ...registrations);\n\n    for (const entry of elementDefinitionEntries) {\n      entry.callback(entry);\n\n      if (entry.willDefine && entry.definition !== null) {\n        entry.definition.define();\n      }\n    }\n\n    return this;\n  }\n\n}\n\nclass ElementDefinitionEntry {\n  constructor(container, name, type, shadowRootMode, callback, willDefine) {\n    this.container = container;\n    this.name = name;\n    this.type = type;\n    this.shadowRootMode = shadowRootMode;\n    this.callback = callback;\n    this.willDefine = willDefine;\n    this.definition = null;\n  }\n\n  definePresentation(presentation) {\n    ComponentPresentation.define(this.name, presentation, this.container);\n  }\n\n  defineElement(definition) {\n    this.definition = new FASTElementDefinition(this.type, Object.assign(Object.assign({}, definition), {\n      name: this.name\n    }));\n  }\n\n  tagFor(type) {\n    return DesignSystem.tagFor(type);\n  }\n\n}\n/* eslint-enable @typescript-eslint/no-non-null-assertion */","map":{"version":3,"names":["FASTElementDefinition","FoundationElement","DI","Registration","DesignToken","ComponentPresentation","ElementDisambiguation","Object","freeze","definitionCallbackOnly","ignoreDuplicate","Symbol","elementTypesByTag","Map","elementTagsByType","rootDesignSystem","designSystemKey","createInterface","x","cachedCallback","handler","DefaultDesignSystem","DesignSystem","tagFor","type","get","responsibleFor","element","owned","$$designSystem$$","container","findResponsibleContainer","getOrCreate","node","getOrCreateDOMContainer","has","system","register","instance","extractTryDefineElementParams","params","elementDefinitionType","elementDefinitionCallback","name","callback","constructor","owner","designTokensInitialized","prefix","shadowRootMode","undefined","disambiguate","withPrefix","withShadowRootMode","mode","withElementDisambiguation","withDesignTokenRoot","root","designTokenRoot","elementDefinitionEntries","context","elementPrefix","tryDefineElement","extractedParams","baseClass","elementName","typeFoundByName","needsDefine","result","set","push","ElementDefinitionEntry","registerRoot","registrations","registerWithContext","entry","willDefine","definition","define","definePresentation","presentation","defineElement","assign"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/design-system/design-system.js"],"sourcesContent":["import { FASTElementDefinition } from \"@microsoft/fast-element\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\nimport { DI, Registration } from \"../di/di.js\";\nimport { DesignToken } from \"../design-token/design-token.js\";\nimport { ComponentPresentation } from \"./component-presentation.js\";\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/**\n * Indicates what to do with an ambiguous (duplicate) element.\n * @public\n */\nexport const ElementDisambiguation = Object.freeze({\n    /**\n     * Skip defining the element but still call the provided callback passed\n     * to DesignSystemRegistrationContext.tryDefineElement\n     */\n    definitionCallbackOnly: null,\n    /**\n     * Ignore the duplicate element entirely.\n     */\n    ignoreDuplicate: Symbol(),\n});\nconst elementTypesByTag = new Map();\nconst elementTagsByType = new Map();\nlet rootDesignSystem = null;\nconst designSystemKey = DI.createInterface(x => x.cachedCallback(handler => {\n    if (rootDesignSystem === null) {\n        rootDesignSystem = new DefaultDesignSystem(null, handler);\n    }\n    return rootDesignSystem;\n}));\n/**\n * An API gateway to design system features.\n * @public\n */\nexport const DesignSystem = Object.freeze({\n    /**\n     * Returns the HTML element name that the type is defined as.\n     * @param type - The type to lookup.\n     * @public\n     */\n    tagFor(type) {\n        return elementTagsByType.get(type);\n    },\n    /**\n     * Searches the DOM hierarchy for the design system that is responsible\n     * for the provided element.\n     * @param element - The element to locate the design system for.\n     * @returns The located design system.\n     * @public\n     */\n    responsibleFor(element) {\n        const owned = element.$$designSystem$$;\n        if (owned) {\n            return owned;\n        }\n        const container = DI.findResponsibleContainer(element);\n        return container.get(designSystemKey);\n    },\n    /**\n     * Gets the DesignSystem if one is explicitly defined on the provided element;\n     * otherwise creates a design system defined directly on the element.\n     * @param element - The element to get or create a design system for.\n     * @returns The design system.\n     * @public\n     */\n    getOrCreate(node) {\n        if (!node) {\n            if (rootDesignSystem === null) {\n                rootDesignSystem = DI.getOrCreateDOMContainer().get(designSystemKey);\n            }\n            return rootDesignSystem;\n        }\n        const owned = node.$$designSystem$$;\n        if (owned) {\n            return owned;\n        }\n        const container = DI.getOrCreateDOMContainer(node);\n        if (container.has(designSystemKey, false)) {\n            return container.get(designSystemKey);\n        }\n        else {\n            const system = new DefaultDesignSystem(node, container);\n            container.register(Registration.instance(designSystemKey, system));\n            return system;\n        }\n    },\n});\nfunction extractTryDefineElementParams(params, elementDefinitionType, elementDefinitionCallback) {\n    if (typeof params === \"string\") {\n        return {\n            name: params,\n            type: elementDefinitionType,\n            callback: elementDefinitionCallback,\n        };\n    }\n    else {\n        return params;\n    }\n}\nclass DefaultDesignSystem {\n    constructor(owner, container) {\n        this.owner = owner;\n        this.container = container;\n        this.designTokensInitialized = false;\n        this.prefix = \"fast\";\n        this.shadowRootMode = undefined;\n        this.disambiguate = () => ElementDisambiguation.definitionCallbackOnly;\n        if (owner !== null) {\n            owner.$$designSystem$$ = this;\n        }\n    }\n    withPrefix(prefix) {\n        this.prefix = prefix;\n        return this;\n    }\n    withShadowRootMode(mode) {\n        this.shadowRootMode = mode;\n        return this;\n    }\n    withElementDisambiguation(callback) {\n        this.disambiguate = callback;\n        return this;\n    }\n    withDesignTokenRoot(root) {\n        this.designTokenRoot = root;\n        return this;\n    }\n    register(...registrations) {\n        const container = this.container;\n        const elementDefinitionEntries = [];\n        const disambiguate = this.disambiguate;\n        const shadowRootMode = this.shadowRootMode;\n        const context = {\n            elementPrefix: this.prefix,\n            tryDefineElement(params, elementDefinitionType, elementDefinitionCallback) {\n                const extractedParams = extractTryDefineElementParams(params, elementDefinitionType, elementDefinitionCallback);\n                const { name, callback, baseClass } = extractedParams;\n                let { type } = extractedParams;\n                let elementName = name;\n                let typeFoundByName = elementTypesByTag.get(elementName);\n                let needsDefine = true;\n                while (typeFoundByName) {\n                    const result = disambiguate(elementName, type, typeFoundByName);\n                    switch (result) {\n                        case ElementDisambiguation.ignoreDuplicate:\n                            return;\n                        case ElementDisambiguation.definitionCallbackOnly:\n                            needsDefine = false;\n                            typeFoundByName = void 0;\n                            break;\n                        default:\n                            elementName = result;\n                            typeFoundByName = elementTypesByTag.get(elementName);\n                            break;\n                    }\n                }\n                if (needsDefine) {\n                    if (elementTagsByType.has(type) || type === FoundationElement) {\n                        type = class extends type {\n                        };\n                    }\n                    elementTypesByTag.set(elementName, type);\n                    elementTagsByType.set(type, elementName);\n                    if (baseClass) {\n                        elementTagsByType.set(baseClass, elementName);\n                    }\n                }\n                elementDefinitionEntries.push(new ElementDefinitionEntry(container, elementName, type, shadowRootMode, callback, needsDefine));\n            },\n        };\n        if (!this.designTokensInitialized) {\n            this.designTokensInitialized = true;\n            if (this.designTokenRoot !== null) {\n                DesignToken.registerRoot(this.designTokenRoot);\n            }\n        }\n        container.registerWithContext(context, ...registrations);\n        for (const entry of elementDefinitionEntries) {\n            entry.callback(entry);\n            if (entry.willDefine && entry.definition !== null) {\n                entry.definition.define();\n            }\n        }\n        return this;\n    }\n}\nclass ElementDefinitionEntry {\n    constructor(container, name, type, shadowRootMode, callback, willDefine) {\n        this.container = container;\n        this.name = name;\n        this.type = type;\n        this.shadowRootMode = shadowRootMode;\n        this.callback = callback;\n        this.willDefine = willDefine;\n        this.definition = null;\n    }\n    definePresentation(presentation) {\n        ComponentPresentation.define(this.name, presentation, this.container);\n    }\n    defineElement(definition) {\n        this.definition = new FASTElementDefinition(this.type, Object.assign(Object.assign({}, definition), { name: this.name }));\n    }\n    tagFor(type) {\n        return DesignSystem.tagFor(type);\n    }\n}\n/* eslint-enable @typescript-eslint/no-non-null-assertion */\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}