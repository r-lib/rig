{"ast":null,"code":"import _slicedToArray from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __decorate } from \"tslib\";\nimport { CSSDirective, defaultExecutionContext, FASTElement, observable, Observable } from \"@microsoft/fast-element\";\nimport { composedParent } from \"../utilities/composed-parent.js\";\nimport { composedContains } from \"../utilities/composed-contains.js\";\nimport { PropertyTargetManager, RootStyleSheetTarget } from \"./custom-property-manager.js\";\nimport { defaultElement } from \"./custom-property-manager.js\";\n/**\n * Implementation of {@link (DesignToken:interface)}\n */\n\nvar DesignTokenImpl = /*#__PURE__*/function (_CSSDirective) {\n  _inherits(DesignTokenImpl, _CSSDirective);\n\n  var _super = _createSuper(DesignTokenImpl);\n\n  function DesignTokenImpl(configuration) {\n    var _this;\n\n    _classCallCheck(this, DesignTokenImpl);\n\n    _this = _super.call(this);\n    _this.subscribers = new WeakMap();\n    _this._appliedTo = new Set();\n    _this.name = configuration.name;\n\n    if (configuration.cssCustomPropertyName !== null) {\n      _this.cssCustomProperty = \"--\".concat(configuration.cssCustomPropertyName);\n      _this.cssVar = \"var(\".concat(_this.cssCustomProperty, \")\");\n    }\n\n    _this.id = DesignTokenImpl.uniqueId();\n    DesignTokenImpl.tokensById.set(_this.id, _assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(DesignTokenImpl, [{\n    key: \"appliedTo\",\n    get: function get() {\n      return _toConsumableArray(this._appliedTo);\n    }\n  }, {\n    key: \"getOrCreateSubscriberSet\",\n    value: function getOrCreateSubscriberSet() {\n      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\n      return this.subscribers.get(target) || this.subscribers.set(target, new Set()) && this.subscribers.get(target);\n    }\n  }, {\n    key: \"createCSS\",\n    value: function createCSS() {\n      return this.cssVar || \"\";\n    }\n  }, {\n    key: \"getValueFor\",\n    value: function getValueFor(element) {\n      var value = DesignTokenNode.getOrCreate(element).get(this);\n\n      if (value !== undefined) {\n        return value;\n      }\n\n      throw new Error(\"Value could not be retrieved for token named \\\"\".concat(this.name, \"\\\". Ensure the value is set for \").concat(element, \" or an ancestor of \").concat(element, \".\"));\n    }\n  }, {\n    key: \"setValueFor\",\n    value: function setValueFor(element, value) {\n      this._appliedTo.add(element);\n\n      if (value instanceof DesignTokenImpl) {\n        value = this.alias(value);\n      }\n\n      DesignTokenNode.getOrCreate(element).set(this, value);\n      return this;\n    }\n  }, {\n    key: \"deleteValueFor\",\n    value: function deleteValueFor(element) {\n      this._appliedTo.delete(element);\n\n      if (DesignTokenNode.existsFor(element)) {\n        DesignTokenNode.getOrCreate(element).delete(this);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"withDefault\",\n    value: function withDefault(value) {\n      this.setValueFor(defaultElement, value);\n      return this;\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(subscriber, target) {\n      var subscriberSet = this.getOrCreateSubscriberSet(target);\n\n      if (target && !DesignTokenNode.existsFor(target)) {\n        DesignTokenNode.getOrCreate(target);\n      }\n\n      if (!subscriberSet.has(subscriber)) {\n        subscriberSet.add(subscriber);\n      }\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(subscriber, target) {\n      var list = this.subscribers.get(target || this);\n\n      if (list && list.has(subscriber)) {\n        list.delete(subscriber);\n      }\n    }\n    /**\n     * Notifies subscribers that the value for an element has changed.\n     * @param element - The element to emit a notification for\n     */\n\n  }, {\n    key: \"notify\",\n    value: function notify(element) {\n      var record = Object.freeze({\n        token: this,\n        target: element\n      });\n\n      if (this.subscribers.has(this)) {\n        this.subscribers.get(this).forEach(function (sub) {\n          return sub.handleChange(record);\n        });\n      }\n\n      if (this.subscribers.has(element)) {\n        this.subscribers.get(element).forEach(function (sub) {\n          return sub.handleChange(record);\n        });\n      }\n    }\n    /**\n     * Alias the token to the provided token.\n     * @param token - the token to alias to\n     */\n\n  }, {\n    key: \"alias\",\n    value: function alias(token) {\n      return function (target) {\n        return token.getValueFor(target);\n      };\n    }\n  }], [{\n    key: \"from\",\n    value: function from(nameOrConfig) {\n      return new DesignTokenImpl({\n        name: typeof nameOrConfig === \"string\" ? nameOrConfig : nameOrConfig.name,\n        cssCustomPropertyName: typeof nameOrConfig === \"string\" ? nameOrConfig : nameOrConfig.cssCustomPropertyName === void 0 ? nameOrConfig.name : nameOrConfig.cssCustomPropertyName\n      });\n    }\n  }, {\n    key: \"isCSSDesignToken\",\n    value: function isCSSDesignToken(token) {\n      return typeof token.cssCustomProperty === \"string\";\n    }\n  }, {\n    key: \"isDerivedDesignTokenValue\",\n    value: function isDerivedDesignTokenValue(value) {\n      return typeof value === \"function\";\n    }\n    /**\n     * Gets a token by ID. Returns undefined if the token was not found.\n     * @param id - The ID of the token\n     * @returns\n     */\n\n  }, {\n    key: \"getTokenById\",\n    value: function getTokenById(id) {\n      return DesignTokenImpl.tokensById.get(id);\n    }\n  }]);\n\n  return DesignTokenImpl;\n}(CSSDirective);\n\nDesignTokenImpl.uniqueId = function () {\n  var id = 0;\n  return function () {\n    id++;\n    return id.toString(16);\n  };\n}();\n/**\n * Token storage by token ID\n */\n\n\nDesignTokenImpl.tokensById = new Map();\n\nvar CustomPropertyReflector = /*#__PURE__*/function () {\n  function CustomPropertyReflector() {\n    _classCallCheck(this, CustomPropertyReflector);\n  }\n\n  _createClass(CustomPropertyReflector, [{\n    key: \"startReflection\",\n    value: function startReflection(token, target) {\n      token.subscribe(this, target);\n      this.handleChange({\n        token: token,\n        target: target\n      });\n    }\n  }, {\n    key: \"stopReflection\",\n    value: function stopReflection(token, target) {\n      token.unsubscribe(this, target);\n      this.remove(token, target);\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(record) {\n      var token = record.token,\n          target = record.target;\n      this.add(token, target);\n    }\n  }, {\n    key: \"add\",\n    value: function add(token, target) {\n      PropertyTargetManager.getOrCreate(target).setProperty(token.cssCustomProperty, this.resolveCSSValue(DesignTokenNode.getOrCreate(target).get(token)));\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(token, target) {\n      PropertyTargetManager.getOrCreate(target).removeProperty(token.cssCustomProperty);\n    }\n  }, {\n    key: \"resolveCSSValue\",\n    value: function resolveCSSValue(value) {\n      return value && typeof value.createCSS === \"function\" ? value.createCSS() : value;\n    }\n  }]);\n\n  return CustomPropertyReflector;\n}();\n/**\n * A light wrapper around BindingObserver to handle value caching and\n * token notification\n */\n\n\nvar DesignTokenBindingObserver = /*#__PURE__*/function () {\n  function DesignTokenBindingObserver(source, token, node) {\n    _classCallCheck(this, DesignTokenBindingObserver);\n\n    this.source = source;\n    this.token = token;\n    this.node = node;\n    this.dependencies = new Set();\n    this.observer = Observable.binding(source, this, false); // This is a little bit hacky because it's using internal APIs of BindingObserverImpl.\n    // BindingObserverImpl queues updates to batch it's notifications which doesn't work for this\n    // scenario because the DesignToken.getValueFor API is not async. Without this, using DesignToken.getValueFor()\n    // after DesignToken.setValueFor() when setting a dependency of the value being retrieved can return a stale\n    // value. Assigning .handleChange to .call forces immediate invocation of this classes handleChange() method,\n    // allowing resolution of values synchronously.\n    // TODO: https://github.com/microsoft/fast/issues/5110\n\n    this.observer.handleChange = this.observer.call;\n    this.handleChange();\n  }\n\n  _createClass(DesignTokenBindingObserver, [{\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.observer.disconnect();\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      this.node.store.set(this.token, this.observer.observe(this.node.target, defaultExecutionContext));\n    }\n  }]);\n\n  return DesignTokenBindingObserver;\n}();\n/**\n * Stores resolved token/value pairs and notifies on changes\n */\n\n\nvar Store = /*#__PURE__*/function () {\n  function Store() {\n    _classCallCheck(this, Store);\n\n    this.values = new Map();\n  }\n\n  _createClass(Store, [{\n    key: \"set\",\n    value: function set(token, value) {\n      if (this.values.get(token) !== value) {\n        this.values.set(token, value);\n        Observable.getNotifier(this).notify(token.id);\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get(token) {\n      Observable.track(this, token.id);\n      return this.values.get(token);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(token) {\n      this.values.delete(token);\n    }\n  }, {\n    key: \"all\",\n    value: function all() {\n      return this.values.entries();\n    }\n  }]);\n\n  return Store;\n}();\n\nvar nodeCache = new WeakMap();\nvar childToParent = new WeakMap();\n/**\n * A node responsible for setting and getting token values,\n * emitting values to CSS custom properties, and maintaining\n * inheritance structures.\n */\n\nvar DesignTokenNode = /*#__PURE__*/function () {\n  function DesignTokenNode(target) {\n    var _this2 = this;\n\n    _classCallCheck(this, DesignTokenNode);\n\n    this.target = target;\n    /**\n     * Stores all resolved token values for a node\n     */\n\n    this.store = new Store();\n    /**\n     * All children assigned to the node\n     */\n\n    this.children = [];\n    /**\n     * All values explicitly assigned to the node in their raw form\n     */\n\n    this.assignedValues = new Map();\n    /**\n     * Tokens currently being reflected to CSS custom properties\n     */\n\n    this.reflecting = new Set();\n    /**\n     * Binding observers for assigned and inherited derived values.\n     */\n\n    this.bindingObservers = new Map();\n    /**\n     * Emits notifications to token when token values\n     * change the DesignTokenNode\n     */\n\n    this.tokenValueChangeHandler = {\n      handleChange: function handleChange(source, arg) {\n        var token = DesignTokenImpl.getTokenById(arg);\n\n        if (token) {\n          // Notify any token subscribers\n          token.notify(_this2.target);\n\n          if (DesignTokenImpl.isCSSDesignToken(token)) {\n            var parent = _this2.parent;\n\n            var reflecting = _this2.isReflecting(token);\n\n            if (parent) {\n              var parentValue = parent.get(token);\n              var sourceValue = source.get(token);\n\n              if (parentValue !== sourceValue && !reflecting) {\n                _this2.reflectToCSS(token);\n              } else if (parentValue === sourceValue && reflecting) {\n                _this2.stopReflectToCSS(token);\n              }\n            } else if (!reflecting) {\n              _this2.reflectToCSS(token);\n            }\n          }\n        }\n      }\n    };\n    nodeCache.set(target, this); // Map store change notifications to token change notifications\n\n    Observable.getNotifier(this.store).subscribe(this.tokenValueChangeHandler);\n\n    if (target instanceof FASTElement) {\n      target.$fastController.addBehaviors([this]);\n    } else if (target.isConnected) {\n      this.bind();\n    }\n  }\n  /**\n   * Returns a DesignTokenNode for an element.\n   * Creates a new instance if one does not already exist for a node,\n   * otherwise returns the cached instance\n   *\n   * @param target - The HTML element to retrieve a DesignTokenNode for\n   */\n\n\n  _createClass(DesignTokenNode, [{\n    key: \"parent\",\n    get:\n    /**\n     * The parent DesignTokenNode, or null.\n     */\n    function get() {\n      return childToParent.get(this) || null;\n    }\n    /**\n     * Checks if a token has been assigned an explicit value the node.\n     * @param token - the token to check.\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(token) {\n      return this.assignedValues.has(token);\n    }\n    /**\n     * Gets the value of a token for a node\n     * @param token - The token to retrieve the value for\n     * @returns\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(token) {\n      var value = this.store.get(token);\n\n      if (value !== undefined) {\n        return value;\n      }\n\n      var raw = this.getRaw(token);\n\n      if (raw !== undefined) {\n        this.hydrate(token, raw);\n        return this.get(token);\n      }\n    }\n    /**\n     * Retrieves the raw assigned value of a token from the nearest assigned node.\n     * @param token - The token to retrieve a raw value for\n     * @returns\n     */\n\n  }, {\n    key: \"getRaw\",\n    value: function getRaw(token) {\n      var _a;\n\n      if (this.assignedValues.has(token)) {\n        return this.assignedValues.get(token);\n      }\n\n      return (_a = DesignTokenNode.findClosestAssignedNode(token, this)) === null || _a === void 0 ? void 0 : _a.getRaw(token);\n    }\n    /**\n     * Sets a token to a value for a node\n     * @param token - The token to set\n     * @param value - The value to set the token to\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(token, value) {\n      if (DesignTokenImpl.isDerivedDesignTokenValue(this.assignedValues.get(token))) {\n        this.tearDownBindingObserver(token);\n      }\n\n      this.assignedValues.set(token, value);\n\n      if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {\n        this.setupBindingObserver(token, value);\n      } else {\n        this.store.set(token, value);\n      }\n    }\n    /**\n     * Deletes a token value for the node.\n     * @param token - The token to delete the value for\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(token) {\n      this.assignedValues.delete(token);\n      this.tearDownBindingObserver(token);\n      var upstream = this.getRaw(token);\n\n      if (upstream) {\n        this.hydrate(token, upstream);\n      } else {\n        this.store.delete(token);\n      }\n    }\n    /**\n     * Invoked when the DesignTokenNode.target is attached to the document\n     */\n\n  }, {\n    key: \"bind\",\n    value: function bind() {\n      var parent = DesignTokenNode.findParent(this);\n\n      if (parent) {\n        parent.appendChild(this);\n      }\n\n      var _iterator = _createForOfIteratorHelper(this.assignedValues.keys()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          key.notify(this.target);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Invoked when the DesignTokenNode.target is detached from the document\n     */\n\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      if (this.parent) {\n        var parent = childToParent.get(this);\n        parent.removeChild(this);\n      }\n    }\n    /**\n     * Appends a child to a parent DesignTokenNode.\n     * @param child - The child to append to the node\n     */\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(child) {\n      if (child.parent) {\n        childToParent.get(child).removeChild(child);\n      }\n\n      var reParent = this.children.filter(function (x) {\n        return child.contains(x);\n      });\n      childToParent.set(child, this);\n      this.children.push(child);\n      reParent.forEach(function (x) {\n        return child.appendChild(x);\n      });\n      Observable.getNotifier(this.store).subscribe(child); // How can we not notify *every* subscriber?\n\n      var _iterator2 = _createForOfIteratorHelper(this.store.all()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              token = _step2$value[0],\n              value = _step2$value[1];\n\n          child.hydrate(token, this.bindingObservers.has(token) ? this.getRaw(token) : value);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * Removes a child from a node.\n     * @param child - The child to remove.\n     */\n\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(child) {\n      var childIndex = this.children.indexOf(child);\n\n      if (childIndex !== -1) {\n        this.children.splice(childIndex, 1);\n      }\n\n      Observable.getNotifier(this.store).unsubscribe(child);\n      return child.parent === this ? childToParent.delete(child) : false;\n    }\n    /**\n     * Tests whether a provided node is contained by\n     * the calling node.\n     * @param test - The node to test\n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(test) {\n      return composedContains(this.target, test.target);\n    }\n    /**\n     * Instructs the node to reflect a design token for the provided token.\n     * @param token - The design token to reflect\n     */\n\n  }, {\n    key: \"reflectToCSS\",\n    value: function reflectToCSS(token) {\n      if (!this.isReflecting(token)) {\n        this.reflecting.add(token);\n        DesignTokenNode.cssCustomPropertyReflector.startReflection(token, this.target);\n      }\n    }\n    /**\n     * Stops reflecting a DesignToken to CSS\n     * @param token - The design token to stop reflecting\n     */\n\n  }, {\n    key: \"stopReflectToCSS\",\n    value: function stopReflectToCSS(token) {\n      if (this.isReflecting(token)) {\n        this.reflecting.delete(token);\n        DesignTokenNode.cssCustomPropertyReflector.stopReflection(token, this.target);\n      }\n    }\n    /**\n     * Determines if a token is being reflected to CSS for a node.\n     * @param token - The token to check for reflection\n     * @returns\n     */\n\n  }, {\n    key: \"isReflecting\",\n    value: function isReflecting(token) {\n      return this.reflecting.has(token);\n    }\n    /**\n     * Handle changes to upstream tokens\n     * @param source - The parent DesignTokenNode\n     * @param property - The token ID that changed\n     */\n\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(source, property) {\n      var token = DesignTokenImpl.getTokenById(property);\n\n      if (!token) {\n        return;\n      }\n\n      this.hydrate(token, this.getRaw(token));\n    }\n    /**\n     * Hydrates a token with a DesignTokenValue, making retrieval available.\n     * @param token - The token to hydrate\n     * @param value - The value to hydrate\n     */\n\n  }, {\n    key: \"hydrate\",\n    value: function hydrate(token, value) {\n      if (!this.has(token)) {\n        var observer = this.bindingObservers.get(token);\n\n        if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {\n          if (observer) {\n            // If the binding source doesn't match, we need\n            // to update the binding\n            if (observer.source !== value) {\n              this.tearDownBindingObserver(token);\n              this.setupBindingObserver(token, value);\n            }\n          } else {\n            this.setupBindingObserver(token, value);\n          }\n        } else {\n          if (observer) {\n            this.tearDownBindingObserver(token);\n          }\n\n          this.store.set(token, value);\n        }\n      }\n    }\n    /**\n     * Sets up a binding observer for a derived token value that notifies token\n     * subscribers on change.\n     *\n     * @param token - The token to notify when the binding updates\n     * @param source - The binding source\n     */\n\n  }, {\n    key: \"setupBindingObserver\",\n    value: function setupBindingObserver(token, source) {\n      var binding = new DesignTokenBindingObserver(source, token, this);\n      this.bindingObservers.set(token, binding);\n      return binding;\n    }\n    /**\n     * Tear down a binding observer for a token.\n     */\n\n  }, {\n    key: \"tearDownBindingObserver\",\n    value: function tearDownBindingObserver(token) {\n      if (this.bindingObservers.has(token)) {\n        this.bindingObservers.get(token).disconnect();\n        this.bindingObservers.delete(token);\n        return true;\n      }\n\n      return false;\n    }\n  }], [{\n    key: \"getOrCreate\",\n    value: function getOrCreate(target) {\n      return nodeCache.get(target) || new DesignTokenNode(target);\n    }\n    /**\n     * Determines if a DesignTokenNode has been created for a target\n     * @param target - The element to test\n     */\n\n  }, {\n    key: \"existsFor\",\n    value: function existsFor(target) {\n      return nodeCache.has(target);\n    }\n    /**\n     * Searches for and return the nearest parent DesignTokenNode.\n     * Null is returned if no node is found or the node provided is for a default element.\n     */\n\n  }, {\n    key: \"findParent\",\n    value: function findParent(node) {\n      if (!(defaultElement === node.target)) {\n        var parent = composedParent(node.target);\n\n        while (parent !== null) {\n          if (nodeCache.has(parent)) {\n            return nodeCache.get(parent);\n          }\n\n          parent = composedParent(parent);\n        }\n\n        return DesignTokenNode.getOrCreate(defaultElement);\n      }\n\n      return null;\n    }\n    /**\n     * Finds the closest node with a value explicitly assigned for a token, otherwise null.\n     * @param token - The token to look for\n     * @param start - The node to start looking for value assignment\n     * @returns\n     */\n\n  }, {\n    key: \"findClosestAssignedNode\",\n    value: function findClosestAssignedNode(token, start) {\n      var current = start;\n\n      do {\n        if (current.has(token)) {\n          return current;\n        }\n\n        current = current.parent ? current.parent : current.target !== defaultElement ? DesignTokenNode.getOrCreate(defaultElement) : null;\n      } while (current !== null);\n\n      return null;\n    }\n  }]);\n\n  return DesignTokenNode;\n}();\n/**\n * Responsible for reflecting tokens to CSS custom properties\n */\n\n\nDesignTokenNode.cssCustomPropertyReflector = new CustomPropertyReflector();\n\n__decorate([observable], DesignTokenNode.prototype, \"children\", void 0);\n\nfunction create(nameOrConfig) {\n  return DesignTokenImpl.from(nameOrConfig);\n}\n/* eslint-enable @typescript-eslint/no-unused-vars */\n\n/**\n * Factory object for creating {@link (DesignToken:interface)} instances.\n * @public\n */\n\n\nexport var DesignToken = Object.freeze({\n  create: create,\n\n  /**\n   * Informs DesignToken that an HTMLElement for which tokens have\n   * been set has been connected to the document.\n   *\n   * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness\n   * in all scenarios, so invoking this method manually is necessary when:\n   *\n   * 1. Token values are set for an HTMLElement.\n   * 2. The HTMLElement does not inherit from FASTElement.\n   * 3. The HTMLElement is not connected to the document when token values are set.\n   *\n   * @param element - The element to notify\n   * @returns - true if notification was successful, otherwise false.\n   */\n  notifyConnection: function notifyConnection(element) {\n    if (!element.isConnected || !DesignTokenNode.existsFor(element)) {\n      return false;\n    }\n\n    DesignTokenNode.getOrCreate(element).bind();\n    return true;\n  },\n\n  /**\n   * Informs DesignToken that an HTMLElement for which tokens have\n   * been set has been disconnected to the document.\n   *\n   * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness\n   * in all scenarios, so invoking this method manually is necessary when:\n   *\n   * 1. Token values are set for an HTMLElement.\n   * 2. The HTMLElement does not inherit from FASTElement.\n   *\n   * @param element - The element to notify\n   * @returns - true if notification was successful, otherwise false.\n   */\n  notifyDisconnection: function notifyDisconnection(element) {\n    if (element.isConnected || !DesignTokenNode.existsFor(element)) {\n      return false;\n    }\n\n    DesignTokenNode.getOrCreate(element).unbind();\n    return true;\n  },\n\n  /**\n   * Registers and element or document as a DesignToken root.\n   * {@link CSSDesignToken | CSSDesignTokens} with default values assigned via\n   * {@link (DesignToken:interface).withDefault} will emit CSS custom properties to all\n   * registered roots.\n   * @param target - The root to register\n   */\n  registerRoot: function registerRoot() {\n    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultElement;\n    RootStyleSheetTarget.registerRoot(target);\n  },\n\n  /**\n   * Unregister an element or document as a DesignToken root.\n   * @param target - The root to deregister\n   */\n  unregisterRoot: function unregisterRoot() {\n    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultElement;\n    RootStyleSheetTarget.unregisterRoot(target);\n  }\n});\n/* eslint-enable @typescript-eslint/no-non-null-assertion */","map":{"version":3,"names":["__decorate","CSSDirective","defaultExecutionContext","FASTElement","observable","Observable","composedParent","composedContains","PropertyTargetManager","RootStyleSheetTarget","defaultElement","DesignTokenImpl","configuration","subscribers","WeakMap","_appliedTo","Set","name","cssCustomPropertyName","cssCustomProperty","cssVar","id","uniqueId","tokensById","set","target","get","element","value","DesignTokenNode","getOrCreate","undefined","Error","add","alias","delete","existsFor","setValueFor","subscriber","subscriberSet","getOrCreateSubscriberSet","has","list","record","Object","freeze","token","forEach","sub","handleChange","getValueFor","nameOrConfig","toString","Map","CustomPropertyReflector","subscribe","unsubscribe","remove","setProperty","resolveCSSValue","removeProperty","createCSS","DesignTokenBindingObserver","source","node","dependencies","observer","binding","call","disconnect","store","observe","Store","values","getNotifier","notify","track","entries","nodeCache","childToParent","children","assignedValues","reflecting","bindingObservers","tokenValueChangeHandler","arg","getTokenById","isCSSDesignToken","parent","isReflecting","parentValue","sourceValue","reflectToCSS","stopReflectToCSS","$fastController","addBehaviors","isConnected","bind","raw","getRaw","hydrate","_a","findClosestAssignedNode","isDerivedDesignTokenValue","tearDownBindingObserver","setupBindingObserver","upstream","findParent","appendChild","keys","key","removeChild","child","reParent","filter","x","contains","push","all","childIndex","indexOf","splice","test","cssCustomPropertyReflector","startReflection","stopReflection","property","start","current","prototype","create","from","DesignToken","notifyConnection","notifyDisconnection","unbind","registerRoot","unregisterRoot"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/design-token/design-token.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { CSSDirective, defaultExecutionContext, FASTElement, observable, Observable, } from \"@microsoft/fast-element\";\nimport { composedParent } from \"../utilities/composed-parent.js\";\nimport { composedContains } from \"../utilities/composed-contains.js\";\nimport { PropertyTargetManager, RootStyleSheetTarget, } from \"./custom-property-manager.js\";\nimport { defaultElement } from \"./custom-property-manager.js\";\n/**\n * Implementation of {@link (DesignToken:interface)}\n */\nclass DesignTokenImpl extends CSSDirective {\n    constructor(configuration) {\n        super();\n        this.subscribers = new WeakMap();\n        this._appliedTo = new Set();\n        this.name = configuration.name;\n        if (configuration.cssCustomPropertyName !== null) {\n            this.cssCustomProperty = `--${configuration.cssCustomPropertyName}`;\n            this.cssVar = `var(${this.cssCustomProperty})`;\n        }\n        this.id = DesignTokenImpl.uniqueId();\n        DesignTokenImpl.tokensById.set(this.id, this);\n    }\n    get appliedTo() {\n        return [...this._appliedTo];\n    }\n    static from(nameOrConfig) {\n        return new DesignTokenImpl({\n            name: typeof nameOrConfig === \"string\" ? nameOrConfig : nameOrConfig.name,\n            cssCustomPropertyName: typeof nameOrConfig === \"string\"\n                ? nameOrConfig\n                : nameOrConfig.cssCustomPropertyName === void 0\n                    ? nameOrConfig.name\n                    : nameOrConfig.cssCustomPropertyName,\n        });\n    }\n    static isCSSDesignToken(token) {\n        return typeof token.cssCustomProperty === \"string\";\n    }\n    static isDerivedDesignTokenValue(value) {\n        return typeof value === \"function\";\n    }\n    /**\n     * Gets a token by ID. Returns undefined if the token was not found.\n     * @param id - The ID of the token\n     * @returns\n     */\n    static getTokenById(id) {\n        return DesignTokenImpl.tokensById.get(id);\n    }\n    getOrCreateSubscriberSet(target = this) {\n        return (this.subscribers.get(target) ||\n            (this.subscribers.set(target, new Set()) && this.subscribers.get(target)));\n    }\n    createCSS() {\n        return this.cssVar || \"\";\n    }\n    getValueFor(element) {\n        const value = DesignTokenNode.getOrCreate(element).get(this);\n        if (value !== undefined) {\n            return value;\n        }\n        throw new Error(`Value could not be retrieved for token named \"${this.name}\". Ensure the value is set for ${element} or an ancestor of ${element}.`);\n    }\n    setValueFor(element, value) {\n        this._appliedTo.add(element);\n        if (value instanceof DesignTokenImpl) {\n            value = this.alias(value);\n        }\n        DesignTokenNode.getOrCreate(element).set(this, value);\n        return this;\n    }\n    deleteValueFor(element) {\n        this._appliedTo.delete(element);\n        if (DesignTokenNode.existsFor(element)) {\n            DesignTokenNode.getOrCreate(element).delete(this);\n        }\n        return this;\n    }\n    withDefault(value) {\n        this.setValueFor(defaultElement, value);\n        return this;\n    }\n    subscribe(subscriber, target) {\n        const subscriberSet = this.getOrCreateSubscriberSet(target);\n        if (target && !DesignTokenNode.existsFor(target)) {\n            DesignTokenNode.getOrCreate(target);\n        }\n        if (!subscriberSet.has(subscriber)) {\n            subscriberSet.add(subscriber);\n        }\n    }\n    unsubscribe(subscriber, target) {\n        const list = this.subscribers.get(target || this);\n        if (list && list.has(subscriber)) {\n            list.delete(subscriber);\n        }\n    }\n    /**\n     * Notifies subscribers that the value for an element has changed.\n     * @param element - The element to emit a notification for\n     */\n    notify(element) {\n        const record = Object.freeze({ token: this, target: element });\n        if (this.subscribers.has(this)) {\n            this.subscribers.get(this).forEach(sub => sub.handleChange(record));\n        }\n        if (this.subscribers.has(element)) {\n            this.subscribers.get(element).forEach(sub => sub.handleChange(record));\n        }\n    }\n    /**\n     * Alias the token to the provided token.\n     * @param token - the token to alias to\n     */\n    alias(token) {\n        return ((target) => token.getValueFor(target));\n    }\n}\nDesignTokenImpl.uniqueId = (() => {\n    let id = 0;\n    return () => {\n        id++;\n        return id.toString(16);\n    };\n})();\n/**\n * Token storage by token ID\n */\nDesignTokenImpl.tokensById = new Map();\nclass CustomPropertyReflector {\n    startReflection(token, target) {\n        token.subscribe(this, target);\n        this.handleChange({ token, target });\n    }\n    stopReflection(token, target) {\n        token.unsubscribe(this, target);\n        this.remove(token, target);\n    }\n    handleChange(record) {\n        const { token, target } = record;\n        this.add(token, target);\n    }\n    add(token, target) {\n        PropertyTargetManager.getOrCreate(target).setProperty(token.cssCustomProperty, this.resolveCSSValue(DesignTokenNode.getOrCreate(target).get(token)));\n    }\n    remove(token, target) {\n        PropertyTargetManager.getOrCreate(target).removeProperty(token.cssCustomProperty);\n    }\n    resolveCSSValue(value) {\n        return value && typeof value.createCSS === \"function\" ? value.createCSS() : value;\n    }\n}\n/**\n * A light wrapper around BindingObserver to handle value caching and\n * token notification\n */\nclass DesignTokenBindingObserver {\n    constructor(source, token, node) {\n        this.source = source;\n        this.token = token;\n        this.node = node;\n        this.dependencies = new Set();\n        this.observer = Observable.binding(source, this, false);\n        // This is a little bit hacky because it's using internal APIs of BindingObserverImpl.\n        // BindingObserverImpl queues updates to batch it's notifications which doesn't work for this\n        // scenario because the DesignToken.getValueFor API is not async. Without this, using DesignToken.getValueFor()\n        // after DesignToken.setValueFor() when setting a dependency of the value being retrieved can return a stale\n        // value. Assigning .handleChange to .call forces immediate invocation of this classes handleChange() method,\n        // allowing resolution of values synchronously.\n        // TODO: https://github.com/microsoft/fast/issues/5110\n        this.observer.handleChange = this.observer.call;\n        this.handleChange();\n    }\n    disconnect() {\n        this.observer.disconnect();\n    }\n    /**\n     * @internal\n     */\n    handleChange() {\n        this.node.store.set(this.token, this.observer.observe(this.node.target, defaultExecutionContext));\n    }\n}\n/**\n * Stores resolved token/value pairs and notifies on changes\n */\nclass Store {\n    constructor() {\n        this.values = new Map();\n    }\n    set(token, value) {\n        if (this.values.get(token) !== value) {\n            this.values.set(token, value);\n            Observable.getNotifier(this).notify(token.id);\n        }\n    }\n    get(token) {\n        Observable.track(this, token.id);\n        return this.values.get(token);\n    }\n    delete(token) {\n        this.values.delete(token);\n    }\n    all() {\n        return this.values.entries();\n    }\n}\nconst nodeCache = new WeakMap();\nconst childToParent = new WeakMap();\n/**\n * A node responsible for setting and getting token values,\n * emitting values to CSS custom properties, and maintaining\n * inheritance structures.\n */\nclass DesignTokenNode {\n    constructor(target) {\n        this.target = target;\n        /**\n         * Stores all resolved token values for a node\n         */\n        this.store = new Store();\n        /**\n         * All children assigned to the node\n         */\n        this.children = [];\n        /**\n         * All values explicitly assigned to the node in their raw form\n         */\n        this.assignedValues = new Map();\n        /**\n         * Tokens currently being reflected to CSS custom properties\n         */\n        this.reflecting = new Set();\n        /**\n         * Binding observers for assigned and inherited derived values.\n         */\n        this.bindingObservers = new Map();\n        /**\n         * Emits notifications to token when token values\n         * change the DesignTokenNode\n         */\n        this.tokenValueChangeHandler = {\n            handleChange: (source, arg) => {\n                const token = DesignTokenImpl.getTokenById(arg);\n                if (token) {\n                    // Notify any token subscribers\n                    token.notify(this.target);\n                    if (DesignTokenImpl.isCSSDesignToken(token)) {\n                        const parent = this.parent;\n                        const reflecting = this.isReflecting(token);\n                        if (parent) {\n                            const parentValue = parent.get(token);\n                            const sourceValue = source.get(token);\n                            if (parentValue !== sourceValue && !reflecting) {\n                                this.reflectToCSS(token);\n                            }\n                            else if (parentValue === sourceValue && reflecting) {\n                                this.stopReflectToCSS(token);\n                            }\n                        }\n                        else if (!reflecting) {\n                            this.reflectToCSS(token);\n                        }\n                    }\n                }\n            },\n        };\n        nodeCache.set(target, this);\n        // Map store change notifications to token change notifications\n        Observable.getNotifier(this.store).subscribe(this.tokenValueChangeHandler);\n        if (target instanceof FASTElement) {\n            target.$fastController.addBehaviors([this]);\n        }\n        else if (target.isConnected) {\n            this.bind();\n        }\n    }\n    /**\n     * Returns a DesignTokenNode for an element.\n     * Creates a new instance if one does not already exist for a node,\n     * otherwise returns the cached instance\n     *\n     * @param target - The HTML element to retrieve a DesignTokenNode for\n     */\n    static getOrCreate(target) {\n        return nodeCache.get(target) || new DesignTokenNode(target);\n    }\n    /**\n     * Determines if a DesignTokenNode has been created for a target\n     * @param target - The element to test\n     */\n    static existsFor(target) {\n        return nodeCache.has(target);\n    }\n    /**\n     * Searches for and return the nearest parent DesignTokenNode.\n     * Null is returned if no node is found or the node provided is for a default element.\n     */\n    static findParent(node) {\n        if (!(defaultElement === node.target)) {\n            let parent = composedParent(node.target);\n            while (parent !== null) {\n                if (nodeCache.has(parent)) {\n                    return nodeCache.get(parent);\n                }\n                parent = composedParent(parent);\n            }\n            return DesignTokenNode.getOrCreate(defaultElement);\n        }\n        return null;\n    }\n    /**\n     * Finds the closest node with a value explicitly assigned for a token, otherwise null.\n     * @param token - The token to look for\n     * @param start - The node to start looking for value assignment\n     * @returns\n     */\n    static findClosestAssignedNode(token, start) {\n        let current = start;\n        do {\n            if (current.has(token)) {\n                return current;\n            }\n            current = current.parent\n                ? current.parent\n                : current.target !== defaultElement\n                    ? DesignTokenNode.getOrCreate(defaultElement)\n                    : null;\n        } while (current !== null);\n        return null;\n    }\n    /**\n     * The parent DesignTokenNode, or null.\n     */\n    get parent() {\n        return childToParent.get(this) || null;\n    }\n    /**\n     * Checks if a token has been assigned an explicit value the node.\n     * @param token - the token to check.\n     */\n    has(token) {\n        return this.assignedValues.has(token);\n    }\n    /**\n     * Gets the value of a token for a node\n     * @param token - The token to retrieve the value for\n     * @returns\n     */\n    get(token) {\n        const value = this.store.get(token);\n        if (value !== undefined) {\n            return value;\n        }\n        const raw = this.getRaw(token);\n        if (raw !== undefined) {\n            this.hydrate(token, raw);\n            return this.get(token);\n        }\n    }\n    /**\n     * Retrieves the raw assigned value of a token from the nearest assigned node.\n     * @param token - The token to retrieve a raw value for\n     * @returns\n     */\n    getRaw(token) {\n        var _a;\n        if (this.assignedValues.has(token)) {\n            return this.assignedValues.get(token);\n        }\n        return (_a = DesignTokenNode.findClosestAssignedNode(token, this)) === null || _a === void 0 ? void 0 : _a.getRaw(token);\n    }\n    /**\n     * Sets a token to a value for a node\n     * @param token - The token to set\n     * @param value - The value to set the token to\n     */\n    set(token, value) {\n        if (DesignTokenImpl.isDerivedDesignTokenValue(this.assignedValues.get(token))) {\n            this.tearDownBindingObserver(token);\n        }\n        this.assignedValues.set(token, value);\n        if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {\n            this.setupBindingObserver(token, value);\n        }\n        else {\n            this.store.set(token, value);\n        }\n    }\n    /**\n     * Deletes a token value for the node.\n     * @param token - The token to delete the value for\n     */\n    delete(token) {\n        this.assignedValues.delete(token);\n        this.tearDownBindingObserver(token);\n        const upstream = this.getRaw(token);\n        if (upstream) {\n            this.hydrate(token, upstream);\n        }\n        else {\n            this.store.delete(token);\n        }\n    }\n    /**\n     * Invoked when the DesignTokenNode.target is attached to the document\n     */\n    bind() {\n        const parent = DesignTokenNode.findParent(this);\n        if (parent) {\n            parent.appendChild(this);\n        }\n        for (const key of this.assignedValues.keys()) {\n            key.notify(this.target);\n        }\n    }\n    /**\n     * Invoked when the DesignTokenNode.target is detached from the document\n     */\n    unbind() {\n        if (this.parent) {\n            const parent = childToParent.get(this);\n            parent.removeChild(this);\n        }\n    }\n    /**\n     * Appends a child to a parent DesignTokenNode.\n     * @param child - The child to append to the node\n     */\n    appendChild(child) {\n        if (child.parent) {\n            childToParent.get(child).removeChild(child);\n        }\n        const reParent = this.children.filter(x => child.contains(x));\n        childToParent.set(child, this);\n        this.children.push(child);\n        reParent.forEach(x => child.appendChild(x));\n        Observable.getNotifier(this.store).subscribe(child);\n        // How can we not notify *every* subscriber?\n        for (const [token, value] of this.store.all()) {\n            child.hydrate(token, this.bindingObservers.has(token) ? this.getRaw(token) : value);\n        }\n    }\n    /**\n     * Removes a child from a node.\n     * @param child - The child to remove.\n     */\n    removeChild(child) {\n        const childIndex = this.children.indexOf(child);\n        if (childIndex !== -1) {\n            this.children.splice(childIndex, 1);\n        }\n        Observable.getNotifier(this.store).unsubscribe(child);\n        return child.parent === this ? childToParent.delete(child) : false;\n    }\n    /**\n     * Tests whether a provided node is contained by\n     * the calling node.\n     * @param test - The node to test\n     */\n    contains(test) {\n        return composedContains(this.target, test.target);\n    }\n    /**\n     * Instructs the node to reflect a design token for the provided token.\n     * @param token - The design token to reflect\n     */\n    reflectToCSS(token) {\n        if (!this.isReflecting(token)) {\n            this.reflecting.add(token);\n            DesignTokenNode.cssCustomPropertyReflector.startReflection(token, this.target);\n        }\n    }\n    /**\n     * Stops reflecting a DesignToken to CSS\n     * @param token - The design token to stop reflecting\n     */\n    stopReflectToCSS(token) {\n        if (this.isReflecting(token)) {\n            this.reflecting.delete(token);\n            DesignTokenNode.cssCustomPropertyReflector.stopReflection(token, this.target);\n        }\n    }\n    /**\n     * Determines if a token is being reflected to CSS for a node.\n     * @param token - The token to check for reflection\n     * @returns\n     */\n    isReflecting(token) {\n        return this.reflecting.has(token);\n    }\n    /**\n     * Handle changes to upstream tokens\n     * @param source - The parent DesignTokenNode\n     * @param property - The token ID that changed\n     */\n    handleChange(source, property) {\n        const token = DesignTokenImpl.getTokenById(property);\n        if (!token) {\n            return;\n        }\n        this.hydrate(token, this.getRaw(token));\n    }\n    /**\n     * Hydrates a token with a DesignTokenValue, making retrieval available.\n     * @param token - The token to hydrate\n     * @param value - The value to hydrate\n     */\n    hydrate(token, value) {\n        if (!this.has(token)) {\n            const observer = this.bindingObservers.get(token);\n            if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {\n                if (observer) {\n                    // If the binding source doesn't match, we need\n                    // to update the binding\n                    if (observer.source !== value) {\n                        this.tearDownBindingObserver(token);\n                        this.setupBindingObserver(token, value);\n                    }\n                }\n                else {\n                    this.setupBindingObserver(token, value);\n                }\n            }\n            else {\n                if (observer) {\n                    this.tearDownBindingObserver(token);\n                }\n                this.store.set(token, value);\n            }\n        }\n    }\n    /**\n     * Sets up a binding observer for a derived token value that notifies token\n     * subscribers on change.\n     *\n     * @param token - The token to notify when the binding updates\n     * @param source - The binding source\n     */\n    setupBindingObserver(token, source) {\n        const binding = new DesignTokenBindingObserver(source, token, this);\n        this.bindingObservers.set(token, binding);\n        return binding;\n    }\n    /**\n     * Tear down a binding observer for a token.\n     */\n    tearDownBindingObserver(token) {\n        if (this.bindingObservers.has(token)) {\n            this.bindingObservers.get(token).disconnect();\n            this.bindingObservers.delete(token);\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * Responsible for reflecting tokens to CSS custom properties\n */\nDesignTokenNode.cssCustomPropertyReflector = new CustomPropertyReflector();\n__decorate([\n    observable\n], DesignTokenNode.prototype, \"children\", void 0);\nfunction create(nameOrConfig) {\n    return DesignTokenImpl.from(nameOrConfig);\n}\n/* eslint-enable @typescript-eslint/no-unused-vars */\n/**\n * Factory object for creating {@link (DesignToken:interface)} instances.\n * @public\n */\nexport const DesignToken = Object.freeze({\n    create,\n    /**\n     * Informs DesignToken that an HTMLElement for which tokens have\n     * been set has been connected to the document.\n     *\n     * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness\n     * in all scenarios, so invoking this method manually is necessary when:\n     *\n     * 1. Token values are set for an HTMLElement.\n     * 2. The HTMLElement does not inherit from FASTElement.\n     * 3. The HTMLElement is not connected to the document when token values are set.\n     *\n     * @param element - The element to notify\n     * @returns - true if notification was successful, otherwise false.\n     */\n    notifyConnection(element) {\n        if (!element.isConnected || !DesignTokenNode.existsFor(element)) {\n            return false;\n        }\n        DesignTokenNode.getOrCreate(element).bind();\n        return true;\n    },\n    /**\n     * Informs DesignToken that an HTMLElement for which tokens have\n     * been set has been disconnected to the document.\n     *\n     * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness\n     * in all scenarios, so invoking this method manually is necessary when:\n     *\n     * 1. Token values are set for an HTMLElement.\n     * 2. The HTMLElement does not inherit from FASTElement.\n     *\n     * @param element - The element to notify\n     * @returns - true if notification was successful, otherwise false.\n     */\n    notifyDisconnection(element) {\n        if (element.isConnected || !DesignTokenNode.existsFor(element)) {\n            return false;\n        }\n        DesignTokenNode.getOrCreate(element).unbind();\n        return true;\n    },\n    /**\n     * Registers and element or document as a DesignToken root.\n     * {@link CSSDesignToken | CSSDesignTokens} with default values assigned via\n     * {@link (DesignToken:interface).withDefault} will emit CSS custom properties to all\n     * registered roots.\n     * @param target - The root to register\n     */\n    registerRoot(target = defaultElement) {\n        RootStyleSheetTarget.registerRoot(target);\n    },\n    /**\n     * Unregister an element or document as a DesignToken root.\n     * @param target - The root to deregister\n     */\n    unregisterRoot(target = defaultElement) {\n        RootStyleSheetTarget.unregisterRoot(target);\n    },\n});\n/* eslint-enable @typescript-eslint/no-non-null-assertion */\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}