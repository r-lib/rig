{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { attr, DOM, observable } from \"@microsoft/fast-element\";\nimport { getDisplayedNodes, isHTMLElement, keyArrowDown, keyArrowLeft, keyArrowRight, keyArrowUp, keyEnd, keyEnter, keyHome } from \"@microsoft/fast-web-utilities\";\nimport { isTreeItemElement, TreeItem } from \"../tree-item/tree-item.js\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\n/**\n * A Tree view Custom HTML Element.\n * Implements the {@link https://w3c.github.io/aria-practices/#TreeView | ARIA TreeView }.\n *\n * @slot - The default slot for tree items\n *\n * @public\n */\n\nexport class TreeView extends FoundationElement {\n  constructor() {\n    super(...arguments);\n    /**\n     * The tree item that is designated to be in the tab queue.\n     *\n     * @internal\n     */\n\n    this.currentFocused = null;\n    /**\n     * Handle focus events\n     *\n     * @internal\n     */\n\n    this.handleFocus = e => {\n      if (this.slottedTreeItems.length < 1) {\n        // no child items, nothing to do\n        return;\n      }\n\n      if (e.target === this) {\n        if (this.currentFocused === null) {\n          this.currentFocused = this.getValidFocusableItem();\n        }\n\n        if (this.currentFocused !== null) {\n          TreeItem.focusItem(this.currentFocused);\n        }\n\n        return;\n      }\n\n      if (this.contains(e.target)) {\n        this.setAttribute(\"tabindex\", \"-1\");\n        this.currentFocused = e.target;\n      }\n    };\n    /**\n     * Handle blur events\n     *\n     * @internal\n     */\n\n\n    this.handleBlur = e => {\n      if (e.target instanceof HTMLElement && (e.relatedTarget === null || !this.contains(e.relatedTarget))) {\n        this.setAttribute(\"tabindex\", \"0\");\n      }\n    };\n    /**\n     * KeyDown handler\n     *\n     *  @internal\n     */\n\n\n    this.handleKeyDown = e => {\n      if (e.defaultPrevented) {\n        return;\n      }\n\n      if (this.slottedTreeItems.length < 1) {\n        return true;\n      }\n\n      const treeItems = this.getVisibleNodes();\n\n      switch (e.key) {\n        case keyHome:\n          if (treeItems.length) {\n            TreeItem.focusItem(treeItems[0]);\n          }\n\n          return;\n\n        case keyEnd:\n          if (treeItems.length) {\n            TreeItem.focusItem(treeItems[treeItems.length - 1]);\n          }\n\n          return;\n\n        case keyArrowLeft:\n          if (e.target && this.isFocusableElement(e.target)) {\n            const item = e.target;\n\n            if (item instanceof TreeItem && item.childItemLength() > 0 && item.expanded) {\n              item.expanded = false;\n            } else if (item instanceof TreeItem && item.parentElement instanceof TreeItem) {\n              TreeItem.focusItem(item.parentElement);\n            }\n          }\n\n          return false;\n\n        case keyArrowRight:\n          if (e.target && this.isFocusableElement(e.target)) {\n            const item = e.target;\n\n            if (item instanceof TreeItem && item.childItemLength() > 0 && !item.expanded) {\n              item.expanded = true;\n            } else if (item instanceof TreeItem && item.childItemLength() > 0) {\n              this.focusNextNode(1, e.target);\n            }\n          }\n\n          return;\n\n        case keyArrowDown:\n          if (e.target && this.isFocusableElement(e.target)) {\n            this.focusNextNode(1, e.target);\n          }\n\n          return;\n\n        case keyArrowUp:\n          if (e.target && this.isFocusableElement(e.target)) {\n            this.focusNextNode(-1, e.target);\n          }\n\n          return;\n\n        case keyEnter:\n          // In single-select trees where selection does not follow focus (see note below),\n          // the default action is typically to select the focused node.\n          this.handleClick(e);\n          return;\n      } // don't prevent default if we took no action\n\n\n      return true;\n    };\n    /**\n     * Handles the selected-changed events bubbling up\n     * from child tree items\n     *\n     *  @internal\n     */\n\n\n    this.handleSelectedChange = e => {\n      if (e.defaultPrevented) {\n        return;\n      }\n\n      if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {\n        return true;\n      }\n\n      const item = e.target;\n\n      if (item.selected) {\n        if (this.currentSelected && this.currentSelected !== item) {\n          this.currentSelected.selected = false;\n        } // new selected item\n\n\n        this.currentSelected = item;\n      } else if (!item.selected && this.currentSelected === item) {\n        // selected item deselected\n        this.currentSelected = null;\n      }\n\n      return;\n    };\n    /**\n     * Updates the tree view when slottedTreeItems changes\n     */\n\n\n    this.setItems = () => {\n      // force single selection\n      // defaults to first one found\n      const selectedItem = this.treeView.querySelector(\"[aria-selected='true']\");\n      this.currentSelected = selectedItem; // invalidate the current focused item if it is no longer valid\n\n      if (this.currentFocused === null || !this.contains(this.currentFocused)) {\n        this.currentFocused = this.getValidFocusableItem();\n      } // toggle properties on child elements\n\n\n      this.nested = this.checkForNestedItems();\n      const treeItems = this.getVisibleNodes();\n      treeItems.forEach(node => {\n        if (isTreeItemElement(node)) {\n          node.nested = this.nested;\n        }\n      });\n    };\n    /**\n     * check if the item is focusable\n     */\n\n\n    this.isFocusableElement = el => {\n      return isTreeItemElement(el);\n    };\n\n    this.isSelectedElement = el => {\n      return el.selected;\n    };\n  }\n\n  slottedTreeItemsChanged() {\n    if (this.$fastController.isConnected) {\n      // update for slotted children change\n      this.setItems();\n    }\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.setAttribute(\"tabindex\", \"0\");\n    DOM.queueUpdate(() => {\n      this.setItems();\n    });\n  }\n  /**\n   * Handles click events bubbling up\n   *\n   *  @internal\n   */\n\n\n  handleClick(e) {\n    if (e.defaultPrevented) {\n      // handled, do nothing\n      return;\n    }\n\n    if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {\n      // not a tree item, ignore\n      return true;\n    }\n\n    const item = e.target;\n\n    if (!item.disabled) {\n      item.selected = !item.selected;\n    }\n\n    return;\n  }\n  /**\n   * Move focus to a tree item based on its offset from the provided item\n   */\n\n\n  focusNextNode(delta, item) {\n    const visibleNodes = this.getVisibleNodes();\n\n    if (!visibleNodes) {\n      return;\n    }\n\n    const focusItem = visibleNodes[visibleNodes.indexOf(item) + delta];\n\n    if (isHTMLElement(focusItem)) {\n      TreeItem.focusItem(focusItem);\n    }\n  }\n  /**\n   * checks if there are any nested tree items\n   */\n\n\n  getValidFocusableItem() {\n    const treeItems = this.getVisibleNodes(); // default to selected element if there is one\n\n    let focusIndex = treeItems.findIndex(this.isSelectedElement);\n\n    if (focusIndex === -1) {\n      // otherwise first focusable tree item\n      focusIndex = treeItems.findIndex(this.isFocusableElement);\n    }\n\n    if (focusIndex !== -1) {\n      return treeItems[focusIndex];\n    }\n\n    return null;\n  }\n  /**\n   * checks if there are any nested tree items\n   */\n\n\n  checkForNestedItems() {\n    return this.slottedTreeItems.some(node => {\n      return isTreeItemElement(node) && node.querySelector(\"[role='treeitem']\");\n    });\n  }\n\n  getVisibleNodes() {\n    return getDisplayedNodes(this, \"[role='treeitem']\") || [];\n  }\n\n}\n\n__decorate([attr({\n  attribute: \"render-collapsed-nodes\"\n})], TreeView.prototype, \"renderCollapsedNodes\", void 0);\n\n__decorate([observable], TreeView.prototype, \"currentSelected\", void 0);\n\n__decorate([observable], TreeView.prototype, \"slottedTreeItems\", void 0);","map":{"version":3,"names":["__decorate","attr","DOM","observable","getDisplayedNodes","isHTMLElement","keyArrowDown","keyArrowLeft","keyArrowRight","keyArrowUp","keyEnd","keyEnter","keyHome","isTreeItemElement","TreeItem","FoundationElement","TreeView","constructor","arguments","currentFocused","handleFocus","e","slottedTreeItems","length","target","getValidFocusableItem","focusItem","contains","setAttribute","handleBlur","HTMLElement","relatedTarget","handleKeyDown","defaultPrevented","treeItems","getVisibleNodes","key","isFocusableElement","item","childItemLength","expanded","parentElement","focusNextNode","handleClick","handleSelectedChange","Element","selected","currentSelected","setItems","selectedItem","treeView","querySelector","nested","checkForNestedItems","forEach","node","el","isSelectedElement","slottedTreeItemsChanged","$fastController","isConnected","connectedCallback","queueUpdate","disabled","delta","visibleNodes","indexOf","focusIndex","findIndex","some","attribute","prototype"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/tree-view/tree-view.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { attr, DOM, observable } from \"@microsoft/fast-element\";\nimport { getDisplayedNodes, isHTMLElement, keyArrowDown, keyArrowLeft, keyArrowRight, keyArrowUp, keyEnd, keyEnter, keyHome, } from \"@microsoft/fast-web-utilities\";\nimport { isTreeItemElement, TreeItem } from \"../tree-item/tree-item.js\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\n/**\n * A Tree view Custom HTML Element.\n * Implements the {@link https://w3c.github.io/aria-practices/#TreeView | ARIA TreeView }.\n *\n * @slot - The default slot for tree items\n *\n * @public\n */\nexport class TreeView extends FoundationElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * The tree item that is designated to be in the tab queue.\n         *\n         * @internal\n         */\n        this.currentFocused = null;\n        /**\n         * Handle focus events\n         *\n         * @internal\n         */\n        this.handleFocus = (e) => {\n            if (this.slottedTreeItems.length < 1) {\n                // no child items, nothing to do\n                return;\n            }\n            if (e.target === this) {\n                if (this.currentFocused === null) {\n                    this.currentFocused = this.getValidFocusableItem();\n                }\n                if (this.currentFocused !== null) {\n                    TreeItem.focusItem(this.currentFocused);\n                }\n                return;\n            }\n            if (this.contains(e.target)) {\n                this.setAttribute(\"tabindex\", \"-1\");\n                this.currentFocused = e.target;\n            }\n        };\n        /**\n         * Handle blur events\n         *\n         * @internal\n         */\n        this.handleBlur = (e) => {\n            if (e.target instanceof HTMLElement &&\n                (e.relatedTarget === null || !this.contains(e.relatedTarget))) {\n                this.setAttribute(\"tabindex\", \"0\");\n            }\n        };\n        /**\n         * KeyDown handler\n         *\n         *  @internal\n         */\n        this.handleKeyDown = (e) => {\n            if (e.defaultPrevented) {\n                return;\n            }\n            if (this.slottedTreeItems.length < 1) {\n                return true;\n            }\n            const treeItems = this.getVisibleNodes();\n            switch (e.key) {\n                case keyHome:\n                    if (treeItems.length) {\n                        TreeItem.focusItem(treeItems[0]);\n                    }\n                    return;\n                case keyEnd:\n                    if (treeItems.length) {\n                        TreeItem.focusItem(treeItems[treeItems.length - 1]);\n                    }\n                    return;\n                case keyArrowLeft:\n                    if (e.target && this.isFocusableElement(e.target)) {\n                        const item = e.target;\n                        if (item instanceof TreeItem &&\n                            item.childItemLength() > 0 &&\n                            item.expanded) {\n                            item.expanded = false;\n                        }\n                        else if (item instanceof TreeItem &&\n                            item.parentElement instanceof TreeItem) {\n                            TreeItem.focusItem(item.parentElement);\n                        }\n                    }\n                    return false;\n                case keyArrowRight:\n                    if (e.target && this.isFocusableElement(e.target)) {\n                        const item = e.target;\n                        if (item instanceof TreeItem &&\n                            item.childItemLength() > 0 &&\n                            !item.expanded) {\n                            item.expanded = true;\n                        }\n                        else if (item instanceof TreeItem && item.childItemLength() > 0) {\n                            this.focusNextNode(1, e.target);\n                        }\n                    }\n                    return;\n                case keyArrowDown:\n                    if (e.target && this.isFocusableElement(e.target)) {\n                        this.focusNextNode(1, e.target);\n                    }\n                    return;\n                case keyArrowUp:\n                    if (e.target && this.isFocusableElement(e.target)) {\n                        this.focusNextNode(-1, e.target);\n                    }\n                    return;\n                case keyEnter:\n                    // In single-select trees where selection does not follow focus (see note below),\n                    // the default action is typically to select the focused node.\n                    this.handleClick(e);\n                    return;\n            }\n            // don't prevent default if we took no action\n            return true;\n        };\n        /**\n         * Handles the selected-changed events bubbling up\n         * from child tree items\n         *\n         *  @internal\n         */\n        this.handleSelectedChange = (e) => {\n            if (e.defaultPrevented) {\n                return;\n            }\n            if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {\n                return true;\n            }\n            const item = e.target;\n            if (item.selected) {\n                if (this.currentSelected && this.currentSelected !== item) {\n                    this.currentSelected.selected = false;\n                }\n                // new selected item\n                this.currentSelected = item;\n            }\n            else if (!item.selected && this.currentSelected === item) {\n                // selected item deselected\n                this.currentSelected = null;\n            }\n            return;\n        };\n        /**\n         * Updates the tree view when slottedTreeItems changes\n         */\n        this.setItems = () => {\n            // force single selection\n            // defaults to first one found\n            const selectedItem = this.treeView.querySelector(\"[aria-selected='true']\");\n            this.currentSelected = selectedItem;\n            // invalidate the current focused item if it is no longer valid\n            if (this.currentFocused === null || !this.contains(this.currentFocused)) {\n                this.currentFocused = this.getValidFocusableItem();\n            }\n            // toggle properties on child elements\n            this.nested = this.checkForNestedItems();\n            const treeItems = this.getVisibleNodes();\n            treeItems.forEach(node => {\n                if (isTreeItemElement(node)) {\n                    node.nested = this.nested;\n                }\n            });\n        };\n        /**\n         * check if the item is focusable\n         */\n        this.isFocusableElement = (el) => {\n            return isTreeItemElement(el);\n        };\n        this.isSelectedElement = (el) => {\n            return el.selected;\n        };\n    }\n    slottedTreeItemsChanged() {\n        if (this.$fastController.isConnected) {\n            // update for slotted children change\n            this.setItems();\n        }\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.setAttribute(\"tabindex\", \"0\");\n        DOM.queueUpdate(() => {\n            this.setItems();\n        });\n    }\n    /**\n     * Handles click events bubbling up\n     *\n     *  @internal\n     */\n    handleClick(e) {\n        if (e.defaultPrevented) {\n            // handled, do nothing\n            return;\n        }\n        if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {\n            // not a tree item, ignore\n            return true;\n        }\n        const item = e.target;\n        if (!item.disabled) {\n            item.selected = !item.selected;\n        }\n        return;\n    }\n    /**\n     * Move focus to a tree item based on its offset from the provided item\n     */\n    focusNextNode(delta, item) {\n        const visibleNodes = this.getVisibleNodes();\n        if (!visibleNodes) {\n            return;\n        }\n        const focusItem = visibleNodes[visibleNodes.indexOf(item) + delta];\n        if (isHTMLElement(focusItem)) {\n            TreeItem.focusItem(focusItem);\n        }\n    }\n    /**\n     * checks if there are any nested tree items\n     */\n    getValidFocusableItem() {\n        const treeItems = this.getVisibleNodes();\n        // default to selected element if there is one\n        let focusIndex = treeItems.findIndex(this.isSelectedElement);\n        if (focusIndex === -1) {\n            // otherwise first focusable tree item\n            focusIndex = treeItems.findIndex(this.isFocusableElement);\n        }\n        if (focusIndex !== -1) {\n            return treeItems[focusIndex];\n        }\n        return null;\n    }\n    /**\n     * checks if there are any nested tree items\n     */\n    checkForNestedItems() {\n        return this.slottedTreeItems.some((node) => {\n            return isTreeItemElement(node) && node.querySelector(\"[role='treeitem']\");\n        });\n    }\n    getVisibleNodes() {\n        return getDisplayedNodes(this, \"[role='treeitem']\") || [];\n    }\n}\n__decorate([\n    attr({ attribute: \"render-collapsed-nodes\" })\n], TreeView.prototype, \"renderCollapsedNodes\", void 0);\n__decorate([\n    observable\n], TreeView.prototype, \"currentSelected\", void 0);\n__decorate([\n    observable\n], TreeView.prototype, \"slottedTreeItems\", void 0);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}