{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { DOM, observable } from \"@microsoft/fast-element\";\nimport { isHTMLElement, keyArrowDown, keyArrowUp, keyEnd, keyHome } from \"@microsoft/fast-web-utilities\";\nimport { MenuItem, MenuItemRole, roleForMenuItem } from \"../menu-item/index.js\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\n/**\n * A Menu Custom HTML Element.\n * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#menu | ARIA menu }.\n *\n * @slot - The default slot for the menu items\n *\n * @public\n */\n\nexport class Menu extends FoundationElement {\n  constructor() {\n    super(...arguments);\n    this.expandedItem = null;\n    /**\n     * The index of the focusable element in the items array\n     * defaults to -1\n     */\n\n    this.focusIndex = -1;\n    /**\n     * @internal\n     */\n\n    this.isNestedMenu = () => {\n      return this.parentElement !== null && isHTMLElement(this.parentElement) && this.parentElement.getAttribute(\"role\") === \"menuitem\";\n    };\n    /**\n     * if focus is moving out of the menu, reset to a stable initial state\n     * @internal\n     */\n\n\n    this.handleFocusOut = e => {\n      if (!this.contains(e.relatedTarget) && this.menuItems !== undefined) {\n        this.collapseExpandedItem(); // find our first focusable element\n\n        const focusIndex = this.menuItems.findIndex(this.isFocusableElement); // set the current focus index's tabindex to -1\n\n        this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\"); // set the first focusable element tabindex to 0\n\n        this.menuItems[focusIndex].setAttribute(\"tabindex\", \"0\"); // set the focus index\n\n        this.focusIndex = focusIndex;\n      }\n    };\n\n    this.handleItemFocus = e => {\n      const targetItem = e.target;\n\n      if (this.menuItems !== undefined && targetItem !== this.menuItems[this.focusIndex]) {\n        this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n        this.focusIndex = this.menuItems.indexOf(targetItem);\n        targetItem.setAttribute(\"tabindex\", \"0\");\n      }\n    };\n\n    this.handleExpandedChanged = e => {\n      if (e.defaultPrevented || e.target === null || this.menuItems === undefined || this.menuItems.indexOf(e.target) < 0) {\n        return;\n      }\n\n      e.preventDefault();\n      const changedItem = e.target; // closing an expanded item without opening another\n\n      if (this.expandedItem !== null && changedItem === this.expandedItem && changedItem.expanded === false) {\n        this.expandedItem = null;\n        return;\n      }\n\n      if (changedItem.expanded) {\n        if (this.expandedItem !== null && this.expandedItem !== changedItem) {\n          this.expandedItem.expanded = false;\n        }\n\n        this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n        this.expandedItem = changedItem;\n        this.focusIndex = this.menuItems.indexOf(changedItem);\n        changedItem.setAttribute(\"tabindex\", \"0\");\n      }\n    };\n\n    this.removeItemListeners = () => {\n      if (this.menuItems !== undefined) {\n        this.menuItems.forEach(item => {\n          item.removeEventListener(\"expanded-change\", this.handleExpandedChanged);\n          item.removeEventListener(\"focus\", this.handleItemFocus);\n        });\n      }\n    };\n\n    this.setItems = () => {\n      const newItems = this.domChildren();\n      this.removeItemListeners();\n      this.menuItems = newItems;\n      const menuItems = this.menuItems.filter(this.isMenuItemElement); // if our focus index is not -1 we have items\n\n      if (menuItems.length) {\n        this.focusIndex = 0;\n      }\n\n      function elementIndent(el) {\n        const role = el.getAttribute(\"role\");\n        const startSlot = el.querySelector(\"[slot=start]\");\n\n        if (role !== MenuItemRole.menuitem && startSlot === null) {\n          return 1;\n        } else if (role === MenuItemRole.menuitem && startSlot !== null) {\n          return 1;\n        } else if (role !== MenuItemRole.menuitem && startSlot !== null) {\n          return 2;\n        } else {\n          return 0;\n        }\n      }\n\n      const indent = menuItems.reduce((accum, current) => {\n        const elementValue = elementIndent(current);\n        return accum > elementValue ? accum : elementValue;\n      }, 0);\n      menuItems.forEach((item, index) => {\n        item.setAttribute(\"tabindex\", index === 0 ? \"0\" : \"-1\");\n        item.addEventListener(\"expanded-change\", this.handleExpandedChanged);\n        item.addEventListener(\"focus\", this.handleItemFocus);\n\n        if (item instanceof MenuItem) {\n          item.startColumnCount = indent;\n        }\n      });\n    };\n    /**\n     * handle change from child element\n     */\n\n\n    this.changeHandler = e => {\n      if (this.menuItems === undefined) {\n        return;\n      }\n\n      const changedMenuItem = e.target;\n      const changeItemIndex = this.menuItems.indexOf(changedMenuItem);\n\n      if (changeItemIndex === -1) {\n        return;\n      }\n\n      if (changedMenuItem.role === \"menuitemradio\" && changedMenuItem.checked === true) {\n        for (let i = changeItemIndex - 1; i >= 0; --i) {\n          const item = this.menuItems[i];\n          const role = item.getAttribute(\"role\");\n\n          if (role === MenuItemRole.menuitemradio) {\n            item.checked = false;\n          }\n\n          if (role === \"separator\") {\n            break;\n          }\n        }\n\n        const maxIndex = this.menuItems.length - 1;\n\n        for (let i = changeItemIndex + 1; i <= maxIndex; ++i) {\n          const item = this.menuItems[i];\n          const role = item.getAttribute(\"role\");\n\n          if (role === MenuItemRole.menuitemradio) {\n            item.checked = false;\n          }\n\n          if (role === \"separator\") {\n            break;\n          }\n        }\n      }\n    };\n    /**\n     * check if the item is a menu item\n     */\n\n\n    this.isMenuItemElement = el => {\n      return isHTMLElement(el) && Menu.focusableElementRoles.hasOwnProperty(el.getAttribute(\"role\"));\n    };\n    /**\n     * check if the item is focusable\n     */\n\n\n    this.isFocusableElement = el => {\n      return this.isMenuItemElement(el);\n    };\n  }\n\n  itemsChanged(oldValue, newValue) {\n    // only update children after the component is connected and\n    // the setItems has run on connectedCallback\n    // (menuItems is undefined until then)\n    if (this.$fastController.isConnected && this.menuItems !== undefined) {\n      this.setItems();\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n    DOM.queueUpdate(() => {\n      // wait until children have had a chance to\n      // connect before setting/checking their props/attributes\n      this.setItems();\n    });\n    this.addEventListener(\"change\", this.changeHandler);\n  }\n  /**\n   * @internal\n   */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.removeItemListeners();\n    this.menuItems = undefined;\n    this.removeEventListener(\"change\", this.changeHandler);\n  }\n  /**\n   * Focuses the first item in the menu.\n   *\n   * @public\n   */\n\n\n  focus() {\n    this.setFocus(0, 1);\n  }\n  /**\n   * Collapses any expanded menu items.\n   *\n   * @public\n   */\n\n\n  collapseExpandedItem() {\n    if (this.expandedItem !== null) {\n      this.expandedItem.expanded = false;\n      this.expandedItem = null;\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  handleMenuKeyDown(e) {\n    if (e.defaultPrevented || this.menuItems === undefined) {\n      return;\n    }\n\n    switch (e.key) {\n      case keyArrowDown:\n        // go forward one index\n        this.setFocus(this.focusIndex + 1, 1);\n        return;\n\n      case keyArrowUp:\n        // go back one index\n        this.setFocus(this.focusIndex - 1, -1);\n        return;\n\n      case keyEnd:\n        // set focus on last item\n        this.setFocus(this.menuItems.length - 1, -1);\n        return;\n\n      case keyHome:\n        // set focus on first item\n        this.setFocus(0, 1);\n        return;\n\n      default:\n        // if we are not handling the event, do not prevent default\n        return true;\n    }\n  }\n  /**\n   * get an array of valid DOM children\n   */\n\n\n  domChildren() {\n    return Array.from(this.children).filter(child => !child.hasAttribute(\"hidden\"));\n  }\n\n  setFocus(focusIndex, adjustment) {\n    if (this.menuItems === undefined) {\n      return;\n    }\n\n    while (focusIndex >= 0 && focusIndex < this.menuItems.length) {\n      const child = this.menuItems[focusIndex];\n\n      if (this.isFocusableElement(child)) {\n        // change the previous index to -1\n        if (this.focusIndex > -1 && this.menuItems.length >= this.focusIndex - 1) {\n          this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n        } // update the focus index\n\n\n        this.focusIndex = focusIndex; // update the tabindex of next focusable element\n\n        child.setAttribute(\"tabindex\", \"0\"); // focus the element\n\n        child.focus();\n        break;\n      }\n\n      focusIndex += adjustment;\n    }\n  }\n\n}\nMenu.focusableElementRoles = roleForMenuItem;\n\n__decorate([observable], Menu.prototype, \"items\", void 0);","map":{"version":3,"names":["__decorate","DOM","observable","isHTMLElement","keyArrowDown","keyArrowUp","keyEnd","keyHome","MenuItem","MenuItemRole","roleForMenuItem","FoundationElement","Menu","constructor","arguments","expandedItem","focusIndex","isNestedMenu","parentElement","getAttribute","handleFocusOut","e","contains","relatedTarget","menuItems","undefined","collapseExpandedItem","findIndex","isFocusableElement","setAttribute","handleItemFocus","targetItem","target","indexOf","handleExpandedChanged","defaultPrevented","preventDefault","changedItem","expanded","removeItemListeners","forEach","item","removeEventListener","setItems","newItems","domChildren","filter","isMenuItemElement","length","elementIndent","el","role","startSlot","querySelector","menuitem","indent","reduce","accum","current","elementValue","index","addEventListener","startColumnCount","changeHandler","changedMenuItem","changeItemIndex","checked","i","menuitemradio","maxIndex","focusableElementRoles","hasOwnProperty","itemsChanged","oldValue","newValue","$fastController","isConnected","connectedCallback","queueUpdate","disconnectedCallback","focus","setFocus","handleMenuKeyDown","key","Array","from","children","child","hasAttribute","adjustment","prototype"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/menu/menu.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { DOM, observable } from \"@microsoft/fast-element\";\nimport { isHTMLElement, keyArrowDown, keyArrowUp, keyEnd, keyHome, } from \"@microsoft/fast-web-utilities\";\nimport { MenuItem, MenuItemRole, roleForMenuItem, } from \"../menu-item/index.js\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\n/**\n * A Menu Custom HTML Element.\n * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#menu | ARIA menu }.\n *\n * @slot - The default slot for the menu items\n *\n * @public\n */\nexport class Menu extends FoundationElement {\n    constructor() {\n        super(...arguments);\n        this.expandedItem = null;\n        /**\n         * The index of the focusable element in the items array\n         * defaults to -1\n         */\n        this.focusIndex = -1;\n        /**\n         * @internal\n         */\n        this.isNestedMenu = () => {\n            return (this.parentElement !== null &&\n                isHTMLElement(this.parentElement) &&\n                this.parentElement.getAttribute(\"role\") === \"menuitem\");\n        };\n        /**\n         * if focus is moving out of the menu, reset to a stable initial state\n         * @internal\n         */\n        this.handleFocusOut = (e) => {\n            if (!this.contains(e.relatedTarget) && this.menuItems !== undefined) {\n                this.collapseExpandedItem();\n                // find our first focusable element\n                const focusIndex = this.menuItems.findIndex(this.isFocusableElement);\n                // set the current focus index's tabindex to -1\n                this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n                // set the first focusable element tabindex to 0\n                this.menuItems[focusIndex].setAttribute(\"tabindex\", \"0\");\n                // set the focus index\n                this.focusIndex = focusIndex;\n            }\n        };\n        this.handleItemFocus = (e) => {\n            const targetItem = e.target;\n            if (this.menuItems !== undefined &&\n                targetItem !== this.menuItems[this.focusIndex]) {\n                this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n                this.focusIndex = this.menuItems.indexOf(targetItem);\n                targetItem.setAttribute(\"tabindex\", \"0\");\n            }\n        };\n        this.handleExpandedChanged = (e) => {\n            if (e.defaultPrevented ||\n                e.target === null ||\n                this.menuItems === undefined ||\n                this.menuItems.indexOf(e.target) < 0) {\n                return;\n            }\n            e.preventDefault();\n            const changedItem = e.target;\n            // closing an expanded item without opening another\n            if (this.expandedItem !== null &&\n                changedItem === this.expandedItem &&\n                changedItem.expanded === false) {\n                this.expandedItem = null;\n                return;\n            }\n            if (changedItem.expanded) {\n                if (this.expandedItem !== null && this.expandedItem !== changedItem) {\n                    this.expandedItem.expanded = false;\n                }\n                this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n                this.expandedItem = changedItem;\n                this.focusIndex = this.menuItems.indexOf(changedItem);\n                changedItem.setAttribute(\"tabindex\", \"0\");\n            }\n        };\n        this.removeItemListeners = () => {\n            if (this.menuItems !== undefined) {\n                this.menuItems.forEach((item) => {\n                    item.removeEventListener(\"expanded-change\", this.handleExpandedChanged);\n                    item.removeEventListener(\"focus\", this.handleItemFocus);\n                });\n            }\n        };\n        this.setItems = () => {\n            const newItems = this.domChildren();\n            this.removeItemListeners();\n            this.menuItems = newItems;\n            const menuItems = this.menuItems.filter(this.isMenuItemElement);\n            // if our focus index is not -1 we have items\n            if (menuItems.length) {\n                this.focusIndex = 0;\n            }\n            function elementIndent(el) {\n                const role = el.getAttribute(\"role\");\n                const startSlot = el.querySelector(\"[slot=start]\");\n                if (role !== MenuItemRole.menuitem && startSlot === null) {\n                    return 1;\n                }\n                else if (role === MenuItemRole.menuitem && startSlot !== null) {\n                    return 1;\n                }\n                else if (role !== MenuItemRole.menuitem && startSlot !== null) {\n                    return 2;\n                }\n                else {\n                    return 0;\n                }\n            }\n            const indent = menuItems.reduce((accum, current) => {\n                const elementValue = elementIndent(current);\n                return accum > elementValue ? accum : elementValue;\n            }, 0);\n            menuItems.forEach((item, index) => {\n                item.setAttribute(\"tabindex\", index === 0 ? \"0\" : \"-1\");\n                item.addEventListener(\"expanded-change\", this.handleExpandedChanged);\n                item.addEventListener(\"focus\", this.handleItemFocus);\n                if (item instanceof MenuItem) {\n                    item.startColumnCount = indent;\n                }\n            });\n        };\n        /**\n         * handle change from child element\n         */\n        this.changeHandler = (e) => {\n            if (this.menuItems === undefined) {\n                return;\n            }\n            const changedMenuItem = e.target;\n            const changeItemIndex = this.menuItems.indexOf(changedMenuItem);\n            if (changeItemIndex === -1) {\n                return;\n            }\n            if (changedMenuItem.role === \"menuitemradio\" &&\n                changedMenuItem.checked === true) {\n                for (let i = changeItemIndex - 1; i >= 0; --i) {\n                    const item = this.menuItems[i];\n                    const role = item.getAttribute(\"role\");\n                    if (role === MenuItemRole.menuitemradio) {\n                        item.checked = false;\n                    }\n                    if (role === \"separator\") {\n                        break;\n                    }\n                }\n                const maxIndex = this.menuItems.length - 1;\n                for (let i = changeItemIndex + 1; i <= maxIndex; ++i) {\n                    const item = this.menuItems[i];\n                    const role = item.getAttribute(\"role\");\n                    if (role === MenuItemRole.menuitemradio) {\n                        item.checked = false;\n                    }\n                    if (role === \"separator\") {\n                        break;\n                    }\n                }\n            }\n        };\n        /**\n         * check if the item is a menu item\n         */\n        this.isMenuItemElement = (el) => {\n            return (isHTMLElement(el) &&\n                Menu.focusableElementRoles.hasOwnProperty(el.getAttribute(\"role\")));\n        };\n        /**\n         * check if the item is focusable\n         */\n        this.isFocusableElement = (el) => {\n            return this.isMenuItemElement(el);\n        };\n    }\n    itemsChanged(oldValue, newValue) {\n        // only update children after the component is connected and\n        // the setItems has run on connectedCallback\n        // (menuItems is undefined until then)\n        if (this.$fastController.isConnected && this.menuItems !== undefined) {\n            this.setItems();\n        }\n    }\n    /**\n     * @internal\n     */\n    connectedCallback() {\n        super.connectedCallback();\n        DOM.queueUpdate(() => {\n            // wait until children have had a chance to\n            // connect before setting/checking their props/attributes\n            this.setItems();\n        });\n        this.addEventListener(\"change\", this.changeHandler);\n    }\n    /**\n     * @internal\n     */\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.removeItemListeners();\n        this.menuItems = undefined;\n        this.removeEventListener(\"change\", this.changeHandler);\n    }\n    /**\n     * Focuses the first item in the menu.\n     *\n     * @public\n     */\n    focus() {\n        this.setFocus(0, 1);\n    }\n    /**\n     * Collapses any expanded menu items.\n     *\n     * @public\n     */\n    collapseExpandedItem() {\n        if (this.expandedItem !== null) {\n            this.expandedItem.expanded = false;\n            this.expandedItem = null;\n        }\n    }\n    /**\n     * @internal\n     */\n    handleMenuKeyDown(e) {\n        if (e.defaultPrevented || this.menuItems === undefined) {\n            return;\n        }\n        switch (e.key) {\n            case keyArrowDown:\n                // go forward one index\n                this.setFocus(this.focusIndex + 1, 1);\n                return;\n            case keyArrowUp:\n                // go back one index\n                this.setFocus(this.focusIndex - 1, -1);\n                return;\n            case keyEnd:\n                // set focus on last item\n                this.setFocus(this.menuItems.length - 1, -1);\n                return;\n            case keyHome:\n                // set focus on first item\n                this.setFocus(0, 1);\n                return;\n            default:\n                // if we are not handling the event, do not prevent default\n                return true;\n        }\n    }\n    /**\n     * get an array of valid DOM children\n     */\n    domChildren() {\n        return Array.from(this.children).filter(child => !child.hasAttribute(\"hidden\"));\n    }\n    setFocus(focusIndex, adjustment) {\n        if (this.menuItems === undefined) {\n            return;\n        }\n        while (focusIndex >= 0 && focusIndex < this.menuItems.length) {\n            const child = this.menuItems[focusIndex];\n            if (this.isFocusableElement(child)) {\n                // change the previous index to -1\n                if (this.focusIndex > -1 &&\n                    this.menuItems.length >= this.focusIndex - 1) {\n                    this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n                }\n                // update the focus index\n                this.focusIndex = focusIndex;\n                // update the tabindex of next focusable element\n                child.setAttribute(\"tabindex\", \"0\");\n                // focus the element\n                child.focus();\n                break;\n            }\n            focusIndex += adjustment;\n        }\n    }\n}\nMenu.focusableElementRoles = roleForMenuItem;\n__decorate([\n    observable\n], Menu.prototype, \"items\", void 0);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}