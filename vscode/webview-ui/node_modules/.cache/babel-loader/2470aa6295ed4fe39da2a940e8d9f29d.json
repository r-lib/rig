{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { attr, DOM, observable } from \"@microsoft/fast-element\";\nimport { Direction, eventResize, eventScroll } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\nimport { getDirection } from \"../utilities/direction.js\";\nimport { IntersectionService } from \"../utilities/intersection-service.js\";\n/**\n * An anchored region Custom HTML Element.\n *\n * @slot - The default slot for the content\n * @fires loaded - Fires a custom 'loaded' event when the region is loaded and visible\n * @fires positionchange - Fires a custom 'positionchange' event when the position has changed\n *\n * @public\n */\n\nexport class AnchoredRegion extends FoundationElement {\n  constructor() {\n    super(...arguments);\n    /**\n     * The HTML ID of the anchor element this region is positioned relative to\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: anchor\n     */\n\n    this.anchor = \"\";\n    /**\n     * The HTML ID of the viewport element this region is positioned relative to\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: anchor\n     */\n\n    this.viewport = \"\";\n    /**\n     * Sets what logic the component uses to determine horizontal placement.\n     * 'locktodefault' forces the default position\n     * 'dynamic' decides placement based on available space\n     * 'uncontrolled' does not control placement on the horizontal axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-positioning-mode\n     */\n\n    this.horizontalPositioningMode = \"uncontrolled\";\n    /**\n     * The default horizontal position of the region relative to the anchor element\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-default-position\n     */\n\n    this.horizontalDefaultPosition = \"unset\";\n    /**\n     * Whether the region remains in the viewport (ie. detaches from the anchor) on the horizontal axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-viewport-lock\n     */\n\n    this.horizontalViewportLock = false;\n    /**\n     * Whether the region overlaps the anchor on the horizontal axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-inset\n     */\n\n    this.horizontalInset = false;\n    /**\n     * Defines how the width of the region is calculated\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-scaling\n     */\n\n    this.horizontalScaling = \"content\";\n    /**\n     * Sets what logic the component uses to determine vertical placement.\n     * 'locktodefault' forces the default position\n     * 'dynamic' decides placement based on available space\n     * 'uncontrolled' does not control placement on the vertical axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-positioning-mode\n     */\n\n    this.verticalPositioningMode = \"uncontrolled\";\n    /**\n     * The default vertical position of the region relative to the anchor element\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-default-position\n     */\n\n    this.verticalDefaultPosition = \"unset\";\n    /**\n     * Whether the region remains in the viewport (ie. detaches from the anchor) on the vertical axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-viewport-lock\n     */\n\n    this.verticalViewportLock = false;\n    /**\n     * Whether the region overlaps the anchor on the vertical axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-inset\n     */\n\n    this.verticalInset = false;\n    /**\n     * Defines how the height of the region is calculated\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-scaling\n     */\n\n    this.verticalScaling = \"content\";\n    /**\n     * Whether the region is positioned using css \"position: fixed\".\n     * Otherwise the region uses \"position: absolute\".\n     * Fixed placement allows the region to break out of parent containers,\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: fixed-placement\n     */\n\n    this.fixedPlacement = false;\n    /**\n     * Defines what triggers the anchored region to revaluate positioning\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: auto-update-mode\n     */\n\n    this.autoUpdateMode = \"anchor\";\n    /**\n     * The HTML element being used as the anchor\n     *\n     * @public\n     */\n\n    this.anchorElement = null;\n    /**\n     * The HTML element being used as the viewport\n     *\n     * @public\n     */\n\n    this.viewportElement = null;\n    /**\n     * indicates that an initial positioning pass on layout has completed\n     *\n     * @internal\n     */\n\n    this.initialLayoutComplete = false;\n    this.resizeDetector = null;\n    /**\n     * base offsets between the positioner's base position and the anchor's\n     */\n\n    this.baseHorizontalOffset = 0;\n    this.baseVerticalOffset = 0;\n    this.pendingPositioningUpdate = false;\n    this.pendingReset = false;\n    this.currentDirection = Direction.ltr;\n    this.regionVisible = false; // indicates that a layout update should occur even if geometry has not changed\n    // used to ensure some attribute changes are applied\n\n    this.forceUpdate = false; // defines how big a difference in pixels there must be between states to\n    // justify a layout update that affects the dom (prevents repeated sub-pixel corrections)\n\n    this.updateThreshold = 0.5;\n    /**\n     * update position\n     */\n\n    this.update = () => {\n      if (!this.pendingPositioningUpdate) {\n        this.requestPositionUpdates();\n      }\n    };\n    /**\n     * starts observers\n     */\n\n\n    this.startObservers = () => {\n      this.stopObservers();\n\n      if (this.anchorElement === null) {\n        return;\n      }\n\n      this.requestPositionUpdates();\n\n      if (this.resizeDetector !== null) {\n        this.resizeDetector.observe(this.anchorElement);\n        this.resizeDetector.observe(this);\n      }\n    };\n    /**\n     * get position updates\n     */\n\n\n    this.requestPositionUpdates = () => {\n      if (this.anchorElement === null || this.pendingPositioningUpdate) {\n        return;\n      }\n\n      AnchoredRegion.intersectionService.requestPosition(this, this.handleIntersection);\n      AnchoredRegion.intersectionService.requestPosition(this.anchorElement, this.handleIntersection);\n\n      if (this.viewportElement !== null) {\n        AnchoredRegion.intersectionService.requestPosition(this.viewportElement, this.handleIntersection);\n      }\n\n      this.pendingPositioningUpdate = true;\n    };\n    /**\n     * stops observers\n     */\n\n\n    this.stopObservers = () => {\n      if (this.pendingPositioningUpdate) {\n        this.pendingPositioningUpdate = false;\n        AnchoredRegion.intersectionService.cancelRequestPosition(this, this.handleIntersection);\n\n        if (this.anchorElement !== null) {\n          AnchoredRegion.intersectionService.cancelRequestPosition(this.anchorElement, this.handleIntersection);\n        }\n\n        if (this.viewportElement !== null) {\n          AnchoredRegion.intersectionService.cancelRequestPosition(this.viewportElement, this.handleIntersection);\n        }\n      }\n\n      if (this.resizeDetector !== null) {\n        this.resizeDetector.disconnect();\n      }\n    };\n    /**\n     * Gets the viewport element by id, or defaults to document root\n     */\n\n\n    this.getViewport = () => {\n      if (typeof this.viewport !== \"string\" || this.viewport === \"\") {\n        return document.documentElement;\n      }\n\n      return document.getElementById(this.viewport);\n    };\n    /**\n     *  Gets the anchor element by id\n     */\n\n\n    this.getAnchor = () => {\n      return document.getElementById(this.anchor);\n    };\n    /**\n     *  Handle intersections\n     */\n\n\n    this.handleIntersection = entries => {\n      if (!this.pendingPositioningUpdate) {\n        return;\n      }\n\n      this.pendingPositioningUpdate = false;\n\n      if (!this.applyIntersectionEntries(entries)) {\n        return;\n      }\n\n      this.updateLayout();\n    };\n    /**\n     *  iterate through intersection entries and apply data\n     */\n\n\n    this.applyIntersectionEntries = entries => {\n      const regionEntry = entries.find(x => x.target === this);\n      const anchorEntry = entries.find(x => x.target === this.anchorElement);\n      const viewportEntry = entries.find(x => x.target === this.viewportElement);\n\n      if (regionEntry === undefined || viewportEntry === undefined || anchorEntry === undefined) {\n        return false;\n      } // don't update the dom unless there is a significant difference in rect positions\n\n\n      if (!this.regionVisible || this.forceUpdate || this.regionRect === undefined || this.anchorRect === undefined || this.viewportRect === undefined || this.isRectDifferent(this.anchorRect, anchorEntry.boundingClientRect) || this.isRectDifferent(this.viewportRect, viewportEntry.boundingClientRect) || this.isRectDifferent(this.regionRect, regionEntry.boundingClientRect)) {\n        this.regionRect = regionEntry.boundingClientRect;\n        this.anchorRect = anchorEntry.boundingClientRect;\n\n        if (this.viewportElement === document.documentElement) {\n          this.viewportRect = new DOMRectReadOnly(viewportEntry.boundingClientRect.x + document.documentElement.scrollLeft, viewportEntry.boundingClientRect.y + document.documentElement.scrollTop, viewportEntry.boundingClientRect.width, viewportEntry.boundingClientRect.height);\n        } else {\n          this.viewportRect = viewportEntry.boundingClientRect;\n        }\n\n        this.updateRegionOffset();\n        this.forceUpdate = false;\n        return true;\n      }\n\n      return false;\n    };\n    /**\n     *  Update the offset values\n     */\n\n\n    this.updateRegionOffset = () => {\n      if (this.anchorRect && this.regionRect) {\n        this.baseHorizontalOffset = this.baseHorizontalOffset + (this.anchorRect.left - this.regionRect.left) + (this.translateX - this.baseHorizontalOffset);\n        this.baseVerticalOffset = this.baseVerticalOffset + (this.anchorRect.top - this.regionRect.top) + (this.translateY - this.baseVerticalOffset);\n      }\n    };\n    /**\n     *  compare rects to see if there is enough change to justify a DOM update\n     */\n\n\n    this.isRectDifferent = (rectA, rectB) => {\n      if (Math.abs(rectA.top - rectB.top) > this.updateThreshold || Math.abs(rectA.right - rectB.right) > this.updateThreshold || Math.abs(rectA.bottom - rectB.bottom) > this.updateThreshold || Math.abs(rectA.left - rectB.left) > this.updateThreshold) {\n        return true;\n      }\n\n      return false;\n    };\n    /**\n     *  Handle resize events\n     */\n\n\n    this.handleResize = entries => {\n      this.update();\n    };\n    /**\n     * resets the component\n     */\n\n\n    this.reset = () => {\n      if (!this.pendingReset) {\n        return;\n      }\n\n      this.pendingReset = false;\n\n      if (this.anchorElement === null) {\n        this.anchorElement = this.getAnchor();\n      }\n\n      if (this.viewportElement === null) {\n        this.viewportElement = this.getViewport();\n      }\n\n      this.currentDirection = getDirection(this);\n      this.startObservers();\n    };\n    /**\n     *  Recalculate layout related state values\n     */\n\n\n    this.updateLayout = () => {\n      let desiredVerticalPosition = undefined;\n      let desiredHorizontalPosition = undefined;\n\n      if (this.horizontalPositioningMode !== \"uncontrolled\") {\n        const horizontalOptions = this.getPositioningOptions(this.horizontalInset);\n\n        if (this.horizontalDefaultPosition === \"center\") {\n          desiredHorizontalPosition = \"center\";\n        } else if (this.horizontalDefaultPosition !== \"unset\") {\n          let dirCorrectedHorizontalDefaultPosition = this.horizontalDefaultPosition;\n\n          if (dirCorrectedHorizontalDefaultPosition === \"start\" || dirCorrectedHorizontalDefaultPosition === \"end\") {\n            // if direction changes we reset the layout\n            const newDirection = getDirection(this);\n\n            if (newDirection !== this.currentDirection) {\n              this.currentDirection = newDirection;\n              this.initialize();\n              return;\n            }\n\n            if (this.currentDirection === Direction.ltr) {\n              dirCorrectedHorizontalDefaultPosition = dirCorrectedHorizontalDefaultPosition === \"start\" ? \"left\" : \"right\";\n            } else {\n              dirCorrectedHorizontalDefaultPosition = dirCorrectedHorizontalDefaultPosition === \"start\" ? \"right\" : \"left\";\n            }\n          }\n\n          switch (dirCorrectedHorizontalDefaultPosition) {\n            case \"left\":\n              desiredHorizontalPosition = this.horizontalInset ? \"insetStart\" : \"start\";\n              break;\n\n            case \"right\":\n              desiredHorizontalPosition = this.horizontalInset ? \"insetEnd\" : \"end\";\n              break;\n          }\n        }\n\n        const horizontalThreshold = this.horizontalThreshold !== undefined ? this.horizontalThreshold : this.regionRect !== undefined ? this.regionRect.width : 0;\n        const anchorLeft = this.anchorRect !== undefined ? this.anchorRect.left : 0;\n        const anchorRight = this.anchorRect !== undefined ? this.anchorRect.right : 0;\n        const anchorWidth = this.anchorRect !== undefined ? this.anchorRect.width : 0;\n        const viewportLeft = this.viewportRect !== undefined ? this.viewportRect.left : 0;\n        const viewportRight = this.viewportRect !== undefined ? this.viewportRect.right : 0;\n\n        if (desiredHorizontalPosition === undefined || !(this.horizontalPositioningMode === \"locktodefault\") && this.getAvailableSpace(desiredHorizontalPosition, anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) < horizontalThreshold) {\n          desiredHorizontalPosition = this.getAvailableSpace(horizontalOptions[0], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) > this.getAvailableSpace(horizontalOptions[1], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) ? horizontalOptions[0] : horizontalOptions[1];\n        }\n      }\n\n      if (this.verticalPositioningMode !== \"uncontrolled\") {\n        const verticalOptions = this.getPositioningOptions(this.verticalInset);\n\n        if (this.verticalDefaultPosition === \"center\") {\n          desiredVerticalPosition = \"center\";\n        } else if (this.verticalDefaultPosition !== \"unset\") {\n          switch (this.verticalDefaultPosition) {\n            case \"top\":\n              desiredVerticalPosition = this.verticalInset ? \"insetStart\" : \"start\";\n              break;\n\n            case \"bottom\":\n              desiredVerticalPosition = this.verticalInset ? \"insetEnd\" : \"end\";\n              break;\n          }\n        }\n\n        const verticalThreshold = this.verticalThreshold !== undefined ? this.verticalThreshold : this.regionRect !== undefined ? this.regionRect.height : 0;\n        const anchorTop = this.anchorRect !== undefined ? this.anchorRect.top : 0;\n        const anchorBottom = this.anchorRect !== undefined ? this.anchorRect.bottom : 0;\n        const anchorHeight = this.anchorRect !== undefined ? this.anchorRect.height : 0;\n        const viewportTop = this.viewportRect !== undefined ? this.viewportRect.top : 0;\n        const viewportBottom = this.viewportRect !== undefined ? this.viewportRect.bottom : 0;\n\n        if (desiredVerticalPosition === undefined || !(this.verticalPositioningMode === \"locktodefault\") && this.getAvailableSpace(desiredVerticalPosition, anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) < verticalThreshold) {\n          desiredVerticalPosition = this.getAvailableSpace(verticalOptions[0], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) > this.getAvailableSpace(verticalOptions[1], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) ? verticalOptions[0] : verticalOptions[1];\n        }\n      }\n\n      const nextPositionerDimension = this.getNextRegionDimension(desiredHorizontalPosition, desiredVerticalPosition);\n      const positionChanged = this.horizontalPosition !== desiredHorizontalPosition || this.verticalPosition !== desiredVerticalPosition;\n      this.setHorizontalPosition(desiredHorizontalPosition, nextPositionerDimension);\n      this.setVerticalPosition(desiredVerticalPosition, nextPositionerDimension);\n      this.updateRegionStyle();\n\n      if (!this.initialLayoutComplete) {\n        this.initialLayoutComplete = true;\n        this.requestPositionUpdates();\n        return;\n      }\n\n      if (!this.regionVisible) {\n        this.regionVisible = true;\n        this.style.removeProperty(\"pointer-events\");\n        this.style.removeProperty(\"opacity\");\n        this.classList.toggle(\"loaded\", true);\n        this.$emit(\"loaded\", this, {\n          bubbles: false\n        });\n      }\n\n      this.updatePositionClasses();\n\n      if (positionChanged) {\n        // emit change event\n        this.$emit(\"positionchange\", this, {\n          bubbles: false\n        });\n      }\n    };\n    /**\n     *  Updates the style string applied to the region element as well as the css classes attached\n     *  to the root element\n     */\n\n\n    this.updateRegionStyle = () => {\n      this.style.width = this.regionWidth;\n      this.style.height = this.regionHeight;\n      this.style.transform = `translate(${this.translateX}px, ${this.translateY}px)`;\n    };\n    /**\n     *  Updates the css classes that reflect the current position of the element\n     */\n\n\n    this.updatePositionClasses = () => {\n      this.classList.toggle(\"top\", this.verticalPosition === \"start\");\n      this.classList.toggle(\"bottom\", this.verticalPosition === \"end\");\n      this.classList.toggle(\"inset-top\", this.verticalPosition === \"insetStart\");\n      this.classList.toggle(\"inset-bottom\", this.verticalPosition === \"insetEnd\");\n      this.classList.toggle(\"vertical-center\", this.verticalPosition === \"center\");\n      this.classList.toggle(\"left\", this.horizontalPosition === \"start\");\n      this.classList.toggle(\"right\", this.horizontalPosition === \"end\");\n      this.classList.toggle(\"inset-left\", this.horizontalPosition === \"insetStart\");\n      this.classList.toggle(\"inset-right\", this.horizontalPosition === \"insetEnd\");\n      this.classList.toggle(\"horizontal-center\", this.horizontalPosition === \"center\");\n    };\n    /**\n     * Get horizontal positioning state based on desired position\n     */\n\n\n    this.setHorizontalPosition = (desiredHorizontalPosition, nextPositionerDimension) => {\n      if (desiredHorizontalPosition === undefined || this.regionRect === undefined || this.anchorRect === undefined || this.viewportRect === undefined) {\n        return;\n      }\n\n      let nextRegionWidth = 0;\n\n      switch (this.horizontalScaling) {\n        case \"anchor\":\n        case \"fill\":\n          nextRegionWidth = this.horizontalViewportLock ? this.viewportRect.width : nextPositionerDimension.width;\n          this.regionWidth = `${nextRegionWidth}px`;\n          break;\n\n        case \"content\":\n          nextRegionWidth = this.regionRect.width;\n          this.regionWidth = \"unset\";\n          break;\n      }\n\n      let sizeDelta = 0;\n\n      switch (desiredHorizontalPosition) {\n        case \"start\":\n          this.translateX = this.baseHorizontalOffset - nextRegionWidth;\n\n          if (this.horizontalViewportLock && this.anchorRect.left > this.viewportRect.right) {\n            this.translateX = this.translateX - (this.anchorRect.left - this.viewportRect.right);\n          }\n\n          break;\n\n        case \"insetStart\":\n          this.translateX = this.baseHorizontalOffset - nextRegionWidth + this.anchorRect.width;\n\n          if (this.horizontalViewportLock && this.anchorRect.right > this.viewportRect.right) {\n            this.translateX = this.translateX - (this.anchorRect.right - this.viewportRect.right);\n          }\n\n          break;\n\n        case \"insetEnd\":\n          this.translateX = this.baseHorizontalOffset;\n\n          if (this.horizontalViewportLock && this.anchorRect.left < this.viewportRect.left) {\n            this.translateX = this.translateX - (this.anchorRect.left - this.viewportRect.left);\n          }\n\n          break;\n\n        case \"end\":\n          this.translateX = this.baseHorizontalOffset + this.anchorRect.width;\n\n          if (this.horizontalViewportLock && this.anchorRect.right < this.viewportRect.left) {\n            this.translateX = this.translateX - (this.anchorRect.right - this.viewportRect.left);\n          }\n\n          break;\n\n        case \"center\":\n          sizeDelta = (this.anchorRect.width - nextRegionWidth) / 2;\n          this.translateX = this.baseHorizontalOffset + sizeDelta;\n\n          if (this.horizontalViewportLock) {\n            const regionLeft = this.anchorRect.left + sizeDelta;\n            const regionRight = this.anchorRect.right - sizeDelta;\n\n            if (regionLeft < this.viewportRect.left && !(regionRight > this.viewportRect.right)) {\n              this.translateX = this.translateX - (regionLeft - this.viewportRect.left);\n            } else if (regionRight > this.viewportRect.right && !(regionLeft < this.viewportRect.left)) {\n              this.translateX = this.translateX - (regionRight - this.viewportRect.right);\n            }\n          }\n\n          break;\n      }\n\n      this.horizontalPosition = desiredHorizontalPosition;\n    };\n    /**\n     * Set vertical positioning state based on desired position\n     */\n\n\n    this.setVerticalPosition = (desiredVerticalPosition, nextPositionerDimension) => {\n      if (desiredVerticalPosition === undefined || this.regionRect === undefined || this.anchorRect === undefined || this.viewportRect === undefined) {\n        return;\n      }\n\n      let nextRegionHeight = 0;\n\n      switch (this.verticalScaling) {\n        case \"anchor\":\n        case \"fill\":\n          nextRegionHeight = this.verticalViewportLock ? this.viewportRect.height : nextPositionerDimension.height;\n          this.regionHeight = `${nextRegionHeight}px`;\n          break;\n\n        case \"content\":\n          nextRegionHeight = this.regionRect.height;\n          this.regionHeight = \"unset\";\n          break;\n      }\n\n      let sizeDelta = 0;\n\n      switch (desiredVerticalPosition) {\n        case \"start\":\n          this.translateY = this.baseVerticalOffset - nextRegionHeight;\n\n          if (this.verticalViewportLock && this.anchorRect.top > this.viewportRect.bottom) {\n            this.translateY = this.translateY - (this.anchorRect.top - this.viewportRect.bottom);\n          }\n\n          break;\n\n        case \"insetStart\":\n          this.translateY = this.baseVerticalOffset - nextRegionHeight + this.anchorRect.height;\n\n          if (this.verticalViewportLock && this.anchorRect.bottom > this.viewportRect.bottom) {\n            this.translateY = this.translateY - (this.anchorRect.bottom - this.viewportRect.bottom);\n          }\n\n          break;\n\n        case \"insetEnd\":\n          this.translateY = this.baseVerticalOffset;\n\n          if (this.verticalViewportLock && this.anchorRect.top < this.viewportRect.top) {\n            this.translateY = this.translateY - (this.anchorRect.top - this.viewportRect.top);\n          }\n\n          break;\n\n        case \"end\":\n          this.translateY = this.baseVerticalOffset + this.anchorRect.height;\n\n          if (this.verticalViewportLock && this.anchorRect.bottom < this.viewportRect.top) {\n            this.translateY = this.translateY - (this.anchorRect.bottom - this.viewportRect.top);\n          }\n\n          break;\n\n        case \"center\":\n          sizeDelta = (this.anchorRect.height - nextRegionHeight) / 2;\n          this.translateY = this.baseVerticalOffset + sizeDelta;\n\n          if (this.verticalViewportLock) {\n            const regionTop = this.anchorRect.top + sizeDelta;\n            const regionBottom = this.anchorRect.bottom - sizeDelta;\n\n            if (regionTop < this.viewportRect.top && !(regionBottom > this.viewportRect.bottom)) {\n              this.translateY = this.translateY - (regionTop - this.viewportRect.top);\n            } else if (regionBottom > this.viewportRect.bottom && !(regionTop < this.viewportRect.top)) {\n              this.translateY = this.translateY - (regionBottom - this.viewportRect.bottom);\n            }\n          }\n\n      }\n\n      this.verticalPosition = desiredVerticalPosition;\n    };\n    /**\n     *  Get available positions based on positioning mode\n     */\n\n\n    this.getPositioningOptions = inset => {\n      if (inset) {\n        return [\"insetStart\", \"insetEnd\"];\n      }\n\n      return [\"start\", \"end\"];\n    };\n    /**\n     *  Get the space available for a particular relative position\n     */\n\n\n    this.getAvailableSpace = (positionOption, anchorStart, anchorEnd, anchorSpan, viewportStart, viewportEnd) => {\n      const spaceStart = anchorStart - viewportStart;\n      const spaceEnd = viewportEnd - (anchorStart + anchorSpan);\n\n      switch (positionOption) {\n        case \"start\":\n          return spaceStart;\n\n        case \"insetStart\":\n          return spaceStart + anchorSpan;\n\n        case \"insetEnd\":\n          return spaceEnd + anchorSpan;\n\n        case \"end\":\n          return spaceEnd;\n\n        case \"center\":\n          return Math.min(spaceStart, spaceEnd) * 2 + anchorSpan;\n      }\n    };\n    /**\n     * Get region dimensions\n     */\n\n\n    this.getNextRegionDimension = (desiredHorizontalPosition, desiredVerticalPosition) => {\n      const newRegionDimension = {\n        height: this.regionRect !== undefined ? this.regionRect.height : 0,\n        width: this.regionRect !== undefined ? this.regionRect.width : 0\n      };\n\n      if (desiredHorizontalPosition !== undefined && this.horizontalScaling === \"fill\") {\n        newRegionDimension.width = this.getAvailableSpace(desiredHorizontalPosition, this.anchorRect !== undefined ? this.anchorRect.left : 0, this.anchorRect !== undefined ? this.anchorRect.right : 0, this.anchorRect !== undefined ? this.anchorRect.width : 0, this.viewportRect !== undefined ? this.viewportRect.left : 0, this.viewportRect !== undefined ? this.viewportRect.right : 0);\n      } else if (this.horizontalScaling === \"anchor\") {\n        newRegionDimension.width = this.anchorRect !== undefined ? this.anchorRect.width : 0;\n      }\n\n      if (desiredVerticalPosition !== undefined && this.verticalScaling === \"fill\") {\n        newRegionDimension.height = this.getAvailableSpace(desiredVerticalPosition, this.anchorRect !== undefined ? this.anchorRect.top : 0, this.anchorRect !== undefined ? this.anchorRect.bottom : 0, this.anchorRect !== undefined ? this.anchorRect.height : 0, this.viewportRect !== undefined ? this.viewportRect.top : 0, this.viewportRect !== undefined ? this.viewportRect.bottom : 0);\n      } else if (this.verticalScaling === \"anchor\") {\n        newRegionDimension.height = this.anchorRect !== undefined ? this.anchorRect.height : 0;\n      }\n\n      return newRegionDimension;\n    };\n    /**\n     * starts event listeners that can trigger auto updating\n     */\n\n\n    this.startAutoUpdateEventListeners = () => {\n      window.addEventListener(eventResize, this.update, {\n        passive: true\n      });\n      window.addEventListener(eventScroll, this.update, {\n        passive: true,\n        capture: true\n      });\n\n      if (this.resizeDetector !== null && this.viewportElement !== null) {\n        this.resizeDetector.observe(this.viewportElement);\n      }\n    };\n    /**\n     * stops event listeners that can trigger auto updating\n     */\n\n\n    this.stopAutoUpdateEventListeners = () => {\n      window.removeEventListener(eventResize, this.update);\n      window.removeEventListener(eventScroll, this.update);\n\n      if (this.resizeDetector !== null && this.viewportElement !== null) {\n        this.resizeDetector.unobserve(this.viewportElement);\n      }\n    };\n  }\n\n  anchorChanged() {\n    if (this.initialLayoutComplete) {\n      this.anchorElement = this.getAnchor();\n    }\n  }\n\n  viewportChanged() {\n    if (this.initialLayoutComplete) {\n      this.viewportElement = this.getViewport();\n    }\n  }\n\n  horizontalPositioningModeChanged() {\n    this.requestReset();\n  }\n\n  horizontalDefaultPositionChanged() {\n    this.updateForAttributeChange();\n  }\n\n  horizontalViewportLockChanged() {\n    this.updateForAttributeChange();\n  }\n\n  horizontalInsetChanged() {\n    this.updateForAttributeChange();\n  }\n\n  horizontalThresholdChanged() {\n    this.updateForAttributeChange();\n  }\n\n  horizontalScalingChanged() {\n    this.updateForAttributeChange();\n  }\n\n  verticalPositioningModeChanged() {\n    this.requestReset();\n  }\n\n  verticalDefaultPositionChanged() {\n    this.updateForAttributeChange();\n  }\n\n  verticalViewportLockChanged() {\n    this.updateForAttributeChange();\n  }\n\n  verticalInsetChanged() {\n    this.updateForAttributeChange();\n  }\n\n  verticalThresholdChanged() {\n    this.updateForAttributeChange();\n  }\n\n  verticalScalingChanged() {\n    this.updateForAttributeChange();\n  }\n\n  fixedPlacementChanged() {\n    if (this.$fastController.isConnected && this.initialLayoutComplete) {\n      this.initialize();\n    }\n  }\n\n  autoUpdateModeChanged(prevMode, newMode) {\n    if (this.$fastController.isConnected && this.initialLayoutComplete) {\n      if (prevMode === \"auto\") {\n        this.stopAutoUpdateEventListeners();\n      }\n\n      if (newMode === \"auto\") {\n        this.startAutoUpdateEventListeners();\n      }\n    }\n  }\n\n  anchorElementChanged() {\n    this.requestReset();\n  }\n\n  viewportElementChanged() {\n    if (this.$fastController.isConnected && this.initialLayoutComplete) {\n      this.initialize();\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    if (this.autoUpdateMode === \"auto\") {\n      this.startAutoUpdateEventListeners();\n    }\n\n    this.initialize();\n  }\n  /**\n   * @internal\n   */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    if (this.autoUpdateMode === \"auto\") {\n      this.stopAutoUpdateEventListeners();\n    }\n\n    this.stopObservers();\n    this.disconnectResizeDetector();\n  }\n  /**\n   * @internal\n   */\n\n\n  adoptedCallback() {\n    this.initialize();\n  }\n  /**\n   * destroys the instance's resize observer\n   */\n\n\n  disconnectResizeDetector() {\n    if (this.resizeDetector !== null) {\n      this.resizeDetector.disconnect();\n      this.resizeDetector = null;\n    }\n  }\n  /**\n   * initializes the instance's resize observer\n   */\n\n\n  initializeResizeDetector() {\n    this.disconnectResizeDetector();\n    this.resizeDetector = new window.ResizeObserver(this.handleResize);\n  }\n  /**\n   * react to attribute changes that don't require a reset\n   */\n\n\n  updateForAttributeChange() {\n    if (this.$fastController.isConnected && this.initialLayoutComplete) {\n      this.forceUpdate = true;\n      this.update();\n    }\n  }\n  /**\n   * fully initializes the component\n   */\n\n\n  initialize() {\n    this.initializeResizeDetector();\n\n    if (this.anchorElement === null) {\n      this.anchorElement = this.getAnchor();\n    }\n\n    this.requestReset();\n  }\n  /**\n   * Request a reset if there are currently no open requests\n   */\n\n\n  requestReset() {\n    if (this.$fastController.isConnected && this.pendingReset === false) {\n      this.setInitialState();\n      DOM.queueUpdate(() => this.reset());\n      this.pendingReset = true;\n    }\n  }\n  /**\n   * sets the starting configuration for component internal values\n   */\n\n\n  setInitialState() {\n    this.initialLayoutComplete = false;\n    this.regionVisible = false;\n    this.translateX = 0;\n    this.translateY = 0;\n    this.baseHorizontalOffset = 0;\n    this.baseVerticalOffset = 0;\n    this.viewportRect = undefined;\n    this.regionRect = undefined;\n    this.anchorRect = undefined;\n    this.verticalPosition = undefined;\n    this.horizontalPosition = undefined;\n    this.style.opacity = \"0\";\n    this.style.pointerEvents = \"none\";\n    this.forceUpdate = false;\n    this.style.position = this.fixedPlacement ? \"fixed\" : \"absolute\";\n    this.updatePositionClasses();\n    this.updateRegionStyle();\n  }\n\n}\nAnchoredRegion.intersectionService = new IntersectionService();\n\n__decorate([attr], AnchoredRegion.prototype, \"anchor\", void 0);\n\n__decorate([attr], AnchoredRegion.prototype, \"viewport\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-positioning-mode\"\n})], AnchoredRegion.prototype, \"horizontalPositioningMode\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-default-position\"\n})], AnchoredRegion.prototype, \"horizontalDefaultPosition\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-viewport-lock\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"horizontalViewportLock\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-inset\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"horizontalInset\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-threshold\"\n})], AnchoredRegion.prototype, \"horizontalThreshold\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-scaling\"\n})], AnchoredRegion.prototype, \"horizontalScaling\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-positioning-mode\"\n})], AnchoredRegion.prototype, \"verticalPositioningMode\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-default-position\"\n})], AnchoredRegion.prototype, \"verticalDefaultPosition\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-viewport-lock\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"verticalViewportLock\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-inset\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"verticalInset\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-threshold\"\n})], AnchoredRegion.prototype, \"verticalThreshold\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-scaling\"\n})], AnchoredRegion.prototype, \"verticalScaling\", void 0);\n\n__decorate([attr({\n  attribute: \"fixed-placement\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"fixedPlacement\", void 0);\n\n__decorate([attr({\n  attribute: \"auto-update-mode\"\n})], AnchoredRegion.prototype, \"autoUpdateMode\", void 0);\n\n__decorate([observable], AnchoredRegion.prototype, \"anchorElement\", void 0);\n\n__decorate([observable], AnchoredRegion.prototype, \"viewportElement\", void 0);\n\n__decorate([observable], AnchoredRegion.prototype, \"initialLayoutComplete\", void 0);","map":{"version":3,"names":["__decorate","attr","DOM","observable","Direction","eventResize","eventScroll","FoundationElement","getDirection","IntersectionService","AnchoredRegion","constructor","arguments","anchor","viewport","horizontalPositioningMode","horizontalDefaultPosition","horizontalViewportLock","horizontalInset","horizontalScaling","verticalPositioningMode","verticalDefaultPosition","verticalViewportLock","verticalInset","verticalScaling","fixedPlacement","autoUpdateMode","anchorElement","viewportElement","initialLayoutComplete","resizeDetector","baseHorizontalOffset","baseVerticalOffset","pendingPositioningUpdate","pendingReset","currentDirection","ltr","regionVisible","forceUpdate","updateThreshold","update","requestPositionUpdates","startObservers","stopObservers","observe","intersectionService","requestPosition","handleIntersection","cancelRequestPosition","disconnect","getViewport","document","documentElement","getElementById","getAnchor","entries","applyIntersectionEntries","updateLayout","regionEntry","find","x","target","anchorEntry","viewportEntry","undefined","regionRect","anchorRect","viewportRect","isRectDifferent","boundingClientRect","DOMRectReadOnly","scrollLeft","y","scrollTop","width","height","updateRegionOffset","left","translateX","top","translateY","rectA","rectB","Math","abs","right","bottom","handleResize","reset","desiredVerticalPosition","desiredHorizontalPosition","horizontalOptions","getPositioningOptions","dirCorrectedHorizontalDefaultPosition","newDirection","initialize","horizontalThreshold","anchorLeft","anchorRight","anchorWidth","viewportLeft","viewportRight","getAvailableSpace","verticalOptions","verticalThreshold","anchorTop","anchorBottom","anchorHeight","viewportTop","viewportBottom","nextPositionerDimension","getNextRegionDimension","positionChanged","horizontalPosition","verticalPosition","setHorizontalPosition","setVerticalPosition","updateRegionStyle","style","removeProperty","classList","toggle","$emit","bubbles","updatePositionClasses","regionWidth","regionHeight","transform","nextRegionWidth","sizeDelta","regionLeft","regionRight","nextRegionHeight","regionTop","regionBottom","inset","positionOption","anchorStart","anchorEnd","anchorSpan","viewportStart","viewportEnd","spaceStart","spaceEnd","min","newRegionDimension","startAutoUpdateEventListeners","window","addEventListener","passive","capture","stopAutoUpdateEventListeners","removeEventListener","unobserve","anchorChanged","viewportChanged","horizontalPositioningModeChanged","requestReset","horizontalDefaultPositionChanged","updateForAttributeChange","horizontalViewportLockChanged","horizontalInsetChanged","horizontalThresholdChanged","horizontalScalingChanged","verticalPositioningModeChanged","verticalDefaultPositionChanged","verticalViewportLockChanged","verticalInsetChanged","verticalThresholdChanged","verticalScalingChanged","fixedPlacementChanged","$fastController","isConnected","autoUpdateModeChanged","prevMode","newMode","anchorElementChanged","viewportElementChanged","connectedCallback","disconnectedCallback","disconnectResizeDetector","adoptedCallback","initializeResizeDetector","ResizeObserver","setInitialState","queueUpdate","opacity","pointerEvents","position","prototype","attribute","mode"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { attr, DOM, observable } from \"@microsoft/fast-element\";\nimport { Direction, eventResize, eventScroll } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\nimport { getDirection } from \"../utilities/direction.js\";\nimport { IntersectionService } from \"../utilities/intersection-service.js\";\n/**\n * An anchored region Custom HTML Element.\n *\n * @slot - The default slot for the content\n * @fires loaded - Fires a custom 'loaded' event when the region is loaded and visible\n * @fires positionchange - Fires a custom 'positionchange' event when the position has changed\n *\n * @public\n */\nexport class AnchoredRegion extends FoundationElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * The HTML ID of the anchor element this region is positioned relative to\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: anchor\n         */\n        this.anchor = \"\";\n        /**\n         * The HTML ID of the viewport element this region is positioned relative to\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: anchor\n         */\n        this.viewport = \"\";\n        /**\n         * Sets what logic the component uses to determine horizontal placement.\n         * 'locktodefault' forces the default position\n         * 'dynamic' decides placement based on available space\n         * 'uncontrolled' does not control placement on the horizontal axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-positioning-mode\n         */\n        this.horizontalPositioningMode = \"uncontrolled\";\n        /**\n         * The default horizontal position of the region relative to the anchor element\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-default-position\n         */\n        this.horizontalDefaultPosition = \"unset\";\n        /**\n         * Whether the region remains in the viewport (ie. detaches from the anchor) on the horizontal axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-viewport-lock\n         */\n        this.horizontalViewportLock = false;\n        /**\n         * Whether the region overlaps the anchor on the horizontal axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-inset\n         */\n        this.horizontalInset = false;\n        /**\n         * Defines how the width of the region is calculated\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-scaling\n         */\n        this.horizontalScaling = \"content\";\n        /**\n         * Sets what logic the component uses to determine vertical placement.\n         * 'locktodefault' forces the default position\n         * 'dynamic' decides placement based on available space\n         * 'uncontrolled' does not control placement on the vertical axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-positioning-mode\n         */\n        this.verticalPositioningMode = \"uncontrolled\";\n        /**\n         * The default vertical position of the region relative to the anchor element\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-default-position\n         */\n        this.verticalDefaultPosition = \"unset\";\n        /**\n         * Whether the region remains in the viewport (ie. detaches from the anchor) on the vertical axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-viewport-lock\n         */\n        this.verticalViewportLock = false;\n        /**\n         * Whether the region overlaps the anchor on the vertical axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-inset\n         */\n        this.verticalInset = false;\n        /**\n         * Defines how the height of the region is calculated\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-scaling\n         */\n        this.verticalScaling = \"content\";\n        /**\n         * Whether the region is positioned using css \"position: fixed\".\n         * Otherwise the region uses \"position: absolute\".\n         * Fixed placement allows the region to break out of parent containers,\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: fixed-placement\n         */\n        this.fixedPlacement = false;\n        /**\n         * Defines what triggers the anchored region to revaluate positioning\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: auto-update-mode\n         */\n        this.autoUpdateMode = \"anchor\";\n        /**\n         * The HTML element being used as the anchor\n         *\n         * @public\n         */\n        this.anchorElement = null;\n        /**\n         * The HTML element being used as the viewport\n         *\n         * @public\n         */\n        this.viewportElement = null;\n        /**\n         * indicates that an initial positioning pass on layout has completed\n         *\n         * @internal\n         */\n        this.initialLayoutComplete = false;\n        this.resizeDetector = null;\n        /**\n         * base offsets between the positioner's base position and the anchor's\n         */\n        this.baseHorizontalOffset = 0;\n        this.baseVerticalOffset = 0;\n        this.pendingPositioningUpdate = false;\n        this.pendingReset = false;\n        this.currentDirection = Direction.ltr;\n        this.regionVisible = false;\n        // indicates that a layout update should occur even if geometry has not changed\n        // used to ensure some attribute changes are applied\n        this.forceUpdate = false;\n        // defines how big a difference in pixels there must be between states to\n        // justify a layout update that affects the dom (prevents repeated sub-pixel corrections)\n        this.updateThreshold = 0.5;\n        /**\n         * update position\n         */\n        this.update = () => {\n            if (!this.pendingPositioningUpdate) {\n                this.requestPositionUpdates();\n            }\n        };\n        /**\n         * starts observers\n         */\n        this.startObservers = () => {\n            this.stopObservers();\n            if (this.anchorElement === null) {\n                return;\n            }\n            this.requestPositionUpdates();\n            if (this.resizeDetector !== null) {\n                this.resizeDetector.observe(this.anchorElement);\n                this.resizeDetector.observe(this);\n            }\n        };\n        /**\n         * get position updates\n         */\n        this.requestPositionUpdates = () => {\n            if (this.anchorElement === null || this.pendingPositioningUpdate) {\n                return;\n            }\n            AnchoredRegion.intersectionService.requestPosition(this, this.handleIntersection);\n            AnchoredRegion.intersectionService.requestPosition(this.anchorElement, this.handleIntersection);\n            if (this.viewportElement !== null) {\n                AnchoredRegion.intersectionService.requestPosition(this.viewportElement, this.handleIntersection);\n            }\n            this.pendingPositioningUpdate = true;\n        };\n        /**\n         * stops observers\n         */\n        this.stopObservers = () => {\n            if (this.pendingPositioningUpdate) {\n                this.pendingPositioningUpdate = false;\n                AnchoredRegion.intersectionService.cancelRequestPosition(this, this.handleIntersection);\n                if (this.anchorElement !== null) {\n                    AnchoredRegion.intersectionService.cancelRequestPosition(this.anchorElement, this.handleIntersection);\n                }\n                if (this.viewportElement !== null) {\n                    AnchoredRegion.intersectionService.cancelRequestPosition(this.viewportElement, this.handleIntersection);\n                }\n            }\n            if (this.resizeDetector !== null) {\n                this.resizeDetector.disconnect();\n            }\n        };\n        /**\n         * Gets the viewport element by id, or defaults to document root\n         */\n        this.getViewport = () => {\n            if (typeof this.viewport !== \"string\" || this.viewport === \"\") {\n                return document.documentElement;\n            }\n            return document.getElementById(this.viewport);\n        };\n        /**\n         *  Gets the anchor element by id\n         */\n        this.getAnchor = () => {\n            return document.getElementById(this.anchor);\n        };\n        /**\n         *  Handle intersections\n         */\n        this.handleIntersection = (entries) => {\n            if (!this.pendingPositioningUpdate) {\n                return;\n            }\n            this.pendingPositioningUpdate = false;\n            if (!this.applyIntersectionEntries(entries)) {\n                return;\n            }\n            this.updateLayout();\n        };\n        /**\n         *  iterate through intersection entries and apply data\n         */\n        this.applyIntersectionEntries = (entries) => {\n            const regionEntry = entries.find(x => x.target === this);\n            const anchorEntry = entries.find(x => x.target === this.anchorElement);\n            const viewportEntry = entries.find(x => x.target === this.viewportElement);\n            if (regionEntry === undefined ||\n                viewportEntry === undefined ||\n                anchorEntry === undefined) {\n                return false;\n            }\n            // don't update the dom unless there is a significant difference in rect positions\n            if (!this.regionVisible ||\n                this.forceUpdate ||\n                this.regionRect === undefined ||\n                this.anchorRect === undefined ||\n                this.viewportRect === undefined ||\n                this.isRectDifferent(this.anchorRect, anchorEntry.boundingClientRect) ||\n                this.isRectDifferent(this.viewportRect, viewportEntry.boundingClientRect) ||\n                this.isRectDifferent(this.regionRect, regionEntry.boundingClientRect)) {\n                this.regionRect = regionEntry.boundingClientRect;\n                this.anchorRect = anchorEntry.boundingClientRect;\n                if (this.viewportElement === document.documentElement) {\n                    this.viewportRect = new DOMRectReadOnly(viewportEntry.boundingClientRect.x +\n                        document.documentElement.scrollLeft, viewportEntry.boundingClientRect.y +\n                        document.documentElement.scrollTop, viewportEntry.boundingClientRect.width, viewportEntry.boundingClientRect.height);\n                }\n                else {\n                    this.viewportRect = viewportEntry.boundingClientRect;\n                }\n                this.updateRegionOffset();\n                this.forceUpdate = false;\n                return true;\n            }\n            return false;\n        };\n        /**\n         *  Update the offset values\n         */\n        this.updateRegionOffset = () => {\n            if (this.anchorRect && this.regionRect) {\n                this.baseHorizontalOffset =\n                    this.baseHorizontalOffset +\n                        (this.anchorRect.left - this.regionRect.left) +\n                        (this.translateX - this.baseHorizontalOffset);\n                this.baseVerticalOffset =\n                    this.baseVerticalOffset +\n                        (this.anchorRect.top - this.regionRect.top) +\n                        (this.translateY - this.baseVerticalOffset);\n            }\n        };\n        /**\n         *  compare rects to see if there is enough change to justify a DOM update\n         */\n        this.isRectDifferent = (rectA, rectB) => {\n            if (Math.abs(rectA.top - rectB.top) > this.updateThreshold ||\n                Math.abs(rectA.right - rectB.right) > this.updateThreshold ||\n                Math.abs(rectA.bottom - rectB.bottom) > this.updateThreshold ||\n                Math.abs(rectA.left - rectB.left) > this.updateThreshold) {\n                return true;\n            }\n            return false;\n        };\n        /**\n         *  Handle resize events\n         */\n        this.handleResize = (entries) => {\n            this.update();\n        };\n        /**\n         * resets the component\n         */\n        this.reset = () => {\n            if (!this.pendingReset) {\n                return;\n            }\n            this.pendingReset = false;\n            if (this.anchorElement === null) {\n                this.anchorElement = this.getAnchor();\n            }\n            if (this.viewportElement === null) {\n                this.viewportElement = this.getViewport();\n            }\n            this.currentDirection = getDirection(this);\n            this.startObservers();\n        };\n        /**\n         *  Recalculate layout related state values\n         */\n        this.updateLayout = () => {\n            let desiredVerticalPosition = undefined;\n            let desiredHorizontalPosition = undefined;\n            if (this.horizontalPositioningMode !== \"uncontrolled\") {\n                const horizontalOptions = this.getPositioningOptions(this.horizontalInset);\n                if (this.horizontalDefaultPosition === \"center\") {\n                    desiredHorizontalPosition = \"center\";\n                }\n                else if (this.horizontalDefaultPosition !== \"unset\") {\n                    let dirCorrectedHorizontalDefaultPosition = this\n                        .horizontalDefaultPosition;\n                    if (dirCorrectedHorizontalDefaultPosition === \"start\" ||\n                        dirCorrectedHorizontalDefaultPosition === \"end\") {\n                        // if direction changes we reset the layout\n                        const newDirection = getDirection(this);\n                        if (newDirection !== this.currentDirection) {\n                            this.currentDirection = newDirection;\n                            this.initialize();\n                            return;\n                        }\n                        if (this.currentDirection === Direction.ltr) {\n                            dirCorrectedHorizontalDefaultPosition =\n                                dirCorrectedHorizontalDefaultPosition === \"start\"\n                                    ? \"left\"\n                                    : \"right\";\n                        }\n                        else {\n                            dirCorrectedHorizontalDefaultPosition =\n                                dirCorrectedHorizontalDefaultPosition === \"start\"\n                                    ? \"right\"\n                                    : \"left\";\n                        }\n                    }\n                    switch (dirCorrectedHorizontalDefaultPosition) {\n                        case \"left\":\n                            desiredHorizontalPosition = this.horizontalInset\n                                ? \"insetStart\"\n                                : \"start\";\n                            break;\n                        case \"right\":\n                            desiredHorizontalPosition = this.horizontalInset\n                                ? \"insetEnd\"\n                                : \"end\";\n                            break;\n                    }\n                }\n                const horizontalThreshold = this.horizontalThreshold !== undefined\n                    ? this.horizontalThreshold\n                    : this.regionRect !== undefined\n                        ? this.regionRect.width\n                        : 0;\n                const anchorLeft = this.anchorRect !== undefined ? this.anchorRect.left : 0;\n                const anchorRight = this.anchorRect !== undefined ? this.anchorRect.right : 0;\n                const anchorWidth = this.anchorRect !== undefined ? this.anchorRect.width : 0;\n                const viewportLeft = this.viewportRect !== undefined ? this.viewportRect.left : 0;\n                const viewportRight = this.viewportRect !== undefined ? this.viewportRect.right : 0;\n                if (desiredHorizontalPosition === undefined ||\n                    (!(this.horizontalPositioningMode === \"locktodefault\") &&\n                        this.getAvailableSpace(desiredHorizontalPosition, anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) < horizontalThreshold)) {\n                    desiredHorizontalPosition =\n                        this.getAvailableSpace(horizontalOptions[0], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) >\n                            this.getAvailableSpace(horizontalOptions[1], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight)\n                            ? horizontalOptions[0]\n                            : horizontalOptions[1];\n                }\n            }\n            if (this.verticalPositioningMode !== \"uncontrolled\") {\n                const verticalOptions = this.getPositioningOptions(this.verticalInset);\n                if (this.verticalDefaultPosition === \"center\") {\n                    desiredVerticalPosition = \"center\";\n                }\n                else if (this.verticalDefaultPosition !== \"unset\") {\n                    switch (this.verticalDefaultPosition) {\n                        case \"top\":\n                            desiredVerticalPosition = this.verticalInset\n                                ? \"insetStart\"\n                                : \"start\";\n                            break;\n                        case \"bottom\":\n                            desiredVerticalPosition = this.verticalInset ? \"insetEnd\" : \"end\";\n                            break;\n                    }\n                }\n                const verticalThreshold = this.verticalThreshold !== undefined\n                    ? this.verticalThreshold\n                    : this.regionRect !== undefined\n                        ? this.regionRect.height\n                        : 0;\n                const anchorTop = this.anchorRect !== undefined ? this.anchorRect.top : 0;\n                const anchorBottom = this.anchorRect !== undefined ? this.anchorRect.bottom : 0;\n                const anchorHeight = this.anchorRect !== undefined ? this.anchorRect.height : 0;\n                const viewportTop = this.viewportRect !== undefined ? this.viewportRect.top : 0;\n                const viewportBottom = this.viewportRect !== undefined ? this.viewportRect.bottom : 0;\n                if (desiredVerticalPosition === undefined ||\n                    (!(this.verticalPositioningMode === \"locktodefault\") &&\n                        this.getAvailableSpace(desiredVerticalPosition, anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) < verticalThreshold)) {\n                    desiredVerticalPosition =\n                        this.getAvailableSpace(verticalOptions[0], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) >\n                            this.getAvailableSpace(verticalOptions[1], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom)\n                            ? verticalOptions[0]\n                            : verticalOptions[1];\n                }\n            }\n            const nextPositionerDimension = this.getNextRegionDimension(desiredHorizontalPosition, desiredVerticalPosition);\n            const positionChanged = this.horizontalPosition !== desiredHorizontalPosition ||\n                this.verticalPosition !== desiredVerticalPosition;\n            this.setHorizontalPosition(desiredHorizontalPosition, nextPositionerDimension);\n            this.setVerticalPosition(desiredVerticalPosition, nextPositionerDimension);\n            this.updateRegionStyle();\n            if (!this.initialLayoutComplete) {\n                this.initialLayoutComplete = true;\n                this.requestPositionUpdates();\n                return;\n            }\n            if (!this.regionVisible) {\n                this.regionVisible = true;\n                this.style.removeProperty(\"pointer-events\");\n                this.style.removeProperty(\"opacity\");\n                this.classList.toggle(\"loaded\", true);\n                this.$emit(\"loaded\", this, { bubbles: false });\n            }\n            this.updatePositionClasses();\n            if (positionChanged) {\n                // emit change event\n                this.$emit(\"positionchange\", this, { bubbles: false });\n            }\n        };\n        /**\n         *  Updates the style string applied to the region element as well as the css classes attached\n         *  to the root element\n         */\n        this.updateRegionStyle = () => {\n            this.style.width = this.regionWidth;\n            this.style.height = this.regionHeight;\n            this.style.transform = `translate(${this.translateX}px, ${this.translateY}px)`;\n        };\n        /**\n         *  Updates the css classes that reflect the current position of the element\n         */\n        this.updatePositionClasses = () => {\n            this.classList.toggle(\"top\", this.verticalPosition === \"start\");\n            this.classList.toggle(\"bottom\", this.verticalPosition === \"end\");\n            this.classList.toggle(\"inset-top\", this.verticalPosition === \"insetStart\");\n            this.classList.toggle(\"inset-bottom\", this.verticalPosition === \"insetEnd\");\n            this.classList.toggle(\"vertical-center\", this.verticalPosition === \"center\");\n            this.classList.toggle(\"left\", this.horizontalPosition === \"start\");\n            this.classList.toggle(\"right\", this.horizontalPosition === \"end\");\n            this.classList.toggle(\"inset-left\", this.horizontalPosition === \"insetStart\");\n            this.classList.toggle(\"inset-right\", this.horizontalPosition === \"insetEnd\");\n            this.classList.toggle(\"horizontal-center\", this.horizontalPosition === \"center\");\n        };\n        /**\n         * Get horizontal positioning state based on desired position\n         */\n        this.setHorizontalPosition = (desiredHorizontalPosition, nextPositionerDimension) => {\n            if (desiredHorizontalPosition === undefined ||\n                this.regionRect === undefined ||\n                this.anchorRect === undefined ||\n                this.viewportRect === undefined) {\n                return;\n            }\n            let nextRegionWidth = 0;\n            switch (this.horizontalScaling) {\n                case \"anchor\":\n                case \"fill\":\n                    nextRegionWidth = this.horizontalViewportLock\n                        ? this.viewportRect.width\n                        : nextPositionerDimension.width;\n                    this.regionWidth = `${nextRegionWidth}px`;\n                    break;\n                case \"content\":\n                    nextRegionWidth = this.regionRect.width;\n                    this.regionWidth = \"unset\";\n                    break;\n            }\n            let sizeDelta = 0;\n            switch (desiredHorizontalPosition) {\n                case \"start\":\n                    this.translateX = this.baseHorizontalOffset - nextRegionWidth;\n                    if (this.horizontalViewportLock &&\n                        this.anchorRect.left > this.viewportRect.right) {\n                        this.translateX =\n                            this.translateX -\n                                (this.anchorRect.left - this.viewportRect.right);\n                    }\n                    break;\n                case \"insetStart\":\n                    this.translateX =\n                        this.baseHorizontalOffset - nextRegionWidth + this.anchorRect.width;\n                    if (this.horizontalViewportLock &&\n                        this.anchorRect.right > this.viewportRect.right) {\n                        this.translateX =\n                            this.translateX -\n                                (this.anchorRect.right - this.viewportRect.right);\n                    }\n                    break;\n                case \"insetEnd\":\n                    this.translateX = this.baseHorizontalOffset;\n                    if (this.horizontalViewportLock &&\n                        this.anchorRect.left < this.viewportRect.left) {\n                        this.translateX =\n                            this.translateX - (this.anchorRect.left - this.viewportRect.left);\n                    }\n                    break;\n                case \"end\":\n                    this.translateX = this.baseHorizontalOffset + this.anchorRect.width;\n                    if (this.horizontalViewportLock &&\n                        this.anchorRect.right < this.viewportRect.left) {\n                        this.translateX =\n                            this.translateX -\n                                (this.anchorRect.right - this.viewportRect.left);\n                    }\n                    break;\n                case \"center\":\n                    sizeDelta = (this.anchorRect.width - nextRegionWidth) / 2;\n                    this.translateX = this.baseHorizontalOffset + sizeDelta;\n                    if (this.horizontalViewportLock) {\n                        const regionLeft = this.anchorRect.left + sizeDelta;\n                        const regionRight = this.anchorRect.right - sizeDelta;\n                        if (regionLeft < this.viewportRect.left &&\n                            !(regionRight > this.viewportRect.right)) {\n                            this.translateX =\n                                this.translateX - (regionLeft - this.viewportRect.left);\n                        }\n                        else if (regionRight > this.viewportRect.right &&\n                            !(regionLeft < this.viewportRect.left)) {\n                            this.translateX =\n                                this.translateX - (regionRight - this.viewportRect.right);\n                        }\n                    }\n                    break;\n            }\n            this.horizontalPosition = desiredHorizontalPosition;\n        };\n        /**\n         * Set vertical positioning state based on desired position\n         */\n        this.setVerticalPosition = (desiredVerticalPosition, nextPositionerDimension) => {\n            if (desiredVerticalPosition === undefined ||\n                this.regionRect === undefined ||\n                this.anchorRect === undefined ||\n                this.viewportRect === undefined) {\n                return;\n            }\n            let nextRegionHeight = 0;\n            switch (this.verticalScaling) {\n                case \"anchor\":\n                case \"fill\":\n                    nextRegionHeight = this.verticalViewportLock\n                        ? this.viewportRect.height\n                        : nextPositionerDimension.height;\n                    this.regionHeight = `${nextRegionHeight}px`;\n                    break;\n                case \"content\":\n                    nextRegionHeight = this.regionRect.height;\n                    this.regionHeight = \"unset\";\n                    break;\n            }\n            let sizeDelta = 0;\n            switch (desiredVerticalPosition) {\n                case \"start\":\n                    this.translateY = this.baseVerticalOffset - nextRegionHeight;\n                    if (this.verticalViewportLock &&\n                        this.anchorRect.top > this.viewportRect.bottom) {\n                        this.translateY =\n                            this.translateY -\n                                (this.anchorRect.top - this.viewportRect.bottom);\n                    }\n                    break;\n                case \"insetStart\":\n                    this.translateY =\n                        this.baseVerticalOffset - nextRegionHeight + this.anchorRect.height;\n                    if (this.verticalViewportLock &&\n                        this.anchorRect.bottom > this.viewportRect.bottom) {\n                        this.translateY =\n                            this.translateY -\n                                (this.anchorRect.bottom - this.viewportRect.bottom);\n                    }\n                    break;\n                case \"insetEnd\":\n                    this.translateY = this.baseVerticalOffset;\n                    if (this.verticalViewportLock &&\n                        this.anchorRect.top < this.viewportRect.top) {\n                        this.translateY =\n                            this.translateY - (this.anchorRect.top - this.viewportRect.top);\n                    }\n                    break;\n                case \"end\":\n                    this.translateY = this.baseVerticalOffset + this.anchorRect.height;\n                    if (this.verticalViewportLock &&\n                        this.anchorRect.bottom < this.viewportRect.top) {\n                        this.translateY =\n                            this.translateY -\n                                (this.anchorRect.bottom - this.viewportRect.top);\n                    }\n                    break;\n                case \"center\":\n                    sizeDelta = (this.anchorRect.height - nextRegionHeight) / 2;\n                    this.translateY = this.baseVerticalOffset + sizeDelta;\n                    if (this.verticalViewportLock) {\n                        const regionTop = this.anchorRect.top + sizeDelta;\n                        const regionBottom = this.anchorRect.bottom - sizeDelta;\n                        if (regionTop < this.viewportRect.top &&\n                            !(regionBottom > this.viewportRect.bottom)) {\n                            this.translateY =\n                                this.translateY - (regionTop - this.viewportRect.top);\n                        }\n                        else if (regionBottom > this.viewportRect.bottom &&\n                            !(regionTop < this.viewportRect.top)) {\n                            this.translateY =\n                                this.translateY - (regionBottom - this.viewportRect.bottom);\n                        }\n                    }\n            }\n            this.verticalPosition = desiredVerticalPosition;\n        };\n        /**\n         *  Get available positions based on positioning mode\n         */\n        this.getPositioningOptions = (inset) => {\n            if (inset) {\n                return [\"insetStart\", \"insetEnd\"];\n            }\n            return [\"start\", \"end\"];\n        };\n        /**\n         *  Get the space available for a particular relative position\n         */\n        this.getAvailableSpace = (positionOption, anchorStart, anchorEnd, anchorSpan, viewportStart, viewportEnd) => {\n            const spaceStart = anchorStart - viewportStart;\n            const spaceEnd = viewportEnd - (anchorStart + anchorSpan);\n            switch (positionOption) {\n                case \"start\":\n                    return spaceStart;\n                case \"insetStart\":\n                    return spaceStart + anchorSpan;\n                case \"insetEnd\":\n                    return spaceEnd + anchorSpan;\n                case \"end\":\n                    return spaceEnd;\n                case \"center\":\n                    return Math.min(spaceStart, spaceEnd) * 2 + anchorSpan;\n            }\n        };\n        /**\n         * Get region dimensions\n         */\n        this.getNextRegionDimension = (desiredHorizontalPosition, desiredVerticalPosition) => {\n            const newRegionDimension = {\n                height: this.regionRect !== undefined ? this.regionRect.height : 0,\n                width: this.regionRect !== undefined ? this.regionRect.width : 0,\n            };\n            if (desiredHorizontalPosition !== undefined &&\n                this.horizontalScaling === \"fill\") {\n                newRegionDimension.width = this.getAvailableSpace(desiredHorizontalPosition, this.anchorRect !== undefined ? this.anchorRect.left : 0, this.anchorRect !== undefined ? this.anchorRect.right : 0, this.anchorRect !== undefined ? this.anchorRect.width : 0, this.viewportRect !== undefined ? this.viewportRect.left : 0, this.viewportRect !== undefined ? this.viewportRect.right : 0);\n            }\n            else if (this.horizontalScaling === \"anchor\") {\n                newRegionDimension.width =\n                    this.anchorRect !== undefined ? this.anchorRect.width : 0;\n            }\n            if (desiredVerticalPosition !== undefined && this.verticalScaling === \"fill\") {\n                newRegionDimension.height = this.getAvailableSpace(desiredVerticalPosition, this.anchorRect !== undefined ? this.anchorRect.top : 0, this.anchorRect !== undefined ? this.anchorRect.bottom : 0, this.anchorRect !== undefined ? this.anchorRect.height : 0, this.viewportRect !== undefined ? this.viewportRect.top : 0, this.viewportRect !== undefined ? this.viewportRect.bottom : 0);\n            }\n            else if (this.verticalScaling === \"anchor\") {\n                newRegionDimension.height =\n                    this.anchorRect !== undefined ? this.anchorRect.height : 0;\n            }\n            return newRegionDimension;\n        };\n        /**\n         * starts event listeners that can trigger auto updating\n         */\n        this.startAutoUpdateEventListeners = () => {\n            window.addEventListener(eventResize, this.update, { passive: true });\n            window.addEventListener(eventScroll, this.update, {\n                passive: true,\n                capture: true,\n            });\n            if (this.resizeDetector !== null && this.viewportElement !== null) {\n                this.resizeDetector.observe(this.viewportElement);\n            }\n        };\n        /**\n         * stops event listeners that can trigger auto updating\n         */\n        this.stopAutoUpdateEventListeners = () => {\n            window.removeEventListener(eventResize, this.update);\n            window.removeEventListener(eventScroll, this.update);\n            if (this.resizeDetector !== null && this.viewportElement !== null) {\n                this.resizeDetector.unobserve(this.viewportElement);\n            }\n        };\n    }\n    anchorChanged() {\n        if (this.initialLayoutComplete) {\n            this.anchorElement = this.getAnchor();\n        }\n    }\n    viewportChanged() {\n        if (this.initialLayoutComplete) {\n            this.viewportElement = this.getViewport();\n        }\n    }\n    horizontalPositioningModeChanged() {\n        this.requestReset();\n    }\n    horizontalDefaultPositionChanged() {\n        this.updateForAttributeChange();\n    }\n    horizontalViewportLockChanged() {\n        this.updateForAttributeChange();\n    }\n    horizontalInsetChanged() {\n        this.updateForAttributeChange();\n    }\n    horizontalThresholdChanged() {\n        this.updateForAttributeChange();\n    }\n    horizontalScalingChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalPositioningModeChanged() {\n        this.requestReset();\n    }\n    verticalDefaultPositionChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalViewportLockChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalInsetChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalThresholdChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalScalingChanged() {\n        this.updateForAttributeChange();\n    }\n    fixedPlacementChanged() {\n        if (this.$fastController.isConnected &&\n            this.initialLayoutComplete) {\n            this.initialize();\n        }\n    }\n    autoUpdateModeChanged(prevMode, newMode) {\n        if (this.$fastController.isConnected &&\n            this.initialLayoutComplete) {\n            if (prevMode === \"auto\") {\n                this.stopAutoUpdateEventListeners();\n            }\n            if (newMode === \"auto\") {\n                this.startAutoUpdateEventListeners();\n            }\n        }\n    }\n    anchorElementChanged() {\n        this.requestReset();\n    }\n    viewportElementChanged() {\n        if (this.$fastController.isConnected &&\n            this.initialLayoutComplete) {\n            this.initialize();\n        }\n    }\n    /**\n     * @internal\n     */\n    connectedCallback() {\n        super.connectedCallback();\n        if (this.autoUpdateMode === \"auto\") {\n            this.startAutoUpdateEventListeners();\n        }\n        this.initialize();\n    }\n    /**\n     * @internal\n     */\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        if (this.autoUpdateMode === \"auto\") {\n            this.stopAutoUpdateEventListeners();\n        }\n        this.stopObservers();\n        this.disconnectResizeDetector();\n    }\n    /**\n     * @internal\n     */\n    adoptedCallback() {\n        this.initialize();\n    }\n    /**\n     * destroys the instance's resize observer\n     */\n    disconnectResizeDetector() {\n        if (this.resizeDetector !== null) {\n            this.resizeDetector.disconnect();\n            this.resizeDetector = null;\n        }\n    }\n    /**\n     * initializes the instance's resize observer\n     */\n    initializeResizeDetector() {\n        this.disconnectResizeDetector();\n        this.resizeDetector = new window.ResizeObserver(this.handleResize);\n    }\n    /**\n     * react to attribute changes that don't require a reset\n     */\n    updateForAttributeChange() {\n        if (this.$fastController.isConnected &&\n            this.initialLayoutComplete) {\n            this.forceUpdate = true;\n            this.update();\n        }\n    }\n    /**\n     * fully initializes the component\n     */\n    initialize() {\n        this.initializeResizeDetector();\n        if (this.anchorElement === null) {\n            this.anchorElement = this.getAnchor();\n        }\n        this.requestReset();\n    }\n    /**\n     * Request a reset if there are currently no open requests\n     */\n    requestReset() {\n        if (this.$fastController.isConnected &&\n            this.pendingReset === false) {\n            this.setInitialState();\n            DOM.queueUpdate(() => this.reset());\n            this.pendingReset = true;\n        }\n    }\n    /**\n     * sets the starting configuration for component internal values\n     */\n    setInitialState() {\n        this.initialLayoutComplete = false;\n        this.regionVisible = false;\n        this.translateX = 0;\n        this.translateY = 0;\n        this.baseHorizontalOffset = 0;\n        this.baseVerticalOffset = 0;\n        this.viewportRect = undefined;\n        this.regionRect = undefined;\n        this.anchorRect = undefined;\n        this.verticalPosition = undefined;\n        this.horizontalPosition = undefined;\n        this.style.opacity = \"0\";\n        this.style.pointerEvents = \"none\";\n        this.forceUpdate = false;\n        this.style.position = this.fixedPlacement ? \"fixed\" : \"absolute\";\n        this.updatePositionClasses();\n        this.updateRegionStyle();\n    }\n}\nAnchoredRegion.intersectionService = new IntersectionService();\n__decorate([\n    attr\n], AnchoredRegion.prototype, \"anchor\", void 0);\n__decorate([\n    attr\n], AnchoredRegion.prototype, \"viewport\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-positioning-mode\" })\n], AnchoredRegion.prototype, \"horizontalPositioningMode\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-default-position\" })\n], AnchoredRegion.prototype, \"horizontalDefaultPosition\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-viewport-lock\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"horizontalViewportLock\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-inset\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"horizontalInset\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-threshold\" })\n], AnchoredRegion.prototype, \"horizontalThreshold\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-scaling\" })\n], AnchoredRegion.prototype, \"horizontalScaling\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-positioning-mode\" })\n], AnchoredRegion.prototype, \"verticalPositioningMode\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-default-position\" })\n], AnchoredRegion.prototype, \"verticalDefaultPosition\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-viewport-lock\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"verticalViewportLock\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-inset\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"verticalInset\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-threshold\" })\n], AnchoredRegion.prototype, \"verticalThreshold\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-scaling\" })\n], AnchoredRegion.prototype, \"verticalScaling\", void 0);\n__decorate([\n    attr({ attribute: \"fixed-placement\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"fixedPlacement\", void 0);\n__decorate([\n    attr({ attribute: \"auto-update-mode\" })\n], AnchoredRegion.prototype, \"autoUpdateMode\", void 0);\n__decorate([\n    observable\n], AnchoredRegion.prototype, \"anchorElement\", void 0);\n__decorate([\n    observable\n], AnchoredRegion.prototype, \"viewportElement\", void 0);\n__decorate([\n    observable\n], AnchoredRegion.prototype, \"initialLayoutComplete\", void 0);\n"],"mappings":"AAAA,SAASA,UAAT,QAA2B,OAA3B;AACA,SAASC,IAAT,EAAeC,GAAf,EAAoBC,UAApB,QAAsC,yBAAtC;AACA,SAASC,SAAT,EAAoBC,WAApB,EAAiCC,WAAjC,QAAoD,+BAApD;AACA,SAASC,iBAAT,QAAkC,6CAAlC;AACA,SAASC,YAAT,QAA6B,2BAA7B;AACA,SAASC,mBAAT,QAAoC,sCAApC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,cAAN,SAA6BH,iBAA7B,CAA+C;EAClDI,WAAW,GAAG;IACV,MAAM,GAAGC,SAAT;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,MAAL,GAAc,EAAd;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,QAAL,GAAgB,EAAhB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,yBAAL,GAAiC,cAAjC;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,yBAAL,GAAiC,OAAjC;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,sBAAL,GAA8B,KAA9B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,eAAL,GAAuB,KAAvB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,iBAAL,GAAyB,SAAzB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,uBAAL,GAA+B,cAA/B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,uBAAL,GAA+B,OAA/B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,oBAAL,GAA4B,KAA5B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,aAAL,GAAqB,KAArB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,eAAL,GAAuB,SAAvB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;I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"},"metadata":{},"sourceType":"module"}