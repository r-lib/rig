{"ast":null,"code":"import _defineProperty from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _assertThisInitialized from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { DOM } from \"../dom.js\";\nimport { createMetadataLocator, FAST } from \"../platform.js\";\nimport { PropertyChangeNotifier, SubscriberSet } from \"./notifier.js\";\n/**\n * Common Observable APIs.\n * @public\n */\n\nexport var Observable = FAST.getById(2\n/* observable */\n, function () {\n  var volatileRegex = /(:|&&|\\|\\||if)/;\n  var notifierLookup = new WeakMap();\n  var queueUpdate = DOM.queueUpdate;\n  var watcher = void 0;\n\n  var createArrayObserver = function createArrayObserver(array) {\n    throw new Error(\"Must call enableArrayObservation before observing arrays.\");\n  };\n\n  function getNotifier(source) {\n    var found = source.$fastController || notifierLookup.get(source);\n\n    if (found === void 0) {\n      if (Array.isArray(source)) {\n        found = createArrayObserver(source);\n      } else {\n        notifierLookup.set(source, found = new PropertyChangeNotifier(source));\n      }\n    }\n\n    return found;\n  }\n\n  var getAccessors = createMetadataLocator();\n\n  var DefaultObservableAccessor = /*#__PURE__*/function () {\n    function DefaultObservableAccessor(name) {\n      _classCallCheck(this, DefaultObservableAccessor);\n\n      this.name = name;\n      this.field = \"_\".concat(name);\n      this.callback = \"\".concat(name, \"Changed\");\n    }\n\n    _createClass(DefaultObservableAccessor, [{\n      key: \"getValue\",\n      value: function getValue(source) {\n        if (watcher !== void 0) {\n          watcher.watch(source, this.name);\n        }\n\n        return source[this.field];\n      }\n    }, {\n      key: \"setValue\",\n      value: function setValue(source, newValue) {\n        var field = this.field;\n        var oldValue = source[field];\n\n        if (oldValue !== newValue) {\n          source[field] = newValue;\n          var callback = source[this.callback];\n\n          if (typeof callback === \"function\") {\n            callback.call(source, oldValue, newValue);\n          }\n\n          getNotifier(source).notify(this.name);\n        }\n      }\n    }]);\n\n    return DefaultObservableAccessor;\n  }();\n\n  var BindingObserverImplementation = /*#__PURE__*/function (_SubscriberSet) {\n    _inherits(BindingObserverImplementation, _SubscriberSet);\n\n    var _super = _createSuper(BindingObserverImplementation);\n\n    function BindingObserverImplementation(binding, initialSubscriber) {\n      var _this;\n\n      var isVolatileBinding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      _classCallCheck(this, BindingObserverImplementation);\n\n      _this = _super.call(this, binding, initialSubscriber);\n      _this.binding = binding;\n      _this.isVolatileBinding = isVolatileBinding;\n      _this.needsRefresh = true;\n      _this.needsQueue = true;\n      _this.first = _assertThisInitialized(_this);\n      _this.last = null;\n      _this.propertySource = void 0;\n      _this.propertyName = void 0;\n      _this.notifier = void 0;\n      _this.next = void 0;\n      return _this;\n    }\n\n    _createClass(BindingObserverImplementation, [{\n      key: \"observe\",\n      value: function observe(source, context) {\n        if (this.needsRefresh && this.last !== null) {\n          this.disconnect();\n        }\n\n        var previousWatcher = watcher;\n        watcher = this.needsRefresh ? this : void 0;\n        this.needsRefresh = this.isVolatileBinding;\n        var result = this.binding(source, context);\n        watcher = previousWatcher;\n        return result;\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect() {\n        if (this.last !== null) {\n          var current = this.first;\n\n          while (current !== void 0) {\n            current.notifier.unsubscribe(this, current.propertyName);\n            current = current.next;\n          }\n\n          this.last = null;\n          this.needsRefresh = this.needsQueue = true;\n        }\n      }\n    }, {\n      key: \"watch\",\n      value: function watch(propertySource, propertyName) {\n        var prev = this.last;\n        var notifier = getNotifier(propertySource);\n        var current = prev === null ? this.first : {};\n        current.propertySource = propertySource;\n        current.propertyName = propertyName;\n        current.notifier = notifier;\n        notifier.subscribe(this, propertyName);\n\n        if (prev !== null) {\n          if (!this.needsRefresh) {\n            // Declaring the variable prior to assignment below circumvents\n            // a bug in Angular's optimization process causing infinite recursion\n            // of this watch() method. Details https://github.com/microsoft/fast/issues/4969\n            var prevValue;\n            watcher = void 0;\n            /* eslint-disable-next-line */\n\n            prevValue = prev.propertySource[prev.propertyName];\n            /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n\n            watcher = this;\n\n            if (propertySource === prevValue) {\n              this.needsRefresh = true;\n            }\n          }\n\n          prev.next = current;\n        }\n\n        this.last = current;\n      }\n    }, {\n      key: \"handleChange\",\n      value: function handleChange() {\n        if (this.needsQueue) {\n          this.needsQueue = false;\n          queueUpdate(this);\n        }\n      }\n    }, {\n      key: \"call\",\n      value: function call() {\n        if (this.last !== null) {\n          this.needsQueue = true;\n          this.notify(this);\n        }\n      }\n    }, {\n      key: \"records\",\n      value: function records() {\n        var _next = this.first;\n        return _defineProperty({\n          next: function next() {\n            var current = _next;\n\n            if (current === undefined) {\n              return {\n                value: void 0,\n                done: true\n              };\n            } else {\n              _next = _next.next;\n              return {\n                value: current,\n                done: false\n              };\n            }\n          }\n        }, Symbol.iterator, function () {\n          return this;\n        });\n      }\n    }]);\n\n    return BindingObserverImplementation;\n  }(SubscriberSet);\n\n  return Object.freeze({\n    /**\n     * @internal\n     * @param factory - The factory used to create array observers.\n     */\n    setArrayObserverFactory: function setArrayObserverFactory(factory) {\n      createArrayObserver = factory;\n    },\n\n    /**\n     * Gets a notifier for an object or Array.\n     * @param source - The object or Array to get the notifier for.\n     */\n    getNotifier: getNotifier,\n\n    /**\n     * Records a property change for a source object.\n     * @param source - The object to record the change against.\n     * @param propertyName - The property to track as changed.\n     */\n    track: function track(source, propertyName) {\n      if (watcher !== void 0) {\n        watcher.watch(source, propertyName);\n      }\n    },\n\n    /**\n     * Notifies watchers that the currently executing property getter or function is volatile\n     * with respect to its observable dependencies.\n     */\n    trackVolatile: function trackVolatile() {\n      if (watcher !== void 0) {\n        watcher.needsRefresh = true;\n      }\n    },\n\n    /**\n     * Notifies subscribers of a source object of changes.\n     * @param source - the object to notify of changes.\n     * @param args - The change args to pass to subscribers.\n     */\n    notify: function notify(source, args) {\n      getNotifier(source).notify(args);\n    },\n\n    /**\n     * Defines an observable property on an object or prototype.\n     * @param target - The target object to define the observable on.\n     * @param nameOrAccessor - The name of the property to define as observable;\n     * or a custom accessor that specifies the property name and accessor implementation.\n     */\n    defineProperty: function defineProperty(target, nameOrAccessor) {\n      if (typeof nameOrAccessor === \"string\") {\n        nameOrAccessor = new DefaultObservableAccessor(nameOrAccessor);\n      }\n\n      getAccessors(target).push(nameOrAccessor);\n      Reflect.defineProperty(target, nameOrAccessor.name, {\n        enumerable: true,\n        get: function get() {\n          return nameOrAccessor.getValue(this);\n        },\n        set: function set(newValue) {\n          nameOrAccessor.setValue(this, newValue);\n        }\n      });\n    },\n\n    /**\n     * Finds all the observable accessors defined on the target,\n     * including its prototype chain.\n     * @param target - The target object to search for accessor on.\n     */\n    getAccessors: getAccessors,\n\n    /**\n     * Creates a {@link BindingObserver} that can watch the\n     * provided {@link Binding} for changes.\n     * @param binding - The binding to observe.\n     * @param initialSubscriber - An initial subscriber to changes in the binding value.\n     * @param isVolatileBinding - Indicates whether the binding's dependency list must be re-evaluated on every value evaluation.\n     */\n    binding: function binding(_binding, initialSubscriber) {\n      var isVolatileBinding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.isVolatileBinding(_binding);\n      return new BindingObserverImplementation(_binding, initialSubscriber, isVolatileBinding);\n    },\n\n    /**\n     * Determines whether a binding expression is volatile and needs to have its dependency list re-evaluated\n     * on every evaluation of the value.\n     * @param binding - The binding to inspect.\n     */\n    isVolatileBinding: function isVolatileBinding(binding) {\n      return volatileRegex.test(binding.toString());\n    }\n  });\n});\n/**\n * Decorator: Defines an observable property on the target.\n * @param target - The target to define the observable on.\n * @param nameOrAccessor - The property name or accessor to define the observable as.\n * @public\n */\n\nexport function observable(target, nameOrAccessor) {\n  Observable.defineProperty(target, nameOrAccessor);\n}\n/**\n * Decorator: Marks a property getter as having volatile observable dependencies.\n * @param target - The target that the property is defined on.\n * @param name - The property name.\n * @param name - The existing descriptor.\n * @public\n */\n\nexport function volatile(target, name, descriptor) {\n  return Object.assign({}, descriptor, {\n    get: function get() {\n      Observable.trackVolatile();\n      return descriptor.get.apply(this);\n    }\n  });\n}\nvar contextEvent = FAST.getById(3\n/* contextEvent */\n, function () {\n  var current = null;\n  return {\n    get: function get() {\n      return current;\n    },\n    set: function set(event) {\n      current = event;\n    }\n  };\n});\n/**\n * Provides additional contextual information available to behaviors and expressions.\n * @public\n */\n\nexport var ExecutionContext = /*#__PURE__*/function () {\n  function ExecutionContext() {\n    _classCallCheck(this, ExecutionContext);\n\n    /**\n     * The index of the current item within a repeat context.\n     */\n    this.index = 0;\n    /**\n     * The length of the current collection within a repeat context.\n     */\n\n    this.length = 0;\n    /**\n     * The parent data object within a repeat context.\n     */\n\n    this.parent = null;\n    /**\n     * The parent execution context when in nested context scenarios.\n     */\n\n    this.parentContext = null;\n  }\n  /**\n   * The current event within an event handler.\n   */\n\n\n  _createClass(ExecutionContext, [{\n    key: \"event\",\n    get: function get() {\n      return contextEvent.get();\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * has an even index.\n     */\n\n  }, {\n    key: \"isEven\",\n    get: function get() {\n      return this.index % 2 === 0;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * has an odd index.\n     */\n\n  }, {\n    key: \"isOdd\",\n    get: function get() {\n      return this.index % 2 !== 0;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * is the first item in the collection.\n     */\n\n  }, {\n    key: \"isFirst\",\n    get: function get() {\n      return this.index === 0;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * is somewhere in the middle of the collection.\n     */\n\n  }, {\n    key: \"isInMiddle\",\n    get: function get() {\n      return !this.isFirst && !this.isLast;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * is the last item in the collection.\n     */\n\n  }, {\n    key: \"isLast\",\n    get: function get() {\n      return this.index === this.length - 1;\n    }\n    /**\n     * Sets the event for the current execution context.\n     * @param event - The event to set.\n     * @internal\n     */\n\n  }], [{\n    key: \"setEvent\",\n    value: function setEvent(event) {\n      contextEvent.set(event);\n    }\n  }]);\n\n  return ExecutionContext;\n}();\nObservable.defineProperty(ExecutionContext.prototype, \"index\");\nObservable.defineProperty(ExecutionContext.prototype, \"length\");\n/**\n * The default execution context used in binding expressions.\n * @public\n */\n\nexport var defaultExecutionContext = Object.seal(new ExecutionContext());","map":{"version":3,"names":["DOM","createMetadataLocator","FAST","PropertyChangeNotifier","SubscriberSet","Observable","getById","volatileRegex","notifierLookup","WeakMap","queueUpdate","watcher","createArrayObserver","array","Error","getNotifier","source","found","$fastController","get","Array","isArray","set","getAccessors","DefaultObservableAccessor","name","field","callback","watch","newValue","oldValue","call","notify","BindingObserverImplementation","binding","initialSubscriber","isVolatileBinding","needsRefresh","needsQueue","first","last","propertySource","propertyName","notifier","next","context","disconnect","previousWatcher","result","current","unsubscribe","prev","subscribe","prevValue","undefined","value","done","Symbol","iterator","Object","freeze","setArrayObserverFactory","factory","track","trackVolatile","args","defineProperty","target","nameOrAccessor","push","Reflect","enumerable","getValue","setValue","test","toString","observable","volatile","descriptor","assign","apply","contextEvent","event","ExecutionContext","index","length","parent","parentContext","isFirst","isLast","prototype","defaultExecutionContext","seal"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-element/dist/esm/observation/observable.js"],"sourcesContent":["import { DOM } from \"../dom.js\";\nimport { createMetadataLocator, FAST } from \"../platform.js\";\nimport { PropertyChangeNotifier, SubscriberSet } from \"./notifier.js\";\n/**\n * Common Observable APIs.\n * @public\n */\nexport const Observable = FAST.getById(2 /* observable */, () => {\n    const volatileRegex = /(:|&&|\\|\\||if)/;\n    const notifierLookup = new WeakMap();\n    const queueUpdate = DOM.queueUpdate;\n    let watcher = void 0;\n    let createArrayObserver = (array) => {\n        throw new Error(\"Must call enableArrayObservation before observing arrays.\");\n    };\n    function getNotifier(source) {\n        let found = source.$fastController || notifierLookup.get(source);\n        if (found === void 0) {\n            if (Array.isArray(source)) {\n                found = createArrayObserver(source);\n            }\n            else {\n                notifierLookup.set(source, (found = new PropertyChangeNotifier(source)));\n            }\n        }\n        return found;\n    }\n    const getAccessors = createMetadataLocator();\n    class DefaultObservableAccessor {\n        constructor(name) {\n            this.name = name;\n            this.field = `_${name}`;\n            this.callback = `${name}Changed`;\n        }\n        getValue(source) {\n            if (watcher !== void 0) {\n                watcher.watch(source, this.name);\n            }\n            return source[this.field];\n        }\n        setValue(source, newValue) {\n            const field = this.field;\n            const oldValue = source[field];\n            if (oldValue !== newValue) {\n                source[field] = newValue;\n                const callback = source[this.callback];\n                if (typeof callback === \"function\") {\n                    callback.call(source, oldValue, newValue);\n                }\n                getNotifier(source).notify(this.name);\n            }\n        }\n    }\n    class BindingObserverImplementation extends SubscriberSet {\n        constructor(binding, initialSubscriber, isVolatileBinding = false) {\n            super(binding, initialSubscriber);\n            this.binding = binding;\n            this.isVolatileBinding = isVolatileBinding;\n            this.needsRefresh = true;\n            this.needsQueue = true;\n            this.first = this;\n            this.last = null;\n            this.propertySource = void 0;\n            this.propertyName = void 0;\n            this.notifier = void 0;\n            this.next = void 0;\n        }\n        observe(source, context) {\n            if (this.needsRefresh && this.last !== null) {\n                this.disconnect();\n            }\n            const previousWatcher = watcher;\n            watcher = this.needsRefresh ? this : void 0;\n            this.needsRefresh = this.isVolatileBinding;\n            const result = this.binding(source, context);\n            watcher = previousWatcher;\n            return result;\n        }\n        disconnect() {\n            if (this.last !== null) {\n                let current = this.first;\n                while (current !== void 0) {\n                    current.notifier.unsubscribe(this, current.propertyName);\n                    current = current.next;\n                }\n                this.last = null;\n                this.needsRefresh = this.needsQueue = true;\n            }\n        }\n        watch(propertySource, propertyName) {\n            const prev = this.last;\n            const notifier = getNotifier(propertySource);\n            const current = prev === null ? this.first : {};\n            current.propertySource = propertySource;\n            current.propertyName = propertyName;\n            current.notifier = notifier;\n            notifier.subscribe(this, propertyName);\n            if (prev !== null) {\n                if (!this.needsRefresh) {\n                    // Declaring the variable prior to assignment below circumvents\n                    // a bug in Angular's optimization process causing infinite recursion\n                    // of this watch() method. Details https://github.com/microsoft/fast/issues/4969\n                    let prevValue;\n                    watcher = void 0;\n                    /* eslint-disable-next-line */\n                    prevValue = prev.propertySource[prev.propertyName];\n                    /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n                    watcher = this;\n                    if (propertySource === prevValue) {\n                        this.needsRefresh = true;\n                    }\n                }\n                prev.next = current;\n            }\n            this.last = current;\n        }\n        handleChange() {\n            if (this.needsQueue) {\n                this.needsQueue = false;\n                queueUpdate(this);\n            }\n        }\n        call() {\n            if (this.last !== null) {\n                this.needsQueue = true;\n                this.notify(this);\n            }\n        }\n        records() {\n            let next = this.first;\n            return {\n                next: () => {\n                    const current = next;\n                    if (current === undefined) {\n                        return { value: void 0, done: true };\n                    }\n                    else {\n                        next = next.next;\n                        return {\n                            value: current,\n                            done: false,\n                        };\n                    }\n                },\n                [Symbol.iterator]: function () {\n                    return this;\n                },\n            };\n        }\n    }\n    return Object.freeze({\n        /**\n         * @internal\n         * @param factory - The factory used to create array observers.\n         */\n        setArrayObserverFactory(factory) {\n            createArrayObserver = factory;\n        },\n        /**\n         * Gets a notifier for an object or Array.\n         * @param source - The object or Array to get the notifier for.\n         */\n        getNotifier,\n        /**\n         * Records a property change for a source object.\n         * @param source - The object to record the change against.\n         * @param propertyName - The property to track as changed.\n         */\n        track(source, propertyName) {\n            if (watcher !== void 0) {\n                watcher.watch(source, propertyName);\n            }\n        },\n        /**\n         * Notifies watchers that the currently executing property getter or function is volatile\n         * with respect to its observable dependencies.\n         */\n        trackVolatile() {\n            if (watcher !== void 0) {\n                watcher.needsRefresh = true;\n            }\n        },\n        /**\n         * Notifies subscribers of a source object of changes.\n         * @param source - the object to notify of changes.\n         * @param args - The change args to pass to subscribers.\n         */\n        notify(source, args) {\n            getNotifier(source).notify(args);\n        },\n        /**\n         * Defines an observable property on an object or prototype.\n         * @param target - The target object to define the observable on.\n         * @param nameOrAccessor - The name of the property to define as observable;\n         * or a custom accessor that specifies the property name and accessor implementation.\n         */\n        defineProperty(target, nameOrAccessor) {\n            if (typeof nameOrAccessor === \"string\") {\n                nameOrAccessor = new DefaultObservableAccessor(nameOrAccessor);\n            }\n            getAccessors(target).push(nameOrAccessor);\n            Reflect.defineProperty(target, nameOrAccessor.name, {\n                enumerable: true,\n                get: function () {\n                    return nameOrAccessor.getValue(this);\n                },\n                set: function (newValue) {\n                    nameOrAccessor.setValue(this, newValue);\n                },\n            });\n        },\n        /**\n         * Finds all the observable accessors defined on the target,\n         * including its prototype chain.\n         * @param target - The target object to search for accessor on.\n         */\n        getAccessors,\n        /**\n         * Creates a {@link BindingObserver} that can watch the\n         * provided {@link Binding} for changes.\n         * @param binding - The binding to observe.\n         * @param initialSubscriber - An initial subscriber to changes in the binding value.\n         * @param isVolatileBinding - Indicates whether the binding's dependency list must be re-evaluated on every value evaluation.\n         */\n        binding(binding, initialSubscriber, isVolatileBinding = this.isVolatileBinding(binding)) {\n            return new BindingObserverImplementation(binding, initialSubscriber, isVolatileBinding);\n        },\n        /**\n         * Determines whether a binding expression is volatile and needs to have its dependency list re-evaluated\n         * on every evaluation of the value.\n         * @param binding - The binding to inspect.\n         */\n        isVolatileBinding(binding) {\n            return volatileRegex.test(binding.toString());\n        },\n    });\n});\n/**\n * Decorator: Defines an observable property on the target.\n * @param target - The target to define the observable on.\n * @param nameOrAccessor - The property name or accessor to define the observable as.\n * @public\n */\nexport function observable(target, nameOrAccessor) {\n    Observable.defineProperty(target, nameOrAccessor);\n}\n/**\n * Decorator: Marks a property getter as having volatile observable dependencies.\n * @param target - The target that the property is defined on.\n * @param name - The property name.\n * @param name - The existing descriptor.\n * @public\n */\nexport function volatile(target, name, descriptor) {\n    return Object.assign({}, descriptor, {\n        get: function () {\n            Observable.trackVolatile();\n            return descriptor.get.apply(this);\n        },\n    });\n}\nconst contextEvent = FAST.getById(3 /* contextEvent */, () => {\n    let current = null;\n    return {\n        get() {\n            return current;\n        },\n        set(event) {\n            current = event;\n        },\n    };\n});\n/**\n * Provides additional contextual information available to behaviors and expressions.\n * @public\n */\nexport class ExecutionContext {\n    constructor() {\n        /**\n         * The index of the current item within a repeat context.\n         */\n        this.index = 0;\n        /**\n         * The length of the current collection within a repeat context.\n         */\n        this.length = 0;\n        /**\n         * The parent data object within a repeat context.\n         */\n        this.parent = null;\n        /**\n         * The parent execution context when in nested context scenarios.\n         */\n        this.parentContext = null;\n    }\n    /**\n     * The current event within an event handler.\n     */\n    get event() {\n        return contextEvent.get();\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * has an even index.\n     */\n    get isEven() {\n        return this.index % 2 === 0;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * has an odd index.\n     */\n    get isOdd() {\n        return this.index % 2 !== 0;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * is the first item in the collection.\n     */\n    get isFirst() {\n        return this.index === 0;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * is somewhere in the middle of the collection.\n     */\n    get isInMiddle() {\n        return !this.isFirst && !this.isLast;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * is the last item in the collection.\n     */\n    get isLast() {\n        return this.index === this.length - 1;\n    }\n    /**\n     * Sets the event for the current execution context.\n     * @param event - The event to set.\n     * @internal\n     */\n    static setEvent(event) {\n        contextEvent.set(event);\n    }\n}\nObservable.defineProperty(ExecutionContext.prototype, \"index\");\nObservable.defineProperty(ExecutionContext.prototype, \"length\");\n/**\n * The default execution context used in binding expressions.\n * @public\n */\nexport const defaultExecutionContext = Object.seal(new ExecutionContext());\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}