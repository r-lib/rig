{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { CSSDirective, defaultExecutionContext, FASTElement, observable, Observable } from \"@microsoft/fast-element\";\nimport { composedParent } from \"../utilities/composed-parent.js\";\nimport { composedContains } from \"../utilities/composed-contains.js\";\nimport { PropertyTargetManager, RootStyleSheetTarget } from \"./custom-property-manager.js\";\nimport { defaultElement } from \"./custom-property-manager.js\";\n/**\n * Implementation of {@link (DesignToken:interface)}\n */\n\nclass DesignTokenImpl extends CSSDirective {\n  constructor(configuration) {\n    super();\n    this.subscribers = new WeakMap();\n    this._appliedTo = new Set();\n    this.name = configuration.name;\n\n    if (configuration.cssCustomPropertyName !== null) {\n      this.cssCustomProperty = `--${configuration.cssCustomPropertyName}`;\n      this.cssVar = `var(${this.cssCustomProperty})`;\n    }\n\n    this.id = DesignTokenImpl.uniqueId();\n    DesignTokenImpl.tokensById.set(this.id, this);\n  }\n\n  get appliedTo() {\n    return [...this._appliedTo];\n  }\n\n  static from(nameOrConfig) {\n    return new DesignTokenImpl({\n      name: typeof nameOrConfig === \"string\" ? nameOrConfig : nameOrConfig.name,\n      cssCustomPropertyName: typeof nameOrConfig === \"string\" ? nameOrConfig : nameOrConfig.cssCustomPropertyName === void 0 ? nameOrConfig.name : nameOrConfig.cssCustomPropertyName\n    });\n  }\n\n  static isCSSDesignToken(token) {\n    return typeof token.cssCustomProperty === \"string\";\n  }\n\n  static isDerivedDesignTokenValue(value) {\n    return typeof value === \"function\";\n  }\n  /**\n   * Gets a token by ID. Returns undefined if the token was not found.\n   * @param id - The ID of the token\n   * @returns\n   */\n\n\n  static getTokenById(id) {\n    return DesignTokenImpl.tokensById.get(id);\n  }\n\n  getOrCreateSubscriberSet() {\n    let target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\n    return this.subscribers.get(target) || this.subscribers.set(target, new Set()) && this.subscribers.get(target);\n  }\n\n  createCSS() {\n    return this.cssVar || \"\";\n  }\n\n  getValueFor(element) {\n    const value = DesignTokenNode.getOrCreate(element).get(this);\n\n    if (value !== undefined) {\n      return value;\n    }\n\n    throw new Error(`Value could not be retrieved for token named \"${this.name}\". Ensure the value is set for ${element} or an ancestor of ${element}.`);\n  }\n\n  setValueFor(element, value) {\n    this._appliedTo.add(element);\n\n    if (value instanceof DesignTokenImpl) {\n      value = this.alias(value);\n    }\n\n    DesignTokenNode.getOrCreate(element).set(this, value);\n    return this;\n  }\n\n  deleteValueFor(element) {\n    this._appliedTo.delete(element);\n\n    if (DesignTokenNode.existsFor(element)) {\n      DesignTokenNode.getOrCreate(element).delete(this);\n    }\n\n    return this;\n  }\n\n  withDefault(value) {\n    this.setValueFor(defaultElement, value);\n    return this;\n  }\n\n  subscribe(subscriber, target) {\n    const subscriberSet = this.getOrCreateSubscriberSet(target);\n\n    if (target && !DesignTokenNode.existsFor(target)) {\n      DesignTokenNode.getOrCreate(target);\n    }\n\n    if (!subscriberSet.has(subscriber)) {\n      subscriberSet.add(subscriber);\n    }\n  }\n\n  unsubscribe(subscriber, target) {\n    const list = this.subscribers.get(target || this);\n\n    if (list && list.has(subscriber)) {\n      list.delete(subscriber);\n    }\n  }\n  /**\n   * Notifies subscribers that the value for an element has changed.\n   * @param element - The element to emit a notification for\n   */\n\n\n  notify(element) {\n    const record = Object.freeze({\n      token: this,\n      target: element\n    });\n\n    if (this.subscribers.has(this)) {\n      this.subscribers.get(this).forEach(sub => sub.handleChange(record));\n    }\n\n    if (this.subscribers.has(element)) {\n      this.subscribers.get(element).forEach(sub => sub.handleChange(record));\n    }\n  }\n  /**\n   * Alias the token to the provided token.\n   * @param token - the token to alias to\n   */\n\n\n  alias(token) {\n    return target => token.getValueFor(target);\n  }\n\n}\n\nDesignTokenImpl.uniqueId = (() => {\n  let id = 0;\n  return () => {\n    id++;\n    return id.toString(16);\n  };\n})();\n/**\n * Token storage by token ID\n */\n\n\nDesignTokenImpl.tokensById = new Map();\n\nclass CustomPropertyReflector {\n  startReflection(token, target) {\n    token.subscribe(this, target);\n    this.handleChange({\n      token,\n      target\n    });\n  }\n\n  stopReflection(token, target) {\n    token.unsubscribe(this, target);\n    this.remove(token, target);\n  }\n\n  handleChange(record) {\n    const {\n      token,\n      target\n    } = record;\n    this.add(token, target);\n  }\n\n  add(token, target) {\n    PropertyTargetManager.getOrCreate(target).setProperty(token.cssCustomProperty, this.resolveCSSValue(DesignTokenNode.getOrCreate(target).get(token)));\n  }\n\n  remove(token, target) {\n    PropertyTargetManager.getOrCreate(target).removeProperty(token.cssCustomProperty);\n  }\n\n  resolveCSSValue(value) {\n    return value && typeof value.createCSS === \"function\" ? value.createCSS() : value;\n  }\n\n}\n/**\n * A light wrapper around BindingObserver to handle value caching and\n * token notification\n */\n\n\nclass DesignTokenBindingObserver {\n  constructor(source, token, node) {\n    this.source = source;\n    this.token = token;\n    this.node = node;\n    this.dependencies = new Set();\n    this.observer = Observable.binding(source, this, false); // This is a little bit hacky because it's using internal APIs of BindingObserverImpl.\n    // BindingObserverImpl queues updates to batch it's notifications which doesn't work for this\n    // scenario because the DesignToken.getValueFor API is not async. Without this, using DesignToken.getValueFor()\n    // after DesignToken.setValueFor() when setting a dependency of the value being retrieved can return a stale\n    // value. Assigning .handleChange to .call forces immediate invocation of this classes handleChange() method,\n    // allowing resolution of values synchronously.\n    // TODO: https://github.com/microsoft/fast/issues/5110\n\n    this.observer.handleChange = this.observer.call;\n    this.handleChange();\n  }\n\n  disconnect() {\n    this.observer.disconnect();\n  }\n  /**\n   * @internal\n   */\n\n\n  handleChange() {\n    this.node.store.set(this.token, this.observer.observe(this.node.target, defaultExecutionContext));\n  }\n\n}\n/**\n * Stores resolved token/value pairs and notifies on changes\n */\n\n\nclass Store {\n  constructor() {\n    this.values = new Map();\n  }\n\n  set(token, value) {\n    if (this.values.get(token) !== value) {\n      this.values.set(token, value);\n      Observable.getNotifier(this).notify(token.id);\n    }\n  }\n\n  get(token) {\n    Observable.track(this, token.id);\n    return this.values.get(token);\n  }\n\n  delete(token) {\n    this.values.delete(token);\n  }\n\n  all() {\n    return this.values.entries();\n  }\n\n}\n\nconst nodeCache = new WeakMap();\nconst childToParent = new WeakMap();\n/**\n * A node responsible for setting and getting token values,\n * emitting values to CSS custom properties, and maintaining\n * inheritance structures.\n */\n\nclass DesignTokenNode {\n  constructor(target) {\n    this.target = target;\n    /**\n     * Stores all resolved token values for a node\n     */\n\n    this.store = new Store();\n    /**\n     * All children assigned to the node\n     */\n\n    this.children = [];\n    /**\n     * All values explicitly assigned to the node in their raw form\n     */\n\n    this.assignedValues = new Map();\n    /**\n     * Tokens currently being reflected to CSS custom properties\n     */\n\n    this.reflecting = new Set();\n    /**\n     * Binding observers for assigned and inherited derived values.\n     */\n\n    this.bindingObservers = new Map();\n    /**\n     * Emits notifications to token when token values\n     * change the DesignTokenNode\n     */\n\n    this.tokenValueChangeHandler = {\n      handleChange: (source, arg) => {\n        const token = DesignTokenImpl.getTokenById(arg);\n\n        if (token) {\n          // Notify any token subscribers\n          token.notify(this.target);\n\n          if (DesignTokenImpl.isCSSDesignToken(token)) {\n            const parent = this.parent;\n            const reflecting = this.isReflecting(token);\n\n            if (parent) {\n              const parentValue = parent.get(token);\n              const sourceValue = source.get(token);\n\n              if (parentValue !== sourceValue && !reflecting) {\n                this.reflectToCSS(token);\n              } else if (parentValue === sourceValue && reflecting) {\n                this.stopReflectToCSS(token);\n              }\n            } else if (!reflecting) {\n              this.reflectToCSS(token);\n            }\n          }\n        }\n      }\n    };\n    nodeCache.set(target, this); // Map store change notifications to token change notifications\n\n    Observable.getNotifier(this.store).subscribe(this.tokenValueChangeHandler);\n\n    if (target instanceof FASTElement) {\n      target.$fastController.addBehaviors([this]);\n    } else if (target.isConnected) {\n      this.bind();\n    }\n  }\n  /**\n   * Returns a DesignTokenNode for an element.\n   * Creates a new instance if one does not already exist for a node,\n   * otherwise returns the cached instance\n   *\n   * @param target - The HTML element to retrieve a DesignTokenNode for\n   */\n\n\n  static getOrCreate(target) {\n    return nodeCache.get(target) || new DesignTokenNode(target);\n  }\n  /**\n   * Determines if a DesignTokenNode has been created for a target\n   * @param target - The element to test\n   */\n\n\n  static existsFor(target) {\n    return nodeCache.has(target);\n  }\n  /**\n   * Searches for and return the nearest parent DesignTokenNode.\n   * Null is returned if no node is found or the node provided is for a default element.\n   */\n\n\n  static findParent(node) {\n    if (!(defaultElement === node.target)) {\n      let parent = composedParent(node.target);\n\n      while (parent !== null) {\n        if (nodeCache.has(parent)) {\n          return nodeCache.get(parent);\n        }\n\n        parent = composedParent(parent);\n      }\n\n      return DesignTokenNode.getOrCreate(defaultElement);\n    }\n\n    return null;\n  }\n  /**\n   * Finds the closest node with a value explicitly assigned for a token, otherwise null.\n   * @param token - The token to look for\n   * @param start - The node to start looking for value assignment\n   * @returns\n   */\n\n\n  static findClosestAssignedNode(token, start) {\n    let current = start;\n\n    do {\n      if (current.has(token)) {\n        return current;\n      }\n\n      current = current.parent ? current.parent : current.target !== defaultElement ? DesignTokenNode.getOrCreate(defaultElement) : null;\n    } while (current !== null);\n\n    return null;\n  }\n  /**\n   * The parent DesignTokenNode, or null.\n   */\n\n\n  get parent() {\n    return childToParent.get(this) || null;\n  }\n  /**\n   * Checks if a token has been assigned an explicit value the node.\n   * @param token - the token to check.\n   */\n\n\n  has(token) {\n    return this.assignedValues.has(token);\n  }\n  /**\n   * Gets the value of a token for a node\n   * @param token - The token to retrieve the value for\n   * @returns\n   */\n\n\n  get(token) {\n    const value = this.store.get(token);\n\n    if (value !== undefined) {\n      return value;\n    }\n\n    const raw = this.getRaw(token);\n\n    if (raw !== undefined) {\n      this.hydrate(token, raw);\n      return this.get(token);\n    }\n  }\n  /**\n   * Retrieves the raw assigned value of a token from the nearest assigned node.\n   * @param token - The token to retrieve a raw value for\n   * @returns\n   */\n\n\n  getRaw(token) {\n    var _a;\n\n    if (this.assignedValues.has(token)) {\n      return this.assignedValues.get(token);\n    }\n\n    return (_a = DesignTokenNode.findClosestAssignedNode(token, this)) === null || _a === void 0 ? void 0 : _a.getRaw(token);\n  }\n  /**\n   * Sets a token to a value for a node\n   * @param token - The token to set\n   * @param value - The value to set the token to\n   */\n\n\n  set(token, value) {\n    if (DesignTokenImpl.isDerivedDesignTokenValue(this.assignedValues.get(token))) {\n      this.tearDownBindingObserver(token);\n    }\n\n    this.assignedValues.set(token, value);\n\n    if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {\n      this.setupBindingObserver(token, value);\n    } else {\n      this.store.set(token, value);\n    }\n  }\n  /**\n   * Deletes a token value for the node.\n   * @param token - The token to delete the value for\n   */\n\n\n  delete(token) {\n    this.assignedValues.delete(token);\n    this.tearDownBindingObserver(token);\n    const upstream = this.getRaw(token);\n\n    if (upstream) {\n      this.hydrate(token, upstream);\n    } else {\n      this.store.delete(token);\n    }\n  }\n  /**\n   * Invoked when the DesignTokenNode.target is attached to the document\n   */\n\n\n  bind() {\n    const parent = DesignTokenNode.findParent(this);\n\n    if (parent) {\n      parent.appendChild(this);\n    }\n\n    for (const key of this.assignedValues.keys()) {\n      key.notify(this.target);\n    }\n  }\n  /**\n   * Invoked when the DesignTokenNode.target is detached from the document\n   */\n\n\n  unbind() {\n    if (this.parent) {\n      const parent = childToParent.get(this);\n      parent.removeChild(this);\n    }\n  }\n  /**\n   * Appends a child to a parent DesignTokenNode.\n   * @param child - The child to append to the node\n   */\n\n\n  appendChild(child) {\n    if (child.parent) {\n      childToParent.get(child).removeChild(child);\n    }\n\n    const reParent = this.children.filter(x => child.contains(x));\n    childToParent.set(child, this);\n    this.children.push(child);\n    reParent.forEach(x => child.appendChild(x));\n    Observable.getNotifier(this.store).subscribe(child); // How can we not notify *every* subscriber?\n\n    for (const [token, value] of this.store.all()) {\n      child.hydrate(token, this.bindingObservers.has(token) ? this.getRaw(token) : value);\n    }\n  }\n  /**\n   * Removes a child from a node.\n   * @param child - The child to remove.\n   */\n\n\n  removeChild(child) {\n    const childIndex = this.children.indexOf(child);\n\n    if (childIndex !== -1) {\n      this.children.splice(childIndex, 1);\n    }\n\n    Observable.getNotifier(this.store).unsubscribe(child);\n    return child.parent === this ? childToParent.delete(child) : false;\n  }\n  /**\n   * Tests whether a provided node is contained by\n   * the calling node.\n   * @param test - The node to test\n   */\n\n\n  contains(test) {\n    return composedContains(this.target, test.target);\n  }\n  /**\n   * Instructs the node to reflect a design token for the provided token.\n   * @param token - The design token to reflect\n   */\n\n\n  reflectToCSS(token) {\n    if (!this.isReflecting(token)) {\n      this.reflecting.add(token);\n      DesignTokenNode.cssCustomPropertyReflector.startReflection(token, this.target);\n    }\n  }\n  /**\n   * Stops reflecting a DesignToken to CSS\n   * @param token - The design token to stop reflecting\n   */\n\n\n  stopReflectToCSS(token) {\n    if (this.isReflecting(token)) {\n      this.reflecting.delete(token);\n      DesignTokenNode.cssCustomPropertyReflector.stopReflection(token, this.target);\n    }\n  }\n  /**\n   * Determines if a token is being reflected to CSS for a node.\n   * @param token - The token to check for reflection\n   * @returns\n   */\n\n\n  isReflecting(token) {\n    return this.reflecting.has(token);\n  }\n  /**\n   * Handle changes to upstream tokens\n   * @param source - The parent DesignTokenNode\n   * @param property - The token ID that changed\n   */\n\n\n  handleChange(source, property) {\n    const token = DesignTokenImpl.getTokenById(property);\n\n    if (!token) {\n      return;\n    }\n\n    this.hydrate(token, this.getRaw(token));\n  }\n  /**\n   * Hydrates a token with a DesignTokenValue, making retrieval available.\n   * @param token - The token to hydrate\n   * @param value - The value to hydrate\n   */\n\n\n  hydrate(token, value) {\n    if (!this.has(token)) {\n      const observer = this.bindingObservers.get(token);\n\n      if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {\n        if (observer) {\n          // If the binding source doesn't match, we need\n          // to update the binding\n          if (observer.source !== value) {\n            this.tearDownBindingObserver(token);\n            this.setupBindingObserver(token, value);\n          }\n        } else {\n          this.setupBindingObserver(token, value);\n        }\n      } else {\n        if (observer) {\n          this.tearDownBindingObserver(token);\n        }\n\n        this.store.set(token, value);\n      }\n    }\n  }\n  /**\n   * Sets up a binding observer for a derived token value that notifies token\n   * subscribers on change.\n   *\n   * @param token - The token to notify when the binding updates\n   * @param source - The binding source\n   */\n\n\n  setupBindingObserver(token, source) {\n    const binding = new DesignTokenBindingObserver(source, token, this);\n    this.bindingObservers.set(token, binding);\n    return binding;\n  }\n  /**\n   * Tear down a binding observer for a token.\n   */\n\n\n  tearDownBindingObserver(token) {\n    if (this.bindingObservers.has(token)) {\n      this.bindingObservers.get(token).disconnect();\n      this.bindingObservers.delete(token);\n      return true;\n    }\n\n    return false;\n  }\n\n}\n/**\n * Responsible for reflecting tokens to CSS custom properties\n */\n\n\nDesignTokenNode.cssCustomPropertyReflector = new CustomPropertyReflector();\n\n__decorate([observable], DesignTokenNode.prototype, \"children\", void 0);\n\nfunction create(nameOrConfig) {\n  return DesignTokenImpl.from(nameOrConfig);\n}\n/* eslint-enable @typescript-eslint/no-unused-vars */\n\n/**\n * Factory object for creating {@link (DesignToken:interface)} instances.\n * @public\n */\n\n\nexport const DesignToken = Object.freeze({\n  create,\n\n  /**\n   * Informs DesignToken that an HTMLElement for which tokens have\n   * been set has been connected to the document.\n   *\n   * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness\n   * in all scenarios, so invoking this method manually is necessary when:\n   *\n   * 1. Token values are set for an HTMLElement.\n   * 2. The HTMLElement does not inherit from FASTElement.\n   * 3. The HTMLElement is not connected to the document when token values are set.\n   *\n   * @param element - The element to notify\n   * @returns - true if notification was successful, otherwise false.\n   */\n  notifyConnection(element) {\n    if (!element.isConnected || !DesignTokenNode.existsFor(element)) {\n      return false;\n    }\n\n    DesignTokenNode.getOrCreate(element).bind();\n    return true;\n  },\n\n  /**\n   * Informs DesignToken that an HTMLElement for which tokens have\n   * been set has been disconnected to the document.\n   *\n   * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness\n   * in all scenarios, so invoking this method manually is necessary when:\n   *\n   * 1. Token values are set for an HTMLElement.\n   * 2. The HTMLElement does not inherit from FASTElement.\n   *\n   * @param element - The element to notify\n   * @returns - true if notification was successful, otherwise false.\n   */\n  notifyDisconnection(element) {\n    if (element.isConnected || !DesignTokenNode.existsFor(element)) {\n      return false;\n    }\n\n    DesignTokenNode.getOrCreate(element).unbind();\n    return true;\n  },\n\n  /**\n   * Registers and element or document as a DesignToken root.\n   * {@link CSSDesignToken | CSSDesignTokens} with default values assigned via\n   * {@link (DesignToken:interface).withDefault} will emit CSS custom properties to all\n   * registered roots.\n   * @param target - The root to register\n   */\n  registerRoot() {\n    let target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultElement;\n    RootStyleSheetTarget.registerRoot(target);\n  },\n\n  /**\n   * Unregister an element or document as a DesignToken root.\n   * @param target - The root to deregister\n   */\n  unregisterRoot() {\n    let target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultElement;\n    RootStyleSheetTarget.unregisterRoot(target);\n  }\n\n});\n/* eslint-enable @typescript-eslint/no-non-null-assertion */","map":{"version":3,"names":["__decorate","CSSDirective","defaultExecutionContext","FASTElement","observable","Observable","composedParent","composedContains","PropertyTargetManager","RootStyleSheetTarget","defaultElement","DesignTokenImpl","constructor","configuration","subscribers","WeakMap","_appliedTo","Set","name","cssCustomPropertyName","cssCustomProperty","cssVar","id","uniqueId","tokensById","set","appliedTo","from","nameOrConfig","isCSSDesignToken","token","isDerivedDesignTokenValue","value","getTokenById","get","getOrCreateSubscriberSet","target","createCSS","getValueFor","element","DesignTokenNode","getOrCreate","undefined","Error","setValueFor","add","alias","deleteValueFor","delete","existsFor","withDefault","subscribe","subscriber","subscriberSet","has","unsubscribe","list","notify","record","Object","freeze","forEach","sub","handleChange","toString","Map","CustomPropertyReflector","startReflection","stopReflection","remove","setProperty","resolveCSSValue","removeProperty","DesignTokenBindingObserver","source","node","dependencies","observer","binding","call","disconnect","store","observe","Store","values","getNotifier","track","all","entries","nodeCache","childToParent","children","assignedValues","reflecting","bindingObservers","tokenValueChangeHandler","arg","parent","isReflecting","parentValue","sourceValue","reflectToCSS","stopReflectToCSS","$fastController","addBehaviors","isConnected","bind","findParent","findClosestAssignedNode","start","current","raw","getRaw","hydrate","_a","tearDownBindingObserver","setupBindingObserver","upstream","appendChild","key","keys","unbind","removeChild","child","reParent","filter","x","contains","push","childIndex","indexOf","splice","test","cssCustomPropertyReflector","property","prototype","create","DesignToken","notifyConnection","notifyDisconnection","registerRoot","unregisterRoot"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/design-token/design-token.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { CSSDirective, defaultExecutionContext, FASTElement, observable, Observable, } from \"@microsoft/fast-element\";\nimport { composedParent } from \"../utilities/composed-parent.js\";\nimport { composedContains } from \"../utilities/composed-contains.js\";\nimport { PropertyTargetManager, RootStyleSheetTarget, } from \"./custom-property-manager.js\";\nimport { defaultElement } from \"./custom-property-manager.js\";\n/**\n * Implementation of {@link (DesignToken:interface)}\n */\nclass DesignTokenImpl extends CSSDirective {\n    constructor(configuration) {\n        super();\n        this.subscribers = new WeakMap();\n        this._appliedTo = new Set();\n        this.name = configuration.name;\n        if (configuration.cssCustomPropertyName !== null) {\n            this.cssCustomProperty = `--${configuration.cssCustomPropertyName}`;\n            this.cssVar = `var(${this.cssCustomProperty})`;\n        }\n        this.id = DesignTokenImpl.uniqueId();\n        DesignTokenImpl.tokensById.set(this.id, this);\n    }\n    get appliedTo() {\n        return [...this._appliedTo];\n    }\n    static from(nameOrConfig) {\n        return new DesignTokenImpl({\n            name: typeof nameOrConfig === \"string\" ? nameOrConfig : nameOrConfig.name,\n            cssCustomPropertyName: typeof nameOrConfig === \"string\"\n                ? nameOrConfig\n                : nameOrConfig.cssCustomPropertyName === void 0\n                    ? nameOrConfig.name\n                    : nameOrConfig.cssCustomPropertyName,\n        });\n    }\n    static isCSSDesignToken(token) {\n        return typeof token.cssCustomProperty === \"string\";\n    }\n    static isDerivedDesignTokenValue(value) {\n        return typeof value === \"function\";\n    }\n    /**\n     * Gets a token by ID. Returns undefined if the token was not found.\n     * @param id - The ID of the token\n     * @returns\n     */\n    static getTokenById(id) {\n        return DesignTokenImpl.tokensById.get(id);\n    }\n    getOrCreateSubscriberSet(target = this) {\n        return (this.subscribers.get(target) ||\n            (this.subscribers.set(target, new Set()) && this.subscribers.get(target)));\n    }\n    createCSS() {\n        return this.cssVar || \"\";\n    }\n    getValueFor(element) {\n        const value = DesignTokenNode.getOrCreate(element).get(this);\n        if (value !== undefined) {\n            return value;\n        }\n        throw new Error(`Value could not be retrieved for token named \"${this.name}\". Ensure the value is set for ${element} or an ancestor of ${element}.`);\n    }\n    setValueFor(element, value) {\n        this._appliedTo.add(element);\n        if (value instanceof DesignTokenImpl) {\n            value = this.alias(value);\n        }\n        DesignTokenNode.getOrCreate(element).set(this, value);\n        return this;\n    }\n    deleteValueFor(element) {\n        this._appliedTo.delete(element);\n        if (DesignTokenNode.existsFor(element)) {\n            DesignTokenNode.getOrCreate(element).delete(this);\n        }\n        return this;\n    }\n    withDefault(value) {\n        this.setValueFor(defaultElement, value);\n        return this;\n    }\n    subscribe(subscriber, target) {\n        const subscriberSet = this.getOrCreateSubscriberSet(target);\n        if (target && !DesignTokenNode.existsFor(target)) {\n            DesignTokenNode.getOrCreate(target);\n        }\n        if (!subscriberSet.has(subscriber)) {\n            subscriberSet.add(subscriber);\n        }\n    }\n    unsubscribe(subscriber, target) {\n        const list = this.subscribers.get(target || this);\n        if (list && list.has(subscriber)) {\n            list.delete(subscriber);\n        }\n    }\n    /**\n     * Notifies subscribers that the value for an element has changed.\n     * @param element - The element to emit a notification for\n     */\n    notify(element) {\n        const record = Object.freeze({ token: this, target: element });\n        if (this.subscribers.has(this)) {\n            this.subscribers.get(this).forEach(sub => sub.handleChange(record));\n        }\n        if (this.subscribers.has(element)) {\n            this.subscribers.get(element).forEach(sub => sub.handleChange(record));\n        }\n    }\n    /**\n     * Alias the token to the provided token.\n     * @param token - the token to alias to\n     */\n    alias(token) {\n        return ((target) => token.getValueFor(target));\n    }\n}\nDesignTokenImpl.uniqueId = (() => {\n    let id = 0;\n    return () => {\n        id++;\n        return id.toString(16);\n    };\n})();\n/**\n * Token storage by token ID\n */\nDesignTokenImpl.tokensById = new Map();\nclass CustomPropertyReflector {\n    startReflection(token, target) {\n        token.subscribe(this, target);\n        this.handleChange({ token, target });\n    }\n    stopReflection(token, target) {\n        token.unsubscribe(this, target);\n        this.remove(token, target);\n    }\n    handleChange(record) {\n        const { token, target } = record;\n        this.add(token, target);\n    }\n    add(token, target) {\n        PropertyTargetManager.getOrCreate(target).setProperty(token.cssCustomProperty, this.resolveCSSValue(DesignTokenNode.getOrCreate(target).get(token)));\n    }\n    remove(token, target) {\n        PropertyTargetManager.getOrCreate(target).removeProperty(token.cssCustomProperty);\n    }\n    resolveCSSValue(value) {\n        return value && typeof value.createCSS === \"function\" ? value.createCSS() : value;\n    }\n}\n/**\n * A light wrapper around BindingObserver to handle value caching and\n * token notification\n */\nclass DesignTokenBindingObserver {\n    constructor(source, token, node) {\n        this.source = source;\n        this.token = token;\n        this.node = node;\n        this.dependencies = new Set();\n        this.observer = Observable.binding(source, this, false);\n        // This is a little bit hacky because it's using internal APIs of BindingObserverImpl.\n        // BindingObserverImpl queues updates to batch it's notifications which doesn't work for this\n        // scenario because the DesignToken.getValueFor API is not async. Without this, using DesignToken.getValueFor()\n        // after DesignToken.setValueFor() when setting a dependency of the value being retrieved can return a stale\n        // value. Assigning .handleChange to .call forces immediate invocation of this classes handleChange() method,\n        // allowing resolution of values synchronously.\n        // TODO: https://github.com/microsoft/fast/issues/5110\n        this.observer.handleChange = this.observer.call;\n        this.handleChange();\n    }\n    disconnect() {\n        this.observer.disconnect();\n    }\n    /**\n     * @internal\n     */\n    handleChange() {\n        this.node.store.set(this.token, this.observer.observe(this.node.target, defaultExecutionContext));\n    }\n}\n/**\n * Stores resolved token/value pairs and notifies on changes\n */\nclass Store {\n    constructor() {\n        this.values = new Map();\n    }\n    set(token, value) {\n        if (this.values.get(token) !== value) {\n            this.values.set(token, value);\n            Observable.getNotifier(this).notify(token.id);\n        }\n    }\n    get(token) {\n        Observable.track(this, token.id);\n        return this.values.get(token);\n    }\n    delete(token) {\n        this.values.delete(token);\n    }\n    all() {\n        return this.values.entries();\n    }\n}\nconst nodeCache = new WeakMap();\nconst childToParent = new WeakMap();\n/**\n * A node responsible for setting and getting token values,\n * emitting values to CSS custom properties, and maintaining\n * inheritance structures.\n */\nclass DesignTokenNode {\n    constructor(target) {\n        this.target = target;\n        /**\n         * Stores all resolved token values for a node\n         */\n        this.store = new Store();\n        /**\n         * All children assigned to the node\n         */\n        this.children = [];\n        /**\n         * All values explicitly assigned to the node in their raw form\n         */\n        this.assignedValues = new Map();\n        /**\n         * Tokens currently being reflected to CSS custom properties\n         */\n        this.reflecting = new Set();\n        /**\n         * Binding observers for assigned and inherited derived values.\n         */\n        this.bindingObservers = new Map();\n        /**\n         * Emits notifications to token when token values\n         * change the DesignTokenNode\n         */\n        this.tokenValueChangeHandler = {\n            handleChange: (source, arg) => {\n                const token = DesignTokenImpl.getTokenById(arg);\n                if (token) {\n                    // Notify any token subscribers\n                    token.notify(this.target);\n                    if (DesignTokenImpl.isCSSDesignToken(token)) {\n                        const parent = this.parent;\n                        const reflecting = this.isReflecting(token);\n                        if (parent) {\n                            const parentValue = parent.get(token);\n                            const sourceValue = source.get(token);\n                            if (parentValue !== sourceValue && !reflecting) {\n                                this.reflectToCSS(token);\n                            }\n                            else if (parentValue === sourceValue && reflecting) {\n                                this.stopReflectToCSS(token);\n                            }\n                        }\n                        else if (!reflecting) {\n                            this.reflectToCSS(token);\n                        }\n                    }\n                }\n            },\n        };\n        nodeCache.set(target, this);\n        // Map store change notifications to token change notifications\n        Observable.getNotifier(this.store).subscribe(this.tokenValueChangeHandler);\n        if (target instanceof FASTElement) {\n            target.$fastController.addBehaviors([this]);\n        }\n        else if (target.isConnected) {\n            this.bind();\n        }\n    }\n    /**\n     * Returns a DesignTokenNode for an element.\n     * Creates a new instance if one does not already exist for a node,\n     * otherwise returns the cached instance\n     *\n     * @param target - The HTML element to retrieve a DesignTokenNode for\n     */\n    static getOrCreate(target) {\n        return nodeCache.get(target) || new DesignTokenNode(target);\n    }\n    /**\n     * Determines if a DesignTokenNode has been created for a target\n     * @param target - The element to test\n     */\n    static existsFor(target) {\n        return nodeCache.has(target);\n    }\n    /**\n     * Searches for and return the nearest parent DesignTokenNode.\n     * Null is returned if no node is found or the node provided is for a default element.\n     */\n    static findParent(node) {\n        if (!(defaultElement === node.target)) {\n            let parent = composedParent(node.target);\n            while (parent !== null) {\n                if (nodeCache.has(parent)) {\n                    return nodeCache.get(parent);\n                }\n                parent = composedParent(parent);\n            }\n            return DesignTokenNode.getOrCreate(defaultElement);\n        }\n        return null;\n    }\n    /**\n     * Finds the closest node with a value explicitly assigned for a token, otherwise null.\n     * @param token - The token to look for\n     * @param start - The node to start looking for value assignment\n     * @returns\n     */\n    static findClosestAssignedNode(token, start) {\n        let current = start;\n        do {\n            if (current.has(token)) {\n                return current;\n            }\n            current = current.parent\n                ? current.parent\n                : current.target !== defaultElement\n                    ? DesignTokenNode.getOrCreate(defaultElement)\n                    : null;\n        } while (current !== null);\n        return null;\n    }\n    /**\n     * The parent DesignTokenNode, or null.\n     */\n    get parent() {\n        return childToParent.get(this) || null;\n    }\n    /**\n     * Checks if a token has been assigned an explicit value the node.\n     * @param token - the token to check.\n     */\n    has(token) {\n        return this.assignedValues.has(token);\n    }\n    /**\n     * Gets the value of a token for a node\n     * @param token - The token to retrieve the value for\n     * @returns\n     */\n    get(token) {\n        const value = this.store.get(token);\n        if (value !== undefined) {\n            return value;\n        }\n        const raw = this.getRaw(token);\n        if (raw !== undefined) {\n            this.hydrate(token, raw);\n            return this.get(token);\n        }\n    }\n    /**\n     * Retrieves the raw assigned value of a token from the nearest assigned node.\n     * @param token - The token to retrieve a raw value for\n     * @returns\n     */\n    getRaw(token) {\n        var _a;\n        if (this.assignedValues.has(token)) {\n            return this.assignedValues.get(token);\n        }\n        return (_a = DesignTokenNode.findClosestAssignedNode(token, this)) === null || _a === void 0 ? void 0 : _a.getRaw(token);\n    }\n    /**\n     * Sets a token to a value for a node\n     * @param token - The token to set\n     * @param value - The value to set the token to\n     */\n    set(token, value) {\n        if (DesignTokenImpl.isDerivedDesignTokenValue(this.assignedValues.get(token))) {\n            this.tearDownBindingObserver(token);\n        }\n        this.assignedValues.set(token, value);\n        if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {\n            this.setupBindingObserver(token, value);\n        }\n        else {\n            this.store.set(token, value);\n        }\n    }\n    /**\n     * Deletes a token value for the node.\n     * @param token - The token to delete the value for\n     */\n    delete(token) {\n        this.assignedValues.delete(token);\n        this.tearDownBindingObserver(token);\n        const upstream = this.getRaw(token);\n        if (upstream) {\n            this.hydrate(token, upstream);\n        }\n        else {\n            this.store.delete(token);\n        }\n    }\n    /**\n     * Invoked when the DesignTokenNode.target is attached to the document\n     */\n    bind() {\n        const parent = DesignTokenNode.findParent(this);\n        if (parent) {\n            parent.appendChild(this);\n        }\n        for (const key of this.assignedValues.keys()) {\n            key.notify(this.target);\n        }\n    }\n    /**\n     * Invoked when the DesignTokenNode.target is detached from the document\n     */\n    unbind() {\n        if (this.parent) {\n            const parent = childToParent.get(this);\n            parent.removeChild(this);\n        }\n    }\n    /**\n     * Appends a child to a parent DesignTokenNode.\n     * @param child - The child to append to the node\n     */\n    appendChild(child) {\n        if (child.parent) {\n            childToParent.get(child).removeChild(child);\n        }\n        const reParent = this.children.filter(x => child.contains(x));\n        childToParent.set(child, this);\n        this.children.push(child);\n        reParent.forEach(x => child.appendChild(x));\n        Observable.getNotifier(this.store).subscribe(child);\n        // How can we not notify *every* subscriber?\n        for (const [token, value] of this.store.all()) {\n            child.hydrate(token, this.bindingObservers.has(token) ? this.getRaw(token) : value);\n        }\n    }\n    /**\n     * Removes a child from a node.\n     * @param child - The child to remove.\n     */\n    removeChild(child) {\n        const childIndex = this.children.indexOf(child);\n        if (childIndex !== -1) {\n            this.children.splice(childIndex, 1);\n        }\n        Observable.getNotifier(this.store).unsubscribe(child);\n        return child.parent === this ? childToParent.delete(child) : false;\n    }\n    /**\n     * Tests whether a provided node is contained by\n     * the calling node.\n     * @param test - The node to test\n     */\n    contains(test) {\n        return composedContains(this.target, test.target);\n    }\n    /**\n     * Instructs the node to reflect a design token for the provided token.\n     * @param token - The design token to reflect\n     */\n    reflectToCSS(token) {\n        if (!this.isReflecting(token)) {\n            this.reflecting.add(token);\n            DesignTokenNode.cssCustomPropertyReflector.startReflection(token, this.target);\n        }\n    }\n    /**\n     * Stops reflecting a DesignToken to CSS\n     * @param token - The design token to stop reflecting\n     */\n    stopReflectToCSS(token) {\n        if (this.isReflecting(token)) {\n            this.reflecting.delete(token);\n            DesignTokenNode.cssCustomPropertyReflector.stopReflection(token, this.target);\n        }\n    }\n    /**\n     * Determines if a token is being reflected to CSS for a node.\n     * @param token - The token to check for reflection\n     * @returns\n     */\n    isReflecting(token) {\n        return this.reflecting.has(token);\n    }\n    /**\n     * Handle changes to upstream tokens\n     * @param source - The parent DesignTokenNode\n     * @param property - The token ID that changed\n     */\n    handleChange(source, property) {\n        const token = DesignTokenImpl.getTokenById(property);\n        if (!token) {\n            return;\n        }\n        this.hydrate(token, this.getRaw(token));\n    }\n    /**\n     * Hydrates a token with a DesignTokenValue, making retrieval available.\n     * @param token - The token to hydrate\n     * @param value - The value to hydrate\n     */\n    hydrate(token, value) {\n        if (!this.has(token)) {\n            const observer = this.bindingObservers.get(token);\n            if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {\n                if (observer) {\n                    // If the binding source doesn't match, we need\n                    // to update the binding\n                    if (observer.source !== value) {\n                        this.tearDownBindingObserver(token);\n                        this.setupBindingObserver(token, value);\n                    }\n                }\n                else {\n                    this.setupBindingObserver(token, value);\n                }\n            }\n            else {\n                if (observer) {\n                    this.tearDownBindingObserver(token);\n                }\n                this.store.set(token, value);\n            }\n        }\n    }\n    /**\n     * Sets up a binding observer for a derived token value that notifies token\n     * subscribers on change.\n     *\n     * @param token - The token to notify when the binding updates\n     * @param source - The binding source\n     */\n    setupBindingObserver(token, source) {\n        const binding = new DesignTokenBindingObserver(source, token, this);\n        this.bindingObservers.set(token, binding);\n        return binding;\n    }\n    /**\n     * Tear down a binding observer for a token.\n     */\n    tearDownBindingObserver(token) {\n        if (this.bindingObservers.has(token)) {\n            this.bindingObservers.get(token).disconnect();\n            this.bindingObservers.delete(token);\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * Responsible for reflecting tokens to CSS custom properties\n */\nDesignTokenNode.cssCustomPropertyReflector = new CustomPropertyReflector();\n__decorate([\n    observable\n], DesignTokenNode.prototype, \"children\", void 0);\nfunction create(nameOrConfig) {\n    return DesignTokenImpl.from(nameOrConfig);\n}\n/* eslint-enable @typescript-eslint/no-unused-vars */\n/**\n * Factory object for creating {@link (DesignToken:interface)} instances.\n * @public\n */\nexport const DesignToken = Object.freeze({\n    create,\n    /**\n     * Informs DesignToken that an HTMLElement for which tokens have\n     * been set has been connected to the document.\n     *\n     * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness\n     * in all scenarios, so invoking this method manually is necessary when:\n     *\n     * 1. Token values are set for an HTMLElement.\n     * 2. The HTMLElement does not inherit from FASTElement.\n     * 3. The HTMLElement is not connected to the document when token values are set.\n     *\n     * @param element - The element to notify\n     * @returns - true if notification was successful, otherwise false.\n     */\n    notifyConnection(element) {\n        if (!element.isConnected || !DesignTokenNode.existsFor(element)) {\n            return false;\n        }\n        DesignTokenNode.getOrCreate(element).bind();\n        return true;\n    },\n    /**\n     * Informs DesignToken that an HTMLElement for which tokens have\n     * been set has been disconnected to the document.\n     *\n     * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness\n     * in all scenarios, so invoking this method manually is necessary when:\n     *\n     * 1. Token values are set for an HTMLElement.\n     * 2. The HTMLElement does not inherit from FASTElement.\n     *\n     * @param element - The element to notify\n     * @returns - true if notification was successful, otherwise false.\n     */\n    notifyDisconnection(element) {\n        if (element.isConnected || !DesignTokenNode.existsFor(element)) {\n            return false;\n        }\n        DesignTokenNode.getOrCreate(element).unbind();\n        return true;\n    },\n    /**\n     * Registers and element or document as a DesignToken root.\n     * {@link CSSDesignToken | CSSDesignTokens} with default values assigned via\n     * {@link (DesignToken:interface).withDefault} will emit CSS custom properties to all\n     * registered roots.\n     * @param target - The root to register\n     */\n    registerRoot(target = defaultElement) {\n        RootStyleSheetTarget.registerRoot(target);\n    },\n    /**\n     * Unregister an element or document as a DesignToken root.\n     * @param target - The root to deregister\n     */\n    unregisterRoot(target = defaultElement) {\n        RootStyleSheetTarget.unregisterRoot(target);\n    },\n});\n/* eslint-enable @typescript-eslint/no-non-null-assertion */\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}