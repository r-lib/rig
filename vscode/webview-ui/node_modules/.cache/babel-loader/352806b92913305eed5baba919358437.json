{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { attr, observable, Observable } from \"@microsoft/fast-element\";\nimport { findLastIndex, keyArrowDown, keyArrowUp, keyEnd, keyEnter, keyEscape, keyHome, keySpace, keyTab, uniqueId } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\nimport { isListboxOption } from \"../listbox-option/listbox-option.js\";\nimport { ARIAGlobalStatesAndProperties } from \"../patterns/aria-global.js\";\nimport { applyMixins } from \"../utilities/apply-mixins.js\";\n/**\n * A Listbox Custom HTML Element.\n * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#listbox | ARIA listbox }.\n *\n * @slot - The default slot for the listbox options\n *\n * @public\n */\n\nexport class Listbox extends FoundationElement {\n  constructor() {\n    super(...arguments);\n    /**\n     * The internal unfiltered list of selectable options.\n     *\n     * @internal\n     */\n\n    this._options = [];\n    /**\n     * The index of the selected option.\n     *\n     * @public\n     */\n\n    this.selectedIndex = -1;\n    /**\n     * A collection of the selected options.\n     *\n     * @public\n     */\n\n    this.selectedOptions = [];\n    /**\n     * A standard `click` event creates a `focus` event before firing, so a\n     * `mousedown` event is used to skip that initial focus.\n     *\n     * @internal\n     */\n\n    this.shouldSkipFocus = false;\n    /**\n     * The current typeahead buffer string.\n     *\n     * @internal\n     */\n\n    this.typeaheadBuffer = \"\";\n    /**\n     * Flag for the typeahead timeout expiration.\n     *\n     * @internal\n     */\n\n    this.typeaheadExpired = true;\n    /**\n     * The timeout ID for the typeahead handler.\n     *\n     * @internal\n     */\n\n    this.typeaheadTimeout = -1;\n  }\n  /**\n   * The first selected option.\n   *\n   * @internal\n   */\n\n\n  get firstSelectedOption() {\n    var _a;\n\n    return (_a = this.selectedOptions[0]) !== null && _a !== void 0 ? _a : null;\n  }\n  /**\n   * Returns true if there is one or more selectable option.\n   *\n   * @internal\n   */\n\n\n  get hasSelectableOptions() {\n    return this.options.length > 0 && !this.options.every(o => o.disabled);\n  }\n  /**\n   * The number of options.\n   *\n   * @public\n   */\n\n\n  get length() {\n    var _a, _b;\n\n    return (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;\n  }\n  /**\n   * The list of options.\n   *\n   * @public\n   */\n\n\n  get options() {\n    Observable.track(this, \"options\");\n    return this._options;\n  }\n\n  set options(value) {\n    this._options = value;\n    Observable.notify(this, \"options\");\n  }\n  /**\n   * Flag for the typeahead timeout expiration.\n   *\n   * @deprecated use `Listbox.typeaheadExpired`\n   * @internal\n   */\n\n\n  get typeAheadExpired() {\n    return this.typeaheadExpired;\n  }\n\n  set typeAheadExpired(value) {\n    this.typeaheadExpired = value;\n  }\n  /**\n   * Handle click events for listbox options.\n   *\n   * @internal\n   */\n\n\n  clickHandler(e) {\n    const captured = e.target.closest(`option,[role=option]`);\n\n    if (captured && !captured.disabled) {\n      this.selectedIndex = this.options.indexOf(captured);\n      return true;\n    }\n  }\n  /**\n   * Ensures that the provided option is focused and scrolled into view.\n   *\n   * @param optionToFocus - The option to focus\n   * @internal\n   */\n\n\n  focusAndScrollOptionIntoView() {\n    let optionToFocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.firstSelectedOption;\n\n    // To ensure that the browser handles both `focus()` and `scrollIntoView()`, the\n    // timing here needs to guarantee that they happen on different frames. Since this\n    // function is typically called from the `openChanged` observer, `DOM.queueUpdate`\n    // causes the calls to be grouped into the same frame. To prevent this,\n    // `requestAnimationFrame` is used instead of `DOM.queueUpdate`.\n    if (this.contains(document.activeElement) && optionToFocus !== null) {\n      optionToFocus.focus();\n      requestAnimationFrame(() => {\n        optionToFocus.scrollIntoView({\n          block: \"nearest\"\n        });\n      });\n    }\n  }\n  /**\n   * Handles `focusin` actions for the component. When the component receives focus,\n   * the list of selected options is refreshed and the first selected option is scrolled\n   * into view.\n   *\n   * @internal\n   */\n\n\n  focusinHandler(e) {\n    if (!this.shouldSkipFocus && e.target === e.currentTarget) {\n      this.setSelectedOptions();\n      this.focusAndScrollOptionIntoView();\n    }\n\n    this.shouldSkipFocus = false;\n  }\n  /**\n   * Returns the options which match the current typeahead buffer.\n   *\n   * @internal\n   */\n\n\n  getTypeaheadMatches() {\n    const pattern = this.typeaheadBuffer.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n    const re = new RegExp(`^${pattern}`, \"gi\");\n    return this.options.filter(o => o.text.trim().match(re));\n  }\n  /**\n   * Determines the index of the next option which is selectable, if any.\n   *\n   * @param prev - the previous selected index\n   * @param next - the next index to select\n   *\n   * @internal\n   */\n\n\n  getSelectableIndex() {\n    let prev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectedIndex;\n    let next = arguments.length > 1 ? arguments[1] : undefined;\n    const direction = prev > next ? -1 : prev < next ? 1 : 0;\n    const potentialDirection = prev + direction;\n    let nextSelectableOption = null;\n\n    switch (direction) {\n      case -1:\n        {\n          nextSelectableOption = this.options.reduceRight((nextSelectableOption, thisOption, index) => !nextSelectableOption && !thisOption.disabled && index < potentialDirection ? thisOption : nextSelectableOption, nextSelectableOption);\n          break;\n        }\n\n      case 1:\n        {\n          nextSelectableOption = this.options.reduce((nextSelectableOption, thisOption, index) => !nextSelectableOption && !thisOption.disabled && index > potentialDirection ? thisOption : nextSelectableOption, nextSelectableOption);\n          break;\n        }\n    }\n\n    return this.options.indexOf(nextSelectableOption);\n  }\n  /**\n   * Handles external changes to child options.\n   *\n   * @param source - the source object\n   * @param propertyName - the property\n   *\n   * @internal\n   */\n\n\n  handleChange(source, propertyName) {\n    switch (propertyName) {\n      case \"selected\":\n        {\n          if (Listbox.slottedOptionFilter(source)) {\n            this.selectedIndex = this.options.indexOf(source);\n          }\n\n          this.setSelectedOptions();\n          break;\n        }\n    }\n  }\n  /**\n   * Moves focus to an option whose label matches characters typed by the user.\n   * Consecutive keystrokes are batched into a buffer of search text used\n   * to match against the set of options.  If `TYPE_AHEAD_TIMEOUT_MS` passes\n   * between consecutive keystrokes, the search restarts.\n   *\n   * @param key - the key to be evaluated\n   *\n   * @internal\n   */\n\n\n  handleTypeAhead(key) {\n    if (this.typeaheadTimeout) {\n      window.clearTimeout(this.typeaheadTimeout);\n    }\n\n    this.typeaheadTimeout = window.setTimeout(() => this.typeaheadExpired = true, Listbox.TYPE_AHEAD_TIMEOUT_MS);\n\n    if (key.length > 1) {\n      return;\n    }\n\n    this.typeaheadBuffer = `${this.typeaheadExpired ? \"\" : this.typeaheadBuffer}${key}`;\n  }\n  /**\n   * Handles `keydown` actions for listbox navigation and typeahead.\n   *\n   * @internal\n   */\n\n\n  keydownHandler(e) {\n    if (this.disabled) {\n      return true;\n    }\n\n    this.shouldSkipFocus = false;\n    const key = e.key;\n\n    switch (key) {\n      // Select the first available option\n      case keyHome:\n        {\n          if (!e.shiftKey) {\n            e.preventDefault();\n            this.selectFirstOption();\n          }\n\n          break;\n        }\n      // Select the next selectable option\n\n      case keyArrowDown:\n        {\n          if (!e.shiftKey) {\n            e.preventDefault();\n            this.selectNextOption();\n          }\n\n          break;\n        }\n      // Select the previous selectable option\n\n      case keyArrowUp:\n        {\n          if (!e.shiftKey) {\n            e.preventDefault();\n            this.selectPreviousOption();\n          }\n\n          break;\n        }\n      // Select the last available option\n\n      case keyEnd:\n        {\n          e.preventDefault();\n          this.selectLastOption();\n          break;\n        }\n\n      case keyTab:\n        {\n          this.focusAndScrollOptionIntoView();\n          return true;\n        }\n\n      case keyEnter:\n      case keyEscape:\n        {\n          return true;\n        }\n\n      case keySpace:\n        {\n          if (this.typeaheadExpired) {\n            return true;\n          }\n        }\n      // Send key to Typeahead handler\n\n      default:\n        {\n          if (key.length === 1) {\n            this.handleTypeAhead(`${key}`);\n          }\n\n          return true;\n        }\n    }\n  }\n  /**\n   * Prevents `focusin` events from firing before `click` events when the\n   * element is unfocused.\n   *\n   * @internal\n   */\n\n\n  mousedownHandler(e) {\n    this.shouldSkipFocus = !this.contains(document.activeElement);\n    return true;\n  }\n  /**\n   * Switches between single-selection and multi-selection mode.\n   *\n   * @param prev - the previous value of the `multiple` attribute\n   * @param next - the next value of the `multiple` attribute\n   *\n   * @internal\n   */\n\n\n  multipleChanged(prev, next) {\n    this.ariaMultiSelectable = next ? \"true\" : null;\n  }\n  /**\n   * Updates the list of selected options when the `selectedIndex` changes.\n   *\n   * @param prev - the previous selected index value\n   * @param next - the current selected index value\n   *\n   * @internal\n   */\n\n\n  selectedIndexChanged(prev, next) {\n    var _a;\n\n    if (!this.hasSelectableOptions) {\n      this.selectedIndex = -1;\n      return;\n    }\n\n    if (((_a = this.options[this.selectedIndex]) === null || _a === void 0 ? void 0 : _a.disabled) && typeof prev === \"number\") {\n      const selectableIndex = this.getSelectableIndex(prev, next);\n      const newNext = selectableIndex > -1 ? selectableIndex : prev;\n      this.selectedIndex = newNext;\n\n      if (next === newNext) {\n        this.selectedIndexChanged(next, newNext);\n      }\n\n      return;\n    }\n\n    this.setSelectedOptions();\n  }\n  /**\n   * Updates the selectedness of each option when the list of selected options changes.\n   *\n   * @param prev - the previous list of selected options\n   * @param next - the current list of selected options\n   *\n   * @internal\n   */\n\n\n  selectedOptionsChanged(prev, next) {\n    var _a;\n\n    const filteredNext = next.filter(Listbox.slottedOptionFilter);\n    (_a = this.options) === null || _a === void 0 ? void 0 : _a.forEach(o => {\n      const notifier = Observable.getNotifier(o);\n      notifier.unsubscribe(this, \"selected\");\n      o.selected = filteredNext.includes(o);\n      notifier.subscribe(this, \"selected\");\n    });\n  }\n  /**\n   * Moves focus to the first selectable option.\n   *\n   * @public\n   */\n\n\n  selectFirstOption() {\n    var _a, _b;\n\n    if (!this.disabled) {\n      this.selectedIndex = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.findIndex(o => !o.disabled)) !== null && _b !== void 0 ? _b : -1;\n    }\n  }\n  /**\n   * Moves focus to the last selectable option.\n   *\n   * @internal\n   */\n\n\n  selectLastOption() {\n    if (!this.disabled) {\n      this.selectedIndex = findLastIndex(this.options, o => !o.disabled);\n    }\n  }\n  /**\n   * Moves focus to the next selectable option.\n   *\n   * @internal\n   */\n\n\n  selectNextOption() {\n    if (!this.disabled && this.selectedIndex < this.options.length - 1) {\n      this.selectedIndex += 1;\n    }\n  }\n  /**\n   * Moves focus to the previous selectable option.\n   *\n   * @internal\n   */\n\n\n  selectPreviousOption() {\n    if (!this.disabled && this.selectedIndex > 0) {\n      this.selectedIndex = this.selectedIndex - 1;\n    }\n  }\n  /**\n   * Updates the selected index to match the first selected option.\n   *\n   * @internal\n   */\n\n\n  setDefaultSelectedOption() {\n    var _a, _b;\n\n    this.selectedIndex = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.findIndex(el => el.defaultSelected)) !== null && _b !== void 0 ? _b : -1;\n  }\n  /**\n   * Sets an option as selected and gives it focus.\n   *\n   * @public\n   */\n\n\n  setSelectedOptions() {\n    var _a, _b, _c;\n\n    if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.length) {\n      this.selectedOptions = [this.options[this.selectedIndex]];\n      this.ariaActiveDescendant = (_c = (_b = this.firstSelectedOption) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : \"\";\n      this.focusAndScrollOptionIntoView();\n    }\n  }\n  /**\n   * Updates the list of options and resets the selected option when the slotted option content changes.\n   *\n   * @param prev - the previous list of slotted options\n   * @param next - the current list of slotted options\n   *\n   * @internal\n   */\n\n\n  slottedOptionsChanged(prev, next) {\n    this.options = next.reduce((options, item) => {\n      if (isListboxOption(item)) {\n        options.push(item);\n      }\n\n      return options;\n    }, []);\n    const setSize = `${this.options.length}`;\n    this.options.forEach((option, index) => {\n      if (!option.id) {\n        option.id = uniqueId(\"option-\");\n      }\n\n      option.ariaPosInSet = `${index + 1}`;\n      option.ariaSetSize = setSize;\n    });\n\n    if (this.$fastController.isConnected) {\n      this.setSelectedOptions();\n      this.setDefaultSelectedOption();\n    }\n  }\n  /**\n   * Updates the filtered list of options when the typeahead buffer changes.\n   *\n   * @param prev - the previous typeahead buffer value\n   * @param next - the current typeahead buffer value\n   *\n   * @internal\n   */\n\n\n  typeaheadBufferChanged(prev, next) {\n    if (this.$fastController.isConnected) {\n      const typeaheadMatches = this.getTypeaheadMatches();\n\n      if (typeaheadMatches.length) {\n        const selectedIndex = this.options.indexOf(typeaheadMatches[0]);\n\n        if (selectedIndex > -1) {\n          this.selectedIndex = selectedIndex;\n        }\n      }\n\n      this.typeaheadExpired = false;\n    }\n  }\n\n}\n/**\n * A static filter to include only selectable options.\n *\n * @param n - element to filter\n * @public\n */\n\nListbox.slottedOptionFilter = n => isListboxOption(n) && !n.hidden;\n/**\n * Typeahead timeout in milliseconds.\n *\n * @internal\n */\n\n\nListbox.TYPE_AHEAD_TIMEOUT_MS = 1000;\n\n__decorate([attr({\n  mode: \"boolean\"\n})], Listbox.prototype, \"disabled\", void 0);\n\n__decorate([observable], Listbox.prototype, \"selectedIndex\", void 0);\n\n__decorate([observable], Listbox.prototype, \"selectedOptions\", void 0);\n\n__decorate([observable], Listbox.prototype, \"slottedOptions\", void 0);\n\n__decorate([observable], Listbox.prototype, \"typeaheadBuffer\", void 0);\n/**\n * Includes ARIA states and properties relating to the ARIA listbox role\n *\n * @public\n */\n\n\nexport class DelegatesARIAListbox {}\n\n__decorate([observable], DelegatesARIAListbox.prototype, \"ariaActiveDescendant\", void 0);\n\n__decorate([observable], DelegatesARIAListbox.prototype, \"ariaDisabled\", void 0);\n\n__decorate([observable], DelegatesARIAListbox.prototype, \"ariaExpanded\", void 0);\n\n__decorate([observable], DelegatesARIAListbox.prototype, \"ariaMultiSelectable\", void 0);\n\napplyMixins(DelegatesARIAListbox, ARIAGlobalStatesAndProperties);\napplyMixins(Listbox, DelegatesARIAListbox);","map":{"version":3,"names":["__decorate","attr","observable","Observable","findLastIndex","keyArrowDown","keyArrowUp","keyEnd","keyEnter","keyEscape","keyHome","keySpace","keyTab","uniqueId","FoundationElement","isListboxOption","ARIAGlobalStatesAndProperties","applyMixins","Listbox","constructor","arguments","_options","selectedIndex","selectedOptions","shouldSkipFocus","typeaheadBuffer","typeaheadExpired","typeaheadTimeout","firstSelectedOption","_a","hasSelectableOptions","options","length","every","o","disabled","_b","track","value","notify","typeAheadExpired","clickHandler","e","captured","target","closest","indexOf","focusAndScrollOptionIntoView","optionToFocus","contains","document","activeElement","focus","requestAnimationFrame","scrollIntoView","block","focusinHandler","currentTarget","setSelectedOptions","getTypeaheadMatches","pattern","replace","re","RegExp","filter","text","trim","match","getSelectableIndex","prev","next","direction","potentialDirection","nextSelectableOption","reduceRight","thisOption","index","reduce","handleChange","source","propertyName","slottedOptionFilter","handleTypeAhead","key","window","clearTimeout","setTimeout","TYPE_AHEAD_TIMEOUT_MS","keydownHandler","shiftKey","preventDefault","selectFirstOption","selectNextOption","selectPreviousOption","selectLastOption","mousedownHandler","multipleChanged","ariaMultiSelectable","selectedIndexChanged","selectableIndex","newNext","selectedOptionsChanged","filteredNext","forEach","notifier","getNotifier","unsubscribe","selected","includes","subscribe","findIndex","setDefaultSelectedOption","el","defaultSelected","_c","ariaActiveDescendant","id","slottedOptionsChanged","item","push","setSize","option","ariaPosInSet","ariaSetSize","$fastController","isConnected","typeaheadBufferChanged","typeaheadMatches","n","hidden","mode","prototype","DelegatesARIAListbox"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { attr, observable, Observable } from \"@microsoft/fast-element\";\nimport { findLastIndex, keyArrowDown, keyArrowUp, keyEnd, keyEnter, keyEscape, keyHome, keySpace, keyTab, uniqueId, } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\nimport { isListboxOption } from \"../listbox-option/listbox-option.js\";\nimport { ARIAGlobalStatesAndProperties } from \"../patterns/aria-global.js\";\nimport { applyMixins } from \"../utilities/apply-mixins.js\";\n/**\n * A Listbox Custom HTML Element.\n * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#listbox | ARIA listbox }.\n *\n * @slot - The default slot for the listbox options\n *\n * @public\n */\nexport class Listbox extends FoundationElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * The internal unfiltered list of selectable options.\n         *\n         * @internal\n         */\n        this._options = [];\n        /**\n         * The index of the selected option.\n         *\n         * @public\n         */\n        this.selectedIndex = -1;\n        /**\n         * A collection of the selected options.\n         *\n         * @public\n         */\n        this.selectedOptions = [];\n        /**\n         * A standard `click` event creates a `focus` event before firing, so a\n         * `mousedown` event is used to skip that initial focus.\n         *\n         * @internal\n         */\n        this.shouldSkipFocus = false;\n        /**\n         * The current typeahead buffer string.\n         *\n         * @internal\n         */\n        this.typeaheadBuffer = \"\";\n        /**\n         * Flag for the typeahead timeout expiration.\n         *\n         * @internal\n         */\n        this.typeaheadExpired = true;\n        /**\n         * The timeout ID for the typeahead handler.\n         *\n         * @internal\n         */\n        this.typeaheadTimeout = -1;\n    }\n    /**\n     * The first selected option.\n     *\n     * @internal\n     */\n    get firstSelectedOption() {\n        var _a;\n        return (_a = this.selectedOptions[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * Returns true if there is one or more selectable option.\n     *\n     * @internal\n     */\n    get hasSelectableOptions() {\n        return this.options.length > 0 && !this.options.every(o => o.disabled);\n    }\n    /**\n     * The number of options.\n     *\n     * @public\n     */\n    get length() {\n        var _a, _b;\n        return (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;\n    }\n    /**\n     * The list of options.\n     *\n     * @public\n     */\n    get options() {\n        Observable.track(this, \"options\");\n        return this._options;\n    }\n    set options(value) {\n        this._options = value;\n        Observable.notify(this, \"options\");\n    }\n    /**\n     * Flag for the typeahead timeout expiration.\n     *\n     * @deprecated use `Listbox.typeaheadExpired`\n     * @internal\n     */\n    get typeAheadExpired() {\n        return this.typeaheadExpired;\n    }\n    set typeAheadExpired(value) {\n        this.typeaheadExpired = value;\n    }\n    /**\n     * Handle click events for listbox options.\n     *\n     * @internal\n     */\n    clickHandler(e) {\n        const captured = e.target.closest(`option,[role=option]`);\n        if (captured && !captured.disabled) {\n            this.selectedIndex = this.options.indexOf(captured);\n            return true;\n        }\n    }\n    /**\n     * Ensures that the provided option is focused and scrolled into view.\n     *\n     * @param optionToFocus - The option to focus\n     * @internal\n     */\n    focusAndScrollOptionIntoView(optionToFocus = this.firstSelectedOption) {\n        // To ensure that the browser handles both `focus()` and `scrollIntoView()`, the\n        // timing here needs to guarantee that they happen on different frames. Since this\n        // function is typically called from the `openChanged` observer, `DOM.queueUpdate`\n        // causes the calls to be grouped into the same frame. To prevent this,\n        // `requestAnimationFrame` is used instead of `DOM.queueUpdate`.\n        if (this.contains(document.activeElement) && optionToFocus !== null) {\n            optionToFocus.focus();\n            requestAnimationFrame(() => {\n                optionToFocus.scrollIntoView({ block: \"nearest\" });\n            });\n        }\n    }\n    /**\n     * Handles `focusin` actions for the component. When the component receives focus,\n     * the list of selected options is refreshed and the first selected option is scrolled\n     * into view.\n     *\n     * @internal\n     */\n    focusinHandler(e) {\n        if (!this.shouldSkipFocus && e.target === e.currentTarget) {\n            this.setSelectedOptions();\n            this.focusAndScrollOptionIntoView();\n        }\n        this.shouldSkipFocus = false;\n    }\n    /**\n     * Returns the options which match the current typeahead buffer.\n     *\n     * @internal\n     */\n    getTypeaheadMatches() {\n        const pattern = this.typeaheadBuffer.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n        const re = new RegExp(`^${pattern}`, \"gi\");\n        return this.options.filter((o) => o.text.trim().match(re));\n    }\n    /**\n     * Determines the index of the next option which is selectable, if any.\n     *\n     * @param prev - the previous selected index\n     * @param next - the next index to select\n     *\n     * @internal\n     */\n    getSelectableIndex(prev = this.selectedIndex, next) {\n        const direction = prev > next ? -1 : prev < next ? 1 : 0;\n        const potentialDirection = prev + direction;\n        let nextSelectableOption = null;\n        switch (direction) {\n            case -1: {\n                nextSelectableOption = this.options.reduceRight((nextSelectableOption, thisOption, index) => !nextSelectableOption &&\n                    !thisOption.disabled &&\n                    index < potentialDirection\n                    ? thisOption\n                    : nextSelectableOption, nextSelectableOption);\n                break;\n            }\n            case 1: {\n                nextSelectableOption = this.options.reduce((nextSelectableOption, thisOption, index) => !nextSelectableOption &&\n                    !thisOption.disabled &&\n                    index > potentialDirection\n                    ? thisOption\n                    : nextSelectableOption, nextSelectableOption);\n                break;\n            }\n        }\n        return this.options.indexOf(nextSelectableOption);\n    }\n    /**\n     * Handles external changes to child options.\n     *\n     * @param source - the source object\n     * @param propertyName - the property\n     *\n     * @internal\n     */\n    handleChange(source, propertyName) {\n        switch (propertyName) {\n            case \"selected\": {\n                if (Listbox.slottedOptionFilter(source)) {\n                    this.selectedIndex = this.options.indexOf(source);\n                }\n                this.setSelectedOptions();\n                break;\n            }\n        }\n    }\n    /**\n     * Moves focus to an option whose label matches characters typed by the user.\n     * Consecutive keystrokes are batched into a buffer of search text used\n     * to match against the set of options.  If `TYPE_AHEAD_TIMEOUT_MS` passes\n     * between consecutive keystrokes, the search restarts.\n     *\n     * @param key - the key to be evaluated\n     *\n     * @internal\n     */\n    handleTypeAhead(key) {\n        if (this.typeaheadTimeout) {\n            window.clearTimeout(this.typeaheadTimeout);\n        }\n        this.typeaheadTimeout = window.setTimeout(() => (this.typeaheadExpired = true), Listbox.TYPE_AHEAD_TIMEOUT_MS);\n        if (key.length > 1) {\n            return;\n        }\n        this.typeaheadBuffer = `${this.typeaheadExpired ? \"\" : this.typeaheadBuffer}${key}`;\n    }\n    /**\n     * Handles `keydown` actions for listbox navigation and typeahead.\n     *\n     * @internal\n     */\n    keydownHandler(e) {\n        if (this.disabled) {\n            return true;\n        }\n        this.shouldSkipFocus = false;\n        const key = e.key;\n        switch (key) {\n            // Select the first available option\n            case keyHome: {\n                if (!e.shiftKey) {\n                    e.preventDefault();\n                    this.selectFirstOption();\n                }\n                break;\n            }\n            // Select the next selectable option\n            case keyArrowDown: {\n                if (!e.shiftKey) {\n                    e.preventDefault();\n                    this.selectNextOption();\n                }\n                break;\n            }\n            // Select the previous selectable option\n            case keyArrowUp: {\n                if (!e.shiftKey) {\n                    e.preventDefault();\n                    this.selectPreviousOption();\n                }\n                break;\n            }\n            // Select the last available option\n            case keyEnd: {\n                e.preventDefault();\n                this.selectLastOption();\n                break;\n            }\n            case keyTab: {\n                this.focusAndScrollOptionIntoView();\n                return true;\n            }\n            case keyEnter:\n            case keyEscape: {\n                return true;\n            }\n            case keySpace: {\n                if (this.typeaheadExpired) {\n                    return true;\n                }\n            }\n            // Send key to Typeahead handler\n            default: {\n                if (key.length === 1) {\n                    this.handleTypeAhead(`${key}`);\n                }\n                return true;\n            }\n        }\n    }\n    /**\n     * Prevents `focusin` events from firing before `click` events when the\n     * element is unfocused.\n     *\n     * @internal\n     */\n    mousedownHandler(e) {\n        this.shouldSkipFocus = !this.contains(document.activeElement);\n        return true;\n    }\n    /**\n     * Switches between single-selection and multi-selection mode.\n     *\n     * @param prev - the previous value of the `multiple` attribute\n     * @param next - the next value of the `multiple` attribute\n     *\n     * @internal\n     */\n    multipleChanged(prev, next) {\n        this.ariaMultiSelectable = next ? \"true\" : null;\n    }\n    /**\n     * Updates the list of selected options when the `selectedIndex` changes.\n     *\n     * @param prev - the previous selected index value\n     * @param next - the current selected index value\n     *\n     * @internal\n     */\n    selectedIndexChanged(prev, next) {\n        var _a;\n        if (!this.hasSelectableOptions) {\n            this.selectedIndex = -1;\n            return;\n        }\n        if (((_a = this.options[this.selectedIndex]) === null || _a === void 0 ? void 0 : _a.disabled) && typeof prev === \"number\") {\n            const selectableIndex = this.getSelectableIndex(prev, next);\n            const newNext = selectableIndex > -1 ? selectableIndex : prev;\n            this.selectedIndex = newNext;\n            if (next === newNext) {\n                this.selectedIndexChanged(next, newNext);\n            }\n            return;\n        }\n        this.setSelectedOptions();\n    }\n    /**\n     * Updates the selectedness of each option when the list of selected options changes.\n     *\n     * @param prev - the previous list of selected options\n     * @param next - the current list of selected options\n     *\n     * @internal\n     */\n    selectedOptionsChanged(prev, next) {\n        var _a;\n        const filteredNext = next.filter(Listbox.slottedOptionFilter);\n        (_a = this.options) === null || _a === void 0 ? void 0 : _a.forEach(o => {\n            const notifier = Observable.getNotifier(o);\n            notifier.unsubscribe(this, \"selected\");\n            o.selected = filteredNext.includes(o);\n            notifier.subscribe(this, \"selected\");\n        });\n    }\n    /**\n     * Moves focus to the first selectable option.\n     *\n     * @public\n     */\n    selectFirstOption() {\n        var _a, _b;\n        if (!this.disabled) {\n            this.selectedIndex = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.findIndex(o => !o.disabled)) !== null && _b !== void 0 ? _b : -1;\n        }\n    }\n    /**\n     * Moves focus to the last selectable option.\n     *\n     * @internal\n     */\n    selectLastOption() {\n        if (!this.disabled) {\n            this.selectedIndex = findLastIndex(this.options, o => !o.disabled);\n        }\n    }\n    /**\n     * Moves focus to the next selectable option.\n     *\n     * @internal\n     */\n    selectNextOption() {\n        if (!this.disabled && this.selectedIndex < this.options.length - 1) {\n            this.selectedIndex += 1;\n        }\n    }\n    /**\n     * Moves focus to the previous selectable option.\n     *\n     * @internal\n     */\n    selectPreviousOption() {\n        if (!this.disabled && this.selectedIndex > 0) {\n            this.selectedIndex = this.selectedIndex - 1;\n        }\n    }\n    /**\n     * Updates the selected index to match the first selected option.\n     *\n     * @internal\n     */\n    setDefaultSelectedOption() {\n        var _a, _b;\n        this.selectedIndex = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.findIndex(el => el.defaultSelected)) !== null && _b !== void 0 ? _b : -1;\n    }\n    /**\n     * Sets an option as selected and gives it focus.\n     *\n     * @public\n     */\n    setSelectedOptions() {\n        var _a, _b, _c;\n        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.length) {\n            this.selectedOptions = [this.options[this.selectedIndex]];\n            this.ariaActiveDescendant = (_c = (_b = this.firstSelectedOption) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : \"\";\n            this.focusAndScrollOptionIntoView();\n        }\n    }\n    /**\n     * Updates the list of options and resets the selected option when the slotted option content changes.\n     *\n     * @param prev - the previous list of slotted options\n     * @param next - the current list of slotted options\n     *\n     * @internal\n     */\n    slottedOptionsChanged(prev, next) {\n        this.options = next.reduce((options, item) => {\n            if (isListboxOption(item)) {\n                options.push(item);\n            }\n            return options;\n        }, []);\n        const setSize = `${this.options.length}`;\n        this.options.forEach((option, index) => {\n            if (!option.id) {\n                option.id = uniqueId(\"option-\");\n            }\n            option.ariaPosInSet = `${index + 1}`;\n            option.ariaSetSize = setSize;\n        });\n        if (this.$fastController.isConnected) {\n            this.setSelectedOptions();\n            this.setDefaultSelectedOption();\n        }\n    }\n    /**\n     * Updates the filtered list of options when the typeahead buffer changes.\n     *\n     * @param prev - the previous typeahead buffer value\n     * @param next - the current typeahead buffer value\n     *\n     * @internal\n     */\n    typeaheadBufferChanged(prev, next) {\n        if (this.$fastController.isConnected) {\n            const typeaheadMatches = this.getTypeaheadMatches();\n            if (typeaheadMatches.length) {\n                const selectedIndex = this.options.indexOf(typeaheadMatches[0]);\n                if (selectedIndex > -1) {\n                    this.selectedIndex = selectedIndex;\n                }\n            }\n            this.typeaheadExpired = false;\n        }\n    }\n}\n/**\n * A static filter to include only selectable options.\n *\n * @param n - element to filter\n * @public\n */\nListbox.slottedOptionFilter = (n) => isListboxOption(n) && !n.hidden;\n/**\n * Typeahead timeout in milliseconds.\n *\n * @internal\n */\nListbox.TYPE_AHEAD_TIMEOUT_MS = 1000;\n__decorate([\n    attr({ mode: \"boolean\" })\n], Listbox.prototype, \"disabled\", void 0);\n__decorate([\n    observable\n], Listbox.prototype, \"selectedIndex\", void 0);\n__decorate([\n    observable\n], Listbox.prototype, \"selectedOptions\", void 0);\n__decorate([\n    observable\n], Listbox.prototype, \"slottedOptions\", void 0);\n__decorate([\n    observable\n], Listbox.prototype, \"typeaheadBuffer\", void 0);\n/**\n * Includes ARIA states and properties relating to the ARIA listbox role\n *\n * @public\n */\nexport class DelegatesARIAListbox {\n}\n__decorate([\n    observable\n], DelegatesARIAListbox.prototype, \"ariaActiveDescendant\", void 0);\n__decorate([\n    observable\n], DelegatesARIAListbox.prototype, \"ariaDisabled\", void 0);\n__decorate([\n    observable\n], DelegatesARIAListbox.prototype, \"ariaExpanded\", void 0);\n__decorate([\n    observable\n], DelegatesARIAListbox.prototype, \"ariaMultiSelectable\", void 0);\napplyMixins(DelegatesARIAListbox, ARIAGlobalStatesAndProperties);\napplyMixins(Listbox, DelegatesARIAListbox);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}