{"ast":null,"code":"import _construct from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _toConsumableArray from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\n * Big thanks to https://github.com/fkleuver and the https://github.com/aurelia/aurelia project\n * for the bulk of this code and many of the associated tests.\n */\nimport { emptyArray, FASTElement } from \"@microsoft/fast-element\"; // Tiny polyfill for TypeScript's Reflect metadata API.\n\nvar metadataByTarget = new Map();\n\nif (!(\"metadata\" in Reflect)) {\n  Reflect.metadata = function (key, value) {\n    return function (target) {\n      Reflect.defineMetadata(key, value, target);\n    };\n  };\n\n  Reflect.defineMetadata = function (key, value, target) {\n    var metadata = metadataByTarget.get(target);\n\n    if (metadata === void 0) {\n      metadataByTarget.set(target, metadata = new Map());\n    }\n\n    metadata.set(key, value);\n  };\n\n  Reflect.getOwnMetadata = function (key, target) {\n    var metadata = metadataByTarget.get(target);\n\n    if (metadata !== void 0) {\n      return metadata.get(key);\n    }\n\n    return void 0;\n  };\n}\n/**\n * A utility class used that constructs and registers resolvers for a dependency\n * injection container. Supports a standard set of object lifetimes.\n * @public\n */\n\n\nexport var ResolverBuilder = /*#__PURE__*/function () {\n  /**\n   *\n   * @param container - The container to create resolvers for.\n   * @param key - The key to register resolvers under.\n   */\n  function ResolverBuilder(container, key) {\n    _classCallCheck(this, ResolverBuilder);\n\n    this.container = container;\n    this.key = key;\n  }\n  /**\n   * Creates a resolver for an existing object instance.\n   * @param value - The instance to resolve.\n   * @returns The resolver.\n   */\n\n\n  _createClass(ResolverBuilder, [{\n    key: \"instance\",\n    value: function instance(value) {\n      return this.registerResolver(0\n      /* instance */\n      , value);\n    }\n    /**\n     * Creates a resolver that enforces a singleton lifetime.\n     * @param value - The type to create and cache the singleton for.\n     * @returns The resolver.\n     */\n\n  }, {\n    key: \"singleton\",\n    value: function singleton(value) {\n      return this.registerResolver(1\n      /* singleton */\n      , value);\n    }\n    /**\n     * Creates a resolver that creates a new instance for every dependency request.\n     * @param value - The type to create instances of.\n     * @returns - The resolver.\n     */\n\n  }, {\n    key: \"transient\",\n    value: function transient(value) {\n      return this.registerResolver(2\n      /* transient */\n      , value);\n    }\n    /**\n     * Creates a resolver that invokes a callback function for every dependency resolution\n     * request, allowing custom logic to return the dependency.\n     * @param value - The callback to call during resolution.\n     * @returns The resolver.\n     */\n\n  }, {\n    key: \"callback\",\n    value: function callback(value) {\n      return this.registerResolver(3\n      /* callback */\n      , value);\n    }\n    /**\n     * Creates a resolver that invokes a callback function the first time that a dependency\n     * resolution is requested. The returned value is then cached and provided for all\n     * subsequent requests.\n     * @param value - The callback to call during the first resolution.\n     * @returns The resolver.\n     */\n\n  }, {\n    key: \"cachedCallback\",\n    value: function cachedCallback(value) {\n      return this.registerResolver(3\n      /* callback */\n      , cacheCallbackResult(value));\n    }\n    /**\n     * Aliases the current key to a different key.\n     * @param destinationKey - The key to point the alias to.\n     * @returns The resolver.\n     */\n\n  }, {\n    key: \"aliasTo\",\n    value: function aliasTo(destinationKey) {\n      return this.registerResolver(5\n      /* alias */\n      , destinationKey);\n    }\n  }, {\n    key: \"registerResolver\",\n    value: function registerResolver(strategy, state) {\n      var container = this.container,\n          key = this.key;\n      /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n\n      this.container = this.key = void 0;\n      return container.registerResolver(key, new ResolverImpl(key, strategy, state));\n    }\n  }]);\n\n  return ResolverBuilder;\n}();\n\nfunction cloneArrayWithPossibleProps(source) {\n  var clone = source.slice();\n  var keys = Object.keys(source);\n  var len = keys.length;\n  var key;\n\n  for (var i = 0; i < len; ++i) {\n    key = keys[i];\n\n    if (!isArrayIndex(key)) {\n      clone[key] = source[key];\n    }\n  }\n\n  return clone;\n}\n/**\n * A set of default resolvers useful in configuring a container.\n * @public\n */\n\n\nexport var DefaultResolver = Object.freeze({\n  /**\n   * Disables auto-registration and throws for all un-registered dependencies.\n   * @param key - The key to create the resolver for.\n   */\n  none: function none(key) {\n    throw Error(\"\".concat(key.toString(), \" not registered, did you forget to add @singleton()?\"));\n  },\n\n  /**\n   * Provides default singleton resolution behavior during auto-registration.\n   * @param key - The key to create the resolver for.\n   * @returns The resolver.\n   */\n  singleton: function singleton(key) {\n    return new ResolverImpl(key, 1\n    /* singleton */\n    , key);\n  },\n\n  /**\n   * Provides default transient resolution behavior during auto-registration.\n   * @param key - The key to create the resolver for.\n   * @returns The resolver.\n   */\n  transient: function transient(key) {\n    return new ResolverImpl(key, 2\n    /* transient */\n    , key);\n  }\n});\n/**\n * Configuration for a dependency injection container.\n * @public\n */\n\nexport var ContainerConfiguration = Object.freeze({\n  /**\n   * The default configuration used when creating a DOM-disconnected container.\n   * @remarks\n   * The default creates a root container, with no parent container. It does not handle\n   * owner requests and it uses singleton resolution behavior for auto-registration.\n   */\n  default: Object.freeze({\n    parentLocator: function parentLocator() {\n      return null;\n    },\n    responsibleForOwnerRequests: false,\n    defaultResolver: DefaultResolver.singleton\n  })\n});\nvar dependencyLookup = new Map();\n\nfunction getParamTypes(key) {\n  return function (Type) {\n    return Reflect.getOwnMetadata(key, Type);\n  };\n}\n\nvar rootDOMContainer = null;\n/**\n * The gateway to dependency injection APIs.\n * @public\n */\n\nexport var DI = Object.freeze({\n  /**\n   * Creates a new dependency injection container.\n   * @param config - The configuration for the container.\n   * @returns A newly created dependency injection container.\n   */\n  createContainer: function createContainer(config) {\n    return new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config));\n  },\n\n  /**\n   * Finds the dependency injection container responsible for providing dependencies\n   * to the specified node.\n   * @param node - The node to find the responsible container for.\n   * @returns The container responsible for providing dependencies to the node.\n   * @remarks\n   * This will be the same as the parent container if the specified node\n   * does not itself host a container configured with responsibleForOwnerRequests.\n   */\n  findResponsibleContainer: function findResponsibleContainer(node) {\n    var owned = node.$$container$$;\n\n    if (owned && owned.responsibleForOwnerRequests) {\n      return owned;\n    }\n\n    return DI.findParentContainer(node);\n  },\n\n  /**\n   * Find the dependency injection container up the DOM tree from this node.\n   * @param node - The node to find the parent container for.\n   * @returns The parent container of this node.\n   * @remarks\n   * This will be the same as the responsible container if the specified node\n   * does not itself host a container configured with responsibleForOwnerRequests.\n   */\n  findParentContainer: function findParentContainer(node) {\n    var event = new CustomEvent(DILocateParentEventType, {\n      bubbles: true,\n      composed: true,\n      cancelable: true,\n      detail: {\n        container: void 0\n      }\n    });\n    node.dispatchEvent(event);\n    return event.detail.container || DI.getOrCreateDOMContainer();\n  },\n\n  /**\n   * Returns a dependency injection container if one is explicitly owned by the specified\n   * node. If one is not owned, then a new container is created and assigned to the node.\n   * @param node - The node to find or create the container for.\n   * @param config - The configuration for the container if one needs to be created.\n   * @returns The located or created container.\n   * @remarks\n   * This API does not search for a responsible or parent container. It looks only for a container\n   * directly defined on the specified node and creates one at that location if one does not\n   * already exist.\n   */\n  getOrCreateDOMContainer: function getOrCreateDOMContainer(node, config) {\n    if (!node) {\n      return rootDOMContainer || (rootDOMContainer = new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config, {\n        parentLocator: function parentLocator() {\n          return null;\n        }\n      })));\n    }\n\n    return node.$$container$$ || new ContainerImpl(node, Object.assign({}, ContainerConfiguration.default, config, {\n      parentLocator: DI.findParentContainer\n    }));\n  },\n\n  /**\n   * Gets the \"design:paramtypes\" metadata for the specified type.\n   * @param Type - The type to get the metadata for.\n   * @returns The metadata array or undefined if no metadata is found.\n   */\n  getDesignParamtypes: getParamTypes(\"design:paramtypes\"),\n\n  /**\n   * Gets the \"di:paramtypes\" metadata for the specified type.\n   * @param Type - The type to get the metadata for.\n   * @returns The metadata array or undefined if no metadata is found.\n   */\n  getAnnotationParamtypes: getParamTypes(\"di:paramtypes\"),\n\n  /**\n   *\n   * @param Type - Gets the \"di:paramtypes\" metadata for the specified type. If none is found,\n   * an empty metadata array is created and added.\n   * @returns The metadata array.\n   */\n  getOrCreateAnnotationParamTypes: function getOrCreateAnnotationParamTypes(Type) {\n    var annotationParamtypes = this.getAnnotationParamtypes(Type);\n\n    if (annotationParamtypes === void 0) {\n      Reflect.defineMetadata(\"di:paramtypes\", annotationParamtypes = [], Type);\n    }\n\n    return annotationParamtypes;\n  },\n\n  /**\n   * Gets the dependency keys representing what is needed to instantiate the specified type.\n   * @param Type - The type to get the dependencies for.\n   * @returns An array of dependency keys.\n   */\n  getDependencies: function getDependencies(Type) {\n    // Note: Every detail of this getDependencies method is pretty deliberate at the moment, and probably not yet 100% tested from every possible angle,\n    // so be careful with making changes here as it can have a huge impact on complex end user apps.\n    // Preferably, only make changes to the dependency resolution process via a RFC.\n    var dependencies = dependencyLookup.get(Type);\n\n    if (dependencies === void 0) {\n      // Type.length is the number of constructor parameters. If this is 0, it could mean the class has an empty constructor\n      // but it could also mean the class has no constructor at all (in which case it inherits the constructor from the prototype).\n      // Non-zero constructor length + no paramtypes means emitDecoratorMetadata is off, or the class has no decorator.\n      // We're not doing anything with the above right now, but it's good to keep in mind for any future issues.\n      var _inject = Type.inject;\n\n      if (_inject === void 0) {\n        // design:paramtypes is set by tsc when emitDecoratorMetadata is enabled.\n        var designParamtypes = DI.getDesignParamtypes(Type); // di:paramtypes is set by the parameter decorator from DI.createInterface or by @inject\n\n        var annotationParamtypes = DI.getAnnotationParamtypes(Type);\n\n        if (designParamtypes === void 0) {\n          if (annotationParamtypes === void 0) {\n            // Only go up the prototype if neither static inject nor any of the paramtypes is defined, as\n            // there is no sound way to merge a type's deps with its prototype's deps\n            var Proto = Object.getPrototypeOf(Type);\n\n            if (typeof Proto === \"function\" && Proto !== Function.prototype) {\n              dependencies = cloneArrayWithPossibleProps(DI.getDependencies(Proto));\n            } else {\n              dependencies = [];\n            }\n          } else {\n            // No design:paramtypes so just use the di:paramtypes\n            dependencies = cloneArrayWithPossibleProps(annotationParamtypes);\n          }\n        } else if (annotationParamtypes === void 0) {\n          // No di:paramtypes so just use the design:paramtypes\n          dependencies = cloneArrayWithPossibleProps(designParamtypes);\n        } else {\n          // We've got both, so merge them (in case of conflict on same index, di:paramtypes take precedence)\n          dependencies = cloneArrayWithPossibleProps(designParamtypes);\n          var len = annotationParamtypes.length;\n          var auAnnotationParamtype;\n\n          for (var i = 0; i < len; ++i) {\n            auAnnotationParamtype = annotationParamtypes[i];\n\n            if (auAnnotationParamtype !== void 0) {\n              dependencies[i] = auAnnotationParamtype;\n            }\n          }\n\n          var keys = Object.keys(annotationParamtypes);\n          len = keys.length;\n          var key;\n\n          for (var _i = 0; _i < len; ++_i) {\n            key = keys[_i];\n\n            if (!isArrayIndex(key)) {\n              dependencies[key] = annotationParamtypes[key];\n            }\n          }\n        }\n      } else {\n        // Ignore paramtypes if we have static inject\n        dependencies = cloneArrayWithPossibleProps(_inject);\n      }\n\n      dependencyLookup.set(Type, dependencies);\n    }\n\n    return dependencies;\n  },\n\n  /**\n   * Defines a property on a web component class. The value of this property will\n   * be resolved from the dependency injection container responsible for the element\n   * instance, based on where it is connected in the DOM.\n   * @param target - The target to define the property on.\n   * @param propertyName - The name of the property to define.\n   * @param key - The dependency injection key.\n   * @param respectConnection - Indicates whether or not to update the property value if the\n   * hosting component is disconnected and then re-connected at a different location in the DOM.\n   * @remarks\n   * The respectConnection option is only applicable to elements that descend from FASTElement.\n   */\n  defineProperty: function defineProperty(target, propertyName, key) {\n    var respectConnection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var diPropertyKey = \"$di_\".concat(propertyName);\n    Reflect.defineProperty(target, propertyName, {\n      get: function get() {\n        var _this = this;\n\n        var value = this[diPropertyKey];\n\n        if (value === void 0) {\n          var container = this instanceof HTMLElement ? DI.findResponsibleContainer(this) : DI.getOrCreateDOMContainer();\n          value = container.get(key);\n          this[diPropertyKey] = value;\n\n          if (respectConnection && this instanceof FASTElement) {\n            var notifier = this.$fastController;\n\n            var handleChange = function handleChange() {\n              var newContainer = DI.findResponsibleContainer(_this);\n              var newValue = newContainer.get(key);\n              var oldValue = _this[diPropertyKey];\n\n              if (newValue !== oldValue) {\n                _this[diPropertyKey] = value;\n                notifier.notify(propertyName);\n              }\n            };\n\n            notifier.subscribe({\n              handleChange: handleChange\n            }, \"isConnected\");\n          }\n        }\n\n        return value;\n      }\n    });\n  },\n\n  /**\n   * Creates a dependency injection key.\n   * @param nameConfigOrCallback - A friendly name for the key or a lambda that configures a\n   * default resolution for the dependency.\n   * @param configuror - If a friendly name was provided for the first parameter, then an optional\n   * lambda that configures a default resolution for the dependency can be provided second.\n   * @returns The created key.\n   * @remarks\n   * The created key can be used as a property decorator or constructor parameter decorator,\n   * in addition to its standard use in an inject array or through direct container APIs.\n   */\n  createInterface: function createInterface(nameConfigOrCallback, configuror) {\n    var configure = typeof nameConfigOrCallback === \"function\" ? nameConfigOrCallback : configuror;\n    var friendlyName = typeof nameConfigOrCallback === \"string\" ? nameConfigOrCallback : nameConfigOrCallback && \"friendlyName\" in nameConfigOrCallback ? nameConfigOrCallback.friendlyName || defaultFriendlyName : defaultFriendlyName;\n    var respectConnection = typeof nameConfigOrCallback === \"string\" ? false : nameConfigOrCallback && \"respectConnection\" in nameConfigOrCallback ? nameConfigOrCallback.respectConnection || false : false;\n\n    var Interface = function _target(target, property, index) {\n      if (target == null || (this instanceof _target ? this.constructor : void 0) !== undefined) {\n        throw new Error(\"No registration for interface: '\".concat(Interface.friendlyName, \"'\"));\n      }\n\n      if (property) {\n        DI.defineProperty(target, property, Interface, respectConnection);\n      } else {\n        var annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);\n        annotationParamtypes[index] = Interface;\n      }\n    };\n\n    Interface.$isInterface = true;\n    Interface.friendlyName = friendlyName == null ? \"(anonymous)\" : friendlyName;\n\n    if (configure != null) {\n      Interface.register = function (container, key) {\n        return configure(new ResolverBuilder(container, key !== null && key !== void 0 ? key : Interface));\n      };\n    }\n\n    Interface.toString = function toString() {\n      return \"InterfaceSymbol<\".concat(Interface.friendlyName, \">\");\n    };\n\n    return Interface;\n  },\n\n  /**\n   * A decorator that specifies what to inject into its target.\n   * @param dependencies - The dependencies to inject.\n   * @returns The decorator to be applied to the target class.\n   * @remarks\n   * The decorator can be used to decorate a class, listing all of the classes dependencies.\n   * Or it can be used to decorate a constructor paramter, indicating what to inject for that\n   * parameter.\n   * Or it can be used for a web component property, indicating what that property should resolve to.\n   */\n  inject: function inject() {\n    for (var _len = arguments.length, dependencies = new Array(_len), _key = 0; _key < _len; _key++) {\n      dependencies[_key] = arguments[_key];\n    }\n\n    return function (target, key, descriptor) {\n      if (typeof descriptor === \"number\") {\n        // It's a parameter decorator.\n        var annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);\n        var dep = dependencies[0];\n\n        if (dep !== void 0) {\n          annotationParamtypes[descriptor] = dep;\n        }\n      } else if (key) {\n        DI.defineProperty(target, key, dependencies[0]);\n      } else {\n        var _annotationParamtypes = descriptor ? DI.getOrCreateAnnotationParamTypes(descriptor.value) : DI.getOrCreateAnnotationParamTypes(target);\n\n        var _dep;\n\n        for (var i = 0; i < dependencies.length; ++i) {\n          _dep = dependencies[i];\n\n          if (_dep !== void 0) {\n            _annotationParamtypes[i] = _dep;\n          }\n        }\n      }\n    };\n  },\n\n  /**\n   * Registers the `target` class as a transient dependency; each time the dependency is resolved\n   * a new instance will be created.\n   *\n   * @param target - The class / constructor function to register as transient.\n   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n   *\n   * @example\n   * On an existing class\n   * ```ts\n   * class Foo { }\n   * DI.transient(Foo);\n   * ```\n   *\n   * @example\n   * Inline declaration\n   *\n   * ```ts\n   * const Foo = DI.transient(class { });\n   * // Foo is now strongly typed with register\n   * Foo.register(container);\n   * ```\n   *\n   * @public\n   */\n  transient: function transient(target) {\n    target.register = function register(container) {\n      var registration = Registration.transient(target, target);\n      return registration.register(container);\n    };\n\n    target.registerInRequestor = false;\n    return target;\n  },\n\n  /**\n   * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n   * consecutive time the dependency is resolved, the same instance will be returned.\n   *\n   * @param target - The class / constructor function to register as a singleton.\n   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n   * @example\n   * On an existing class\n   * ```ts\n   * class Foo { }\n   * DI.singleton(Foo);\n   * ```\n   *\n   * @example\n   * Inline declaration\n   * ```ts\n   * const Foo = DI.singleton(class { });\n   * // Foo is now strongly typed with register\n   * Foo.register(container);\n   * ```\n   *\n   * @public\n   */\n  singleton: function singleton(target) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultSingletonOptions;\n\n    target.register = function register(container) {\n      var registration = Registration.singleton(target, target);\n      return registration.register(container);\n    };\n\n    target.registerInRequestor = options.scoped;\n    return target;\n  }\n});\n/**\n * The interface key that resolves the dependency injection container itself.\n * @public\n */\n\nexport var Container = DI.createInterface(\"Container\");\n/**\n * The interface key that resolves the service locator itself.\n * @public\n */\n\nexport var ServiceLocator = Container;\n\nfunction createResolver(getter) {\n  return function (key) {\n    var resolver = function resolver(target, property, descriptor) {\n      DI.inject(resolver)(target, property, descriptor);\n    };\n\n    resolver.$isResolver = true;\n\n    resolver.resolve = function (handler, requestor) {\n      return getter(key, handler, requestor);\n    };\n\n    return resolver;\n  };\n}\n/**\n * A decorator that specifies what to inject into its target.\n * @param dependencies - The dependencies to inject.\n * @returns The decorator to be applied to the target class.\n * @remarks\n * The decorator can be used to decorate a class, listing all of the classes dependencies.\n * Or it can be used to decorate a constructor paramter, indicating what to inject for that\n * parameter.\n * Or it can be used for a web component property, indicating what that property should resolve to.\n *\n * @public\n */\n\n\nexport var inject = DI.inject;\n\nfunction transientDecorator(target) {\n  return DI.transient(target);\n}\n\nexport function transient(target) {\n  return target == null ? transientDecorator : transientDecorator(target);\n}\nvar defaultSingletonOptions = {\n  scoped: false\n};\n\nfunction singletonDecorator(target) {\n  return DI.singleton(target);\n}\n/**\n * @public\n */\n\n\nexport function singleton(targetOrOptions) {\n  if (typeof targetOrOptions === \"function\") {\n    return DI.singleton(targetOrOptions);\n  }\n\n  return function ($target) {\n    return DI.singleton($target, targetOrOptions);\n  };\n}\n\nfunction createAllResolver(getter) {\n  return function (key, searchAncestors) {\n    searchAncestors = !!searchAncestors;\n\n    var resolver = function resolver(target, property, descriptor) {\n      DI.inject(resolver)(target, property, descriptor);\n    };\n\n    resolver.$isResolver = true;\n\n    resolver.resolve = function (handler, requestor) {\n      /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n      return getter(key, handler, requestor, searchAncestors);\n    };\n\n    return resolver;\n  };\n}\n/**\n * A decorator and DI resolver that will resolve an array of all dependencies\n * registered with the specified key.\n * @param key - The key to resolve all dependencies for.\n * @param searchAncestors - [optional] Indicates whether to search ancestor containers.\n * @public\n */\n\n\nexport var all = createAllResolver(function (key, handler, requestor, searchAncestors) {\n  return requestor.getAll(key, searchAncestors);\n});\n/**\n * A decorator that lazily injects a dependency depending on whether the `Key` is present at the time of function call.\n *\n * @example\n * You need to make your argument a function that returns the type, for example\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => number )\n * }\n * const foo = container.get(Foo); // instanceof Foo\n * foo.random(); // throws\n * ```\n * would throw an exception because you haven't registered `'random'` before calling the method.\n * @example\n * This, would give you a new 'Math.random()' number each time.\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => random )\n * }\n * container.register(Registration.callback('random', Math.random ));\n * container.get(Foo).random(); // some random number\n * container.get(Foo).random(); // another random number\n * ```\n *\n * `@lazy` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a\n * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.\n *\n * @param key - The key to lazily resolve.\n * see {@link DI.createInterface} on interactions with interfaces\n *\n * @public\n */\n\nexport var lazy = createResolver(function (key, handler, requestor) {\n  return function () {\n    return requestor.get(key);\n  };\n});\n/**\n * A decorator that allows you to optionally inject a dependency depending on whether the [[`Key`]] is present, for example:\n * @example\n * ```ts\n * class Foo {\n *   constructor( @inject('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo); // throws\n * ```\n * would fail\n *\n * @example\n * ```ts\n * class Foo {\n *   constructor( @optional('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo).str // somestring\n * ```\n * if you use it without a default it will inject `undefined`, so remember to mark your input type as\n * possibly `undefined`!\n *\n * @param key - The key to optionally resolve.\n * see {@link DI.createInterface} on interactions with interfaces\n *\n * @public\n */\n\nexport var optional = createResolver(function (key, handler, requestor) {\n  if (requestor.has(key, true)) {\n    return requestor.get(key);\n  } else {\n    return undefined;\n  }\n});\n/**\n * A decorator that tells the container not to try to inject a dependency.\n *\n * @public\n */\n\nexport function ignore(target, property, descriptor) {\n  DI.inject(ignore)(target, property, descriptor);\n} // Hack: casting below used to prevent TS from generate a namespace which can't be commented\n// and results in documentation validation errors.\n\nignore.$isResolver = true;\n\nignore.resolve = function () {\n  return undefined;\n};\n/**\n * A decorator that indicates that a new instance should be injected scoped to the\n * container that requested the instance.\n * @param key - The dependency key for the new instance.\n * @remarks\n * This creates a resolver with an instance strategy pointing to the new instance, effectively\n * making this a singleton, scoped to the container or DOM's subtree.\n *\n * @public\n */\n\n\nexport var newInstanceForScope = createResolver(function (key, handler, requestor) {\n  var instance = createNewInstance(key, handler);\n  var resolver = new ResolverImpl(key, 0\n  /* instance */\n  , instance);\n  requestor.registerResolver(key, resolver);\n  return instance;\n});\n/**\n * A decorator that indicates that a new instance should be injected.\n * @param key - The dependency key for the new instance.\n * @remarks\n * The instance is not internally cached with a resolver as newInstanceForScope does.\n *\n * @public\n */\n\nexport var newInstanceOf = createResolver(function (key, handler, _requestor) {\n  return createNewInstance(key, handler);\n});\n\nfunction createNewInstance(key, handler) {\n  /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n  return handler.getFactory(key).construct(handler);\n}\n/** @internal */\n\n\nexport var ResolverImpl = /*#__PURE__*/function () {\n  function ResolverImpl(key, strategy, state) {\n    _classCallCheck(this, ResolverImpl);\n\n    this.key = key;\n    this.strategy = strategy;\n    this.state = state;\n    this.resolving = false;\n  }\n\n  _createClass(ResolverImpl, [{\n    key: \"$isResolver\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"register\",\n    value: function register(container) {\n      return container.registerResolver(this.key, this);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(handler, requestor) {\n      switch (this.strategy) {\n        case 0\n        /* instance */\n        :\n          return this.state;\n\n        case 1\n        /* singleton */\n        :\n          {\n            if (this.resolving) {\n              throw new Error(\"Cyclic dependency found: \".concat(this.state.name));\n            }\n\n            this.resolving = true;\n            this.state = handler.getFactory(this.state).construct(requestor);\n            this.strategy = 0\n            /* instance */\n            ;\n            this.resolving = false;\n            return this.state;\n          }\n\n        case 2\n        /* transient */\n        :\n          {\n            // Always create transients from the requesting container\n            var factory = handler.getFactory(this.state);\n\n            if (factory === null) {\n              throw new Error(\"Resolver for \".concat(String(this.key), \" returned a null factory\"));\n            }\n\n            return factory.construct(requestor);\n          }\n\n        case 3\n        /* callback */\n        :\n          return this.state(handler, requestor, this);\n\n        case 4\n        /* array */\n        :\n          return this.state[0].resolve(handler, requestor);\n\n        case 5\n        /* alias */\n        :\n          return requestor.get(this.state);\n\n        default:\n          throw new Error(\"Invalid resolver strategy specified: \".concat(this.strategy, \".\"));\n      }\n    }\n  }, {\n    key: \"getFactory\",\n    value: function getFactory(container) {\n      var _a, _b, _c;\n\n      switch (this.strategy) {\n        case 1\n        /* singleton */\n        :\n        case 2\n        /* transient */\n        :\n          return container.getFactory(this.state);\n\n        case 5\n        /* alias */\n        :\n          return (_c = (_b = (_a = container.getResolver(this.state)) === null || _a === void 0 ? void 0 : _a.getFactory) === null || _b === void 0 ? void 0 : _b.call(_a, container)) !== null && _c !== void 0 ? _c : null;\n\n        default:\n          return null;\n      }\n    }\n  }]);\n\n  return ResolverImpl;\n}();\n\nfunction containerGetKey(d) {\n  return this.get(d);\n}\n\nfunction transformInstance(inst, transform) {\n  return transform(inst);\n}\n/** @internal */\n\n\nexport var FactoryImpl = /*#__PURE__*/function () {\n  function FactoryImpl(Type, dependencies) {\n    _classCallCheck(this, FactoryImpl);\n\n    this.Type = Type;\n    this.dependencies = dependencies;\n    this.transformers = null;\n  }\n\n  _createClass(FactoryImpl, [{\n    key: \"construct\",\n    value: function construct(container, dynamicDependencies) {\n      var instance;\n\n      if (dynamicDependencies === void 0) {\n        instance = _construct(this.Type, _toConsumableArray(this.dependencies.map(containerGetKey, container)));\n      } else {\n        instance = _construct(this.Type, _toConsumableArray(this.dependencies.map(containerGetKey, container)).concat(_toConsumableArray(dynamicDependencies)));\n      }\n\n      if (this.transformers == null) {\n        return instance;\n      }\n\n      return this.transformers.reduce(transformInstance, instance);\n    }\n  }, {\n    key: \"registerTransformer\",\n    value: function registerTransformer(transformer) {\n      (this.transformers || (this.transformers = [])).push(transformer);\n    }\n  }]);\n\n  return FactoryImpl;\n}();\nvar containerResolver = {\n  $isResolver: true,\n  resolve: function resolve(handler, requestor) {\n    return requestor;\n  }\n};\n\nfunction isRegistry(obj) {\n  return typeof obj.register === \"function\";\n}\n\nfunction isSelfRegistry(obj) {\n  return isRegistry(obj) && typeof obj.registerInRequestor === \"boolean\";\n}\n\nfunction isRegisterInRequester(obj) {\n  return isSelfRegistry(obj) && obj.registerInRequestor;\n}\n\nfunction isClass(obj) {\n  return obj.prototype !== void 0;\n}\n\nvar InstrinsicTypeNames = new Set([\"Array\", \"ArrayBuffer\", \"Boolean\", \"DataView\", \"Date\", \"Error\", \"EvalError\", \"Float32Array\", \"Float64Array\", \"Function\", \"Int8Array\", \"Int16Array\", \"Int32Array\", \"Map\", \"Number\", \"Object\", \"Promise\", \"RangeError\", \"ReferenceError\", \"RegExp\", \"Set\", \"SharedArrayBuffer\", \"String\", \"SyntaxError\", \"TypeError\", \"Uint8Array\", \"Uint8ClampedArray\", \"Uint16Array\", \"Uint32Array\", \"URIError\", \"WeakMap\", \"WeakSet\"]);\nvar DILocateParentEventType = \"__DI_LOCATE_PARENT__\";\nvar factories = new Map();\n/**\n * @internal\n */\n\nexport var ContainerImpl = /*#__PURE__*/function () {\n  function ContainerImpl(owner, config) {\n    var _this2 = this;\n\n    _classCallCheck(this, ContainerImpl);\n\n    this.owner = owner;\n    this.config = config;\n    this._parent = void 0;\n    this.registerDepth = 0;\n    this.context = null;\n\n    if (owner !== null) {\n      owner.$$container$$ = this;\n    }\n\n    this.resolvers = new Map();\n    this.resolvers.set(Container, containerResolver);\n\n    if (owner instanceof Node) {\n      owner.addEventListener(DILocateParentEventType, function (e) {\n        if (e.composedPath()[0] !== _this2.owner) {\n          e.detail.container = _this2;\n          e.stopImmediatePropagation();\n        }\n      });\n    }\n  }\n\n  _createClass(ContainerImpl, [{\n    key: \"parent\",\n    get: function get() {\n      if (this._parent === void 0) {\n        this._parent = this.config.parentLocator(this.owner);\n      }\n\n      return this._parent;\n    }\n  }, {\n    key: \"depth\",\n    get: function get() {\n      return this.parent === null ? 0 : this.parent.depth + 1;\n    }\n  }, {\n    key: \"responsibleForOwnerRequests\",\n    get: function get() {\n      return this.config.responsibleForOwnerRequests;\n    }\n  }, {\n    key: \"registerWithContext\",\n    value: function registerWithContext(context) {\n      this.context = context;\n\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n\n      this.register.apply(this, params);\n      this.context = null;\n      return this;\n    }\n  }, {\n    key: \"register\",\n    value: function register() {\n      if (++this.registerDepth === 100) {\n        throw new Error(\"Unable to autoregister dependency\"); // Most likely cause is trying to register a plain object that does not have a\n        // register method and is not a class constructor\n      }\n\n      var current;\n      var keys;\n      var value;\n      var j;\n      var jj;\n      var context = this.context;\n\n      for (var i = 0, ii = arguments.length; i < ii; ++i) {\n        current = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n        if (!isObject(current)) {\n          continue;\n        }\n\n        if (isRegistry(current)) {\n          current.register(this, context);\n        } else if (isClass(current)) {\n          Registration.singleton(current, current).register(this);\n        } else {\n          keys = Object.keys(current);\n          j = 0;\n          jj = keys.length;\n\n          for (; j < jj; ++j) {\n            value = current[keys[j]];\n\n            if (!isObject(value)) {\n              continue;\n            } // note: we could remove this if-branch and call this.register directly\n            // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator\n\n\n            if (isRegistry(value)) {\n              value.register(this, context);\n            } else {\n              this.register(value);\n            }\n          }\n        }\n      }\n\n      --this.registerDepth;\n      return this;\n    }\n  }, {\n    key: \"registerResolver\",\n    value: function registerResolver(key, resolver) {\n      validateKey(key);\n      var resolvers = this.resolvers;\n      var result = resolvers.get(key);\n\n      if (result == null) {\n        resolvers.set(key, resolver);\n      } else if (result instanceof ResolverImpl && result.strategy === 4\n      /* array */\n      ) {\n        result.state.push(resolver);\n      } else {\n        resolvers.set(key, new ResolverImpl(key, 4\n        /* array */\n        , [result, resolver]));\n      }\n\n      return resolver;\n    }\n  }, {\n    key: \"registerTransformer\",\n    value: function registerTransformer(key, transformer) {\n      var resolver = this.getResolver(key);\n\n      if (resolver == null) {\n        return false;\n      }\n\n      if (resolver.getFactory) {\n        var factory = resolver.getFactory(this);\n\n        if (factory == null) {\n          return false;\n        } // This type cast is a bit of a hacky one, necessary due to the duplicity of IResolverLike.\n        // Problem is that that interface's type arg can be of type Key, but the getFactory method only works on\n        // type Constructable. So the return type of that optional method has this additional constraint, which\n        // seems to confuse the type checker.\n\n\n        factory.registerTransformer(transformer);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getResolver\",\n    value: function getResolver(key) {\n      var autoRegister = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      validateKey(key);\n\n      if (key.resolve !== void 0) {\n        return key;\n      }\n      /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n\n\n      var current = this;\n      var resolver;\n\n      while (current != null) {\n        resolver = current.resolvers.get(key);\n\n        if (resolver == null) {\n          if (current.parent == null) {\n            var handler = isRegisterInRequester(key) ? this : current;\n            return autoRegister ? this.jitRegister(key, handler) : null;\n          }\n\n          current = current.parent;\n        } else {\n          return resolver;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      var searchAncestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.resolvers.has(key) ? true : searchAncestors && this.parent != null ? this.parent.has(key, true) : false;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      validateKey(key);\n\n      if (key.$isResolver) {\n        return key.resolve(this, this);\n      }\n      /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n\n\n      var current = this;\n      var resolver;\n\n      while (current != null) {\n        resolver = current.resolvers.get(key);\n\n        if (resolver == null) {\n          if (current.parent == null) {\n            var handler = isRegisterInRequester(key) ? this : current;\n            resolver = this.jitRegister(key, handler);\n            return resolver.resolve(current, this);\n          }\n\n          current = current.parent;\n        } else {\n          return resolver.resolve(current, this);\n        }\n      }\n\n      throw new Error(\"Unable to resolve key: \".concat(key));\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll(key) {\n      var searchAncestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      validateKey(key);\n      /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n\n      var requestor = this;\n      var current = requestor;\n      var resolver;\n\n      if (searchAncestors) {\n        var resolutions = emptyArray;\n\n        while (current != null) {\n          resolver = current.resolvers.get(key);\n\n          if (resolver != null) {\n            resolutions = resolutions.concat(\n            /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n            buildAllResponse(resolver, current, requestor));\n          }\n\n          current = current.parent;\n        }\n\n        return resolutions;\n      } else {\n        while (current != null) {\n          resolver = current.resolvers.get(key);\n\n          if (resolver == null) {\n            current = current.parent;\n\n            if (current == null) {\n              return emptyArray;\n            }\n          } else {\n            return buildAllResponse(resolver, current, requestor);\n          }\n        }\n      }\n\n      return emptyArray;\n    }\n  }, {\n    key: \"getFactory\",\n    value: function getFactory(Type) {\n      var factory = factories.get(Type);\n\n      if (factory === void 0) {\n        if (isNativeFunction(Type)) {\n          throw new Error(\"\".concat(Type.name, \" is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.\"));\n        }\n\n        factories.set(Type, factory = new FactoryImpl(Type, DI.getDependencies(Type)));\n      }\n\n      return factory;\n    }\n  }, {\n    key: \"registerFactory\",\n    value: function registerFactory(key, factory) {\n      factories.set(key, factory);\n    }\n  }, {\n    key: \"createChild\",\n    value: function createChild(config) {\n      var _this3 = this;\n\n      return new ContainerImpl(null, Object.assign({}, this.config, config, {\n        parentLocator: function parentLocator() {\n          return _this3;\n        }\n      }));\n    }\n  }, {\n    key: \"jitRegister\",\n    value: function jitRegister(keyAsValue, handler) {\n      if (typeof keyAsValue !== \"function\") {\n        throw new Error(\"Attempted to jitRegister something that is not a constructor: '\".concat(keyAsValue, \"'. Did you forget to register this dependency?\"));\n      }\n\n      if (InstrinsicTypeNames.has(keyAsValue.name)) {\n        throw new Error(\"Attempted to jitRegister an intrinsic type: \".concat(keyAsValue.name, \". Did you forget to add @inject(Key)\"));\n      }\n\n      if (isRegistry(keyAsValue)) {\n        var registrationResolver = keyAsValue.register(handler);\n\n        if (!(registrationResolver instanceof Object) || registrationResolver.resolve == null) {\n          var newResolver = handler.resolvers.get(keyAsValue);\n\n          if (newResolver != void 0) {\n            return newResolver;\n          }\n\n          throw new Error(\"A valid resolver was not returned from the static register method\");\n        }\n\n        return registrationResolver;\n      } else if (keyAsValue.$isInterface) {\n        throw new Error(\"Attempted to jitRegister an interface: \".concat(keyAsValue.friendlyName));\n      } else {\n        var resolver = this.config.defaultResolver(keyAsValue, handler);\n        handler.resolvers.set(keyAsValue, resolver);\n        return resolver;\n      }\n    }\n  }]);\n\n  return ContainerImpl;\n}();\nvar cache = new WeakMap();\n\nfunction cacheCallbackResult(fun) {\n  return function (handler, requestor, resolver) {\n    if (cache.has(resolver)) {\n      return cache.get(resolver);\n    }\n\n    var t = fun(handler, requestor, resolver);\n    cache.set(resolver, t);\n    return t;\n  };\n}\n/**\n * You can use the resulting Registration of any of the factory methods\n * to register with the container.\n *\n * @example\n * ```\n * class Foo {}\n * const container = DI.createContainer();\n * container.register(Registration.instance(Foo, new Foo()));\n * container.get(Foo);\n * ```\n *\n * @public\n */\n\n\nexport var Registration = Object.freeze({\n  /**\n   * Allows you to pass an instance.\n   * Every time you request this {@link Key} you will get this instance back.\n   *\n   * @example\n   * ```\n   * Registration.instance(Foo, new Foo()));\n   * ```\n   *\n   * @param key - The key to register the instance under.\n   * @param value - The instance to return when the key is requested.\n   */\n  instance: function instance(key, value) {\n    return new ResolverImpl(key, 0\n    /* instance */\n    , value);\n  },\n\n  /**\n   * Creates an instance from the class.\n   * Every time you request this {@link Key} you will get the same one back.\n   *\n   * @example\n   * ```\n   * Registration.singleton(Foo, Foo);\n   * ```\n   *\n   * @param key - The key to register the singleton under.\n   * @param value - The class to instantiate as a singleton when first requested.\n   */\n  singleton: function singleton(key, value) {\n    return new ResolverImpl(key, 1\n    /* singleton */\n    , value);\n  },\n\n  /**\n   * Creates an instance from a class.\n   * Every time you request this {@link Key} you will get a new instance.\n   *\n   * @example\n   * ```\n   * Registration.instance(Foo, Foo);\n   * ```\n   *\n   * @param key - The key to register the instance type under.\n   * @param value - The class to instantiate each time the key is requested.\n   */\n  transient: function transient(key, value) {\n    return new ResolverImpl(key, 2\n    /* transient */\n    , value);\n  },\n\n  /**\n   * Delegates to a callback function to provide the dependency.\n   * Every time you request this {@link Key} the callback will be invoked to provide\n   * the dependency.\n   *\n   * @example\n   * ```\n   * Registration.callback(Foo, () => new Foo());\n   * Registration.callback(Bar, (c: Container) => new Bar(c.get(Foo)));\n   * ```\n   *\n   * @param key - The key to register the callback for.\n   * @param callback - The function that is expected to return the dependency.\n   */\n  callback: function callback(key, _callback) {\n    return new ResolverImpl(key, 3\n    /* callback */\n    , _callback);\n  },\n\n  /**\n   * Delegates to a callback function to provide the dependency and then caches the\n   * dependency for future requests.\n   *\n   * @example\n   * ```\n   * Registration.cachedCallback(Foo, () => new Foo());\n   * Registration.cachedCallback(Bar, (c: Container) => new Bar(c.get(Foo)));\n   * ```\n   *\n   * @param key - The key to register the callback for.\n   * @param callback - The function that is expected to return the dependency.\n   * @remarks\n   * If you pass the same Registration to another container, the same cached value will be used.\n   * Should all references to the resolver returned be removed, the cache will expire.\n   */\n  cachedCallback: function cachedCallback(key, callback) {\n    return new ResolverImpl(key, 3\n    /* callback */\n    , cacheCallbackResult(callback));\n  },\n\n  /**\n   * Creates an alternate {@link Key} to retrieve an instance by.\n   *\n   * @example\n   * ```\n   * Register.singleton(Foo, Foo)\n   * Register.aliasTo(Foo, MyFoos);\n   *\n   * container.getAll(MyFoos) // contains an instance of Foo\n   * ```\n   *\n   * @param originalKey - The original key that has been registered.\n   * @param aliasKey - The alias to the original key.\n   */\n  aliasTo: function aliasTo(originalKey, aliasKey) {\n    return new ResolverImpl(aliasKey, 5\n    /* alias */\n    , originalKey);\n  }\n});\n/** @internal */\n\nexport function validateKey(key) {\n  if (key === null || key === void 0) {\n    throw new Error(\"key/value cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?\");\n  }\n}\n\nfunction buildAllResponse(resolver, handler, requestor) {\n  if (resolver instanceof ResolverImpl && resolver.strategy === 4\n  /* array */\n  ) {\n    var state = resolver.state;\n    var i = state.length;\n    var results = new Array(i);\n\n    while (i--) {\n      results[i] = state[i].resolve(handler, requestor);\n    }\n\n    return results;\n  }\n\n  return [resolver.resolve(handler, requestor)];\n}\n\nvar defaultFriendlyName = \"(anonymous)\";\n\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null || typeof value === \"function\";\n}\n/**\n * Determine whether the value is a native function.\n *\n * @param fn - The function to check.\n * @returns `true` is the function is a native function, otherwise `false`\n */\n\n\nvar isNativeFunction = function () {\n  var lookup = new WeakMap();\n  var isNative = false;\n  var sourceText = \"\";\n  var i = 0;\n  return function (fn) {\n    isNative = lookup.get(fn);\n\n    if (isNative === void 0) {\n      sourceText = fn.toString();\n      i = sourceText.length; // http://www.ecma-international.org/ecma-262/#prod-NativeFunction\n\n      isNative = // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string\n      i >= 29 && // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.\n      i <= 100 && // This whole heuristic *could* be tricked by a comment. Do we need to care about that?\n      sourceText.charCodeAt(i - 1) === 0x7d && // }\n      // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.\n      sourceText.charCodeAt(i - 2) <= 0x20 && // whitespace\n      sourceText.charCodeAt(i - 3) === 0x5d && // ]\n      sourceText.charCodeAt(i - 4) === 0x65 && // e\n      sourceText.charCodeAt(i - 5) === 0x64 && // d\n      sourceText.charCodeAt(i - 6) === 0x6f && // o\n      sourceText.charCodeAt(i - 7) === 0x63 && // c\n      sourceText.charCodeAt(i - 8) === 0x20 && //\n      sourceText.charCodeAt(i - 9) === 0x65 && // e\n      sourceText.charCodeAt(i - 10) === 0x76 && // v\n      sourceText.charCodeAt(i - 11) === 0x69 && // i\n      sourceText.charCodeAt(i - 12) === 0x74 && // t\n      sourceText.charCodeAt(i - 13) === 0x61 && // a\n      sourceText.charCodeAt(i - 14) === 0x6e && // n\n      sourceText.charCodeAt(i - 15) === 0x58; // [\n\n      lookup.set(fn, isNative);\n    }\n\n    return isNative;\n  };\n}();\n\nvar isNumericLookup = {};\n\nfunction isArrayIndex(value) {\n  switch (typeof value) {\n    case \"number\":\n      return value >= 0 && (value | 0) === value;\n\n    case \"string\":\n      {\n        var result = isNumericLookup[value];\n\n        if (result !== void 0) {\n          return result;\n        }\n\n        var length = value.length;\n\n        if (length === 0) {\n          return isNumericLookup[value] = false;\n        }\n\n        var ch = 0;\n\n        for (var i = 0; i < length; ++i) {\n          ch = value.charCodeAt(i);\n\n          if (i === 0 && ch === 0x30 && length > 1\n          /* must not start with 0 */\n          || ch < 0x30\n          /* 0 */\n          || ch > 0x39\n          /* 9 */\n          ) {\n            return isNumericLookup[value] = false;\n          }\n        }\n\n        return isNumericLookup[value] = true;\n      }\n\n    default:\n      return false;\n  }\n}","map":{"version":3,"names":["emptyArray","FASTElement","metadataByTarget","Map","Reflect","metadata","key","value","target","defineMetadata","get","set","getOwnMetadata","ResolverBuilder","container","registerResolver","cacheCallbackResult","destinationKey","strategy","state","ResolverImpl","cloneArrayWithPossibleProps","source","clone","slice","keys","Object","len","length","i","isArrayIndex","DefaultResolver","freeze","none","Error","toString","singleton","transient","ContainerConfiguration","default","parentLocator","responsibleForOwnerRequests","defaultResolver","dependencyLookup","getParamTypes","Type","rootDOMContainer","DI","createContainer","config","ContainerImpl","assign","findResponsibleContainer","node","owned","$$container$$","findParentContainer","event","CustomEvent","DILocateParentEventType","bubbles","composed","cancelable","detail","dispatchEvent","getOrCreateDOMContainer","getDesignParamtypes","getAnnotationParamtypes","getOrCreateAnnotationParamTypes","annotationParamtypes","getDependencies","dependencies","inject","designParamtypes","Proto","getPrototypeOf","Function","prototype","auAnnotationParamtype","defineProperty","propertyName","respectConnection","diPropertyKey","HTMLElement","notifier","$fastController","handleChange","newContainer","newValue","oldValue","notify","subscribe","createInterface","nameConfigOrCallback","configuror","configure","friendlyName","defaultFriendlyName","Interface","property","index","undefined","$isInterface","register","descriptor","dep","registration","Registration","registerInRequestor","options","defaultSingletonOptions","scoped","Container","ServiceLocator","createResolver","getter","resolver","$isResolver","resolve","handler","requestor","transientDecorator","singletonDecorator","targetOrOptions","$target","createAllResolver","searchAncestors","all","getAll","lazy","optional","has","ignore","newInstanceForScope","instance","createNewInstance","newInstanceOf","_requestor","getFactory","construct","resolving","name","factory","String","_a","_b","_c","getResolver","call","containerGetKey","d","transformInstance","inst","transform","FactoryImpl","transformers","dynamicDependencies","map","reduce","transformer","push","containerResolver","isRegistry","obj","isSelfRegistry","isRegisterInRequester","isClass","InstrinsicTypeNames","Set","factories","owner","_parent","registerDepth","context","resolvers","Node","addEventListener","e","composedPath","stopImmediatePropagation","parent","depth","params","current","j","jj","ii","isObject","validateKey","result","registerTransformer","autoRegister","jitRegister","resolutions","concat","buildAllResponse","isNativeFunction","keyAsValue","registrationResolver","newResolver","cache","WeakMap","fun","t","callback","cachedCallback","aliasTo","originalKey","aliasKey","results","Array","lookup","isNative","sourceText","fn","charCodeAt","isNumericLookup","ch"],"sources":["/Users/gaborcsardi/works/rig/vscode/webview-ui/node_modules/@microsoft/fast-foundation/dist/esm/di/di.js"],"sourcesContent":["/**\n * Big thanks to https://github.com/fkleuver and the https://github.com/aurelia/aurelia project\n * for the bulk of this code and many of the associated tests.\n */\nimport { emptyArray, FASTElement } from \"@microsoft/fast-element\";\n// Tiny polyfill for TypeScript's Reflect metadata API.\nconst metadataByTarget = new Map();\nif (!(\"metadata\" in Reflect)) {\n    Reflect.metadata = function (key, value) {\n        return function (target) {\n            Reflect.defineMetadata(key, value, target);\n        };\n    };\n    Reflect.defineMetadata = function (key, value, target) {\n        let metadata = metadataByTarget.get(target);\n        if (metadata === void 0) {\n            metadataByTarget.set(target, (metadata = new Map()));\n        }\n        metadata.set(key, value);\n    };\n    Reflect.getOwnMetadata = function (key, target) {\n        const metadata = metadataByTarget.get(target);\n        if (metadata !== void 0) {\n            return metadata.get(key);\n        }\n        return void 0;\n    };\n}\n/**\n * A utility class used that constructs and registers resolvers for a dependency\n * injection container. Supports a standard set of object lifetimes.\n * @public\n */\nexport class ResolverBuilder {\n    /**\n     *\n     * @param container - The container to create resolvers for.\n     * @param key - The key to register resolvers under.\n     */\n    constructor(container, key) {\n        this.container = container;\n        this.key = key;\n    }\n    /**\n     * Creates a resolver for an existing object instance.\n     * @param value - The instance to resolve.\n     * @returns The resolver.\n     */\n    instance(value) {\n        return this.registerResolver(0 /* instance */, value);\n    }\n    /**\n     * Creates a resolver that enforces a singleton lifetime.\n     * @param value - The type to create and cache the singleton for.\n     * @returns The resolver.\n     */\n    singleton(value) {\n        return this.registerResolver(1 /* singleton */, value);\n    }\n    /**\n     * Creates a resolver that creates a new instance for every dependency request.\n     * @param value - The type to create instances of.\n     * @returns - The resolver.\n     */\n    transient(value) {\n        return this.registerResolver(2 /* transient */, value);\n    }\n    /**\n     * Creates a resolver that invokes a callback function for every dependency resolution\n     * request, allowing custom logic to return the dependency.\n     * @param value - The callback to call during resolution.\n     * @returns The resolver.\n     */\n    callback(value) {\n        return this.registerResolver(3 /* callback */, value);\n    }\n    /**\n     * Creates a resolver that invokes a callback function the first time that a dependency\n     * resolution is requested. The returned value is then cached and provided for all\n     * subsequent requests.\n     * @param value - The callback to call during the first resolution.\n     * @returns The resolver.\n     */\n    cachedCallback(value) {\n        return this.registerResolver(3 /* callback */, cacheCallbackResult(value));\n    }\n    /**\n     * Aliases the current key to a different key.\n     * @param destinationKey - The key to point the alias to.\n     * @returns The resolver.\n     */\n    aliasTo(destinationKey) {\n        return this.registerResolver(5 /* alias */, destinationKey);\n    }\n    registerResolver(strategy, state) {\n        const { container, key } = this;\n        /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n        this.container = this.key = (void 0);\n        return container.registerResolver(key, new ResolverImpl(key, strategy, state));\n    }\n}\nfunction cloneArrayWithPossibleProps(source) {\n    const clone = source.slice();\n    const keys = Object.keys(source);\n    const len = keys.length;\n    let key;\n    for (let i = 0; i < len; ++i) {\n        key = keys[i];\n        if (!isArrayIndex(key)) {\n            clone[key] = source[key];\n        }\n    }\n    return clone;\n}\n/**\n * A set of default resolvers useful in configuring a container.\n * @public\n */\nexport const DefaultResolver = Object.freeze({\n    /**\n     * Disables auto-registration and throws for all un-registered dependencies.\n     * @param key - The key to create the resolver for.\n     */\n    none(key) {\n        throw Error(`${key.toString()} not registered, did you forget to add @singleton()?`);\n    },\n    /**\n     * Provides default singleton resolution behavior during auto-registration.\n     * @param key - The key to create the resolver for.\n     * @returns The resolver.\n     */\n    singleton(key) {\n        return new ResolverImpl(key, 1 /* singleton */, key);\n    },\n    /**\n     * Provides default transient resolution behavior during auto-registration.\n     * @param key - The key to create the resolver for.\n     * @returns The resolver.\n     */\n    transient(key) {\n        return new ResolverImpl(key, 2 /* transient */, key);\n    },\n});\n/**\n * Configuration for a dependency injection container.\n * @public\n */\nexport const ContainerConfiguration = Object.freeze({\n    /**\n     * The default configuration used when creating a DOM-disconnected container.\n     * @remarks\n     * The default creates a root container, with no parent container. It does not handle\n     * owner requests and it uses singleton resolution behavior for auto-registration.\n     */\n    default: Object.freeze({\n        parentLocator: () => null,\n        responsibleForOwnerRequests: false,\n        defaultResolver: DefaultResolver.singleton,\n    }),\n});\nconst dependencyLookup = new Map();\nfunction getParamTypes(key) {\n    return (Type) => {\n        return Reflect.getOwnMetadata(key, Type);\n    };\n}\nlet rootDOMContainer = null;\n/**\n * The gateway to dependency injection APIs.\n * @public\n */\nexport const DI = Object.freeze({\n    /**\n     * Creates a new dependency injection container.\n     * @param config - The configuration for the container.\n     * @returns A newly created dependency injection container.\n     */\n    createContainer(config) {\n        return new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config));\n    },\n    /**\n     * Finds the dependency injection container responsible for providing dependencies\n     * to the specified node.\n     * @param node - The node to find the responsible container for.\n     * @returns The container responsible for providing dependencies to the node.\n     * @remarks\n     * This will be the same as the parent container if the specified node\n     * does not itself host a container configured with responsibleForOwnerRequests.\n     */\n    findResponsibleContainer(node) {\n        const owned = node.$$container$$;\n        if (owned && owned.responsibleForOwnerRequests) {\n            return owned;\n        }\n        return DI.findParentContainer(node);\n    },\n    /**\n     * Find the dependency injection container up the DOM tree from this node.\n     * @param node - The node to find the parent container for.\n     * @returns The parent container of this node.\n     * @remarks\n     * This will be the same as the responsible container if the specified node\n     * does not itself host a container configured with responsibleForOwnerRequests.\n     */\n    findParentContainer(node) {\n        const event = new CustomEvent(DILocateParentEventType, {\n            bubbles: true,\n            composed: true,\n            cancelable: true,\n            detail: { container: void 0 },\n        });\n        node.dispatchEvent(event);\n        return event.detail.container || DI.getOrCreateDOMContainer();\n    },\n    /**\n     * Returns a dependency injection container if one is explicitly owned by the specified\n     * node. If one is not owned, then a new container is created and assigned to the node.\n     * @param node - The node to find or create the container for.\n     * @param config - The configuration for the container if one needs to be created.\n     * @returns The located or created container.\n     * @remarks\n     * This API does not search for a responsible or parent container. It looks only for a container\n     * directly defined on the specified node and creates one at that location if one does not\n     * already exist.\n     */\n    getOrCreateDOMContainer(node, config) {\n        if (!node) {\n            return (rootDOMContainer ||\n                (rootDOMContainer = new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config, {\n                    parentLocator: () => null,\n                }))));\n        }\n        return (node.$$container$$ ||\n            new ContainerImpl(node, Object.assign({}, ContainerConfiguration.default, config, {\n                parentLocator: DI.findParentContainer,\n            })));\n    },\n    /**\n     * Gets the \"design:paramtypes\" metadata for the specified type.\n     * @param Type - The type to get the metadata for.\n     * @returns The metadata array or undefined if no metadata is found.\n     */\n    getDesignParamtypes: getParamTypes(\"design:paramtypes\"),\n    /**\n     * Gets the \"di:paramtypes\" metadata for the specified type.\n     * @param Type - The type to get the metadata for.\n     * @returns The metadata array or undefined if no metadata is found.\n     */\n    getAnnotationParamtypes: getParamTypes(\"di:paramtypes\"),\n    /**\n     *\n     * @param Type - Gets the \"di:paramtypes\" metadata for the specified type. If none is found,\n     * an empty metadata array is created and added.\n     * @returns The metadata array.\n     */\n    getOrCreateAnnotationParamTypes(Type) {\n        let annotationParamtypes = this.getAnnotationParamtypes(Type);\n        if (annotationParamtypes === void 0) {\n            Reflect.defineMetadata(\"di:paramtypes\", (annotationParamtypes = []), Type);\n        }\n        return annotationParamtypes;\n    },\n    /**\n     * Gets the dependency keys representing what is needed to instantiate the specified type.\n     * @param Type - The type to get the dependencies for.\n     * @returns An array of dependency keys.\n     */\n    getDependencies(Type) {\n        // Note: Every detail of this getDependencies method is pretty deliberate at the moment, and probably not yet 100% tested from every possible angle,\n        // so be careful with making changes here as it can have a huge impact on complex end user apps.\n        // Preferably, only make changes to the dependency resolution process via a RFC.\n        let dependencies = dependencyLookup.get(Type);\n        if (dependencies === void 0) {\n            // Type.length is the number of constructor parameters. If this is 0, it could mean the class has an empty constructor\n            // but it could also mean the class has no constructor at all (in which case it inherits the constructor from the prototype).\n            // Non-zero constructor length + no paramtypes means emitDecoratorMetadata is off, or the class has no decorator.\n            // We're not doing anything with the above right now, but it's good to keep in mind for any future issues.\n            const inject = Type.inject;\n            if (inject === void 0) {\n                // design:paramtypes is set by tsc when emitDecoratorMetadata is enabled.\n                const designParamtypes = DI.getDesignParamtypes(Type);\n                // di:paramtypes is set by the parameter decorator from DI.createInterface or by @inject\n                const annotationParamtypes = DI.getAnnotationParamtypes(Type);\n                if (designParamtypes === void 0) {\n                    if (annotationParamtypes === void 0) {\n                        // Only go up the prototype if neither static inject nor any of the paramtypes is defined, as\n                        // there is no sound way to merge a type's deps with its prototype's deps\n                        const Proto = Object.getPrototypeOf(Type);\n                        if (typeof Proto === \"function\" && Proto !== Function.prototype) {\n                            dependencies = cloneArrayWithPossibleProps(DI.getDependencies(Proto));\n                        }\n                        else {\n                            dependencies = [];\n                        }\n                    }\n                    else {\n                        // No design:paramtypes so just use the di:paramtypes\n                        dependencies = cloneArrayWithPossibleProps(annotationParamtypes);\n                    }\n                }\n                else if (annotationParamtypes === void 0) {\n                    // No di:paramtypes so just use the design:paramtypes\n                    dependencies = cloneArrayWithPossibleProps(designParamtypes);\n                }\n                else {\n                    // We've got both, so merge them (in case of conflict on same index, di:paramtypes take precedence)\n                    dependencies = cloneArrayWithPossibleProps(designParamtypes);\n                    let len = annotationParamtypes.length;\n                    let auAnnotationParamtype;\n                    for (let i = 0; i < len; ++i) {\n                        auAnnotationParamtype = annotationParamtypes[i];\n                        if (auAnnotationParamtype !== void 0) {\n                            dependencies[i] = auAnnotationParamtype;\n                        }\n                    }\n                    const keys = Object.keys(annotationParamtypes);\n                    len = keys.length;\n                    let key;\n                    for (let i = 0; i < len; ++i) {\n                        key = keys[i];\n                        if (!isArrayIndex(key)) {\n                            dependencies[key] = annotationParamtypes[key];\n                        }\n                    }\n                }\n            }\n            else {\n                // Ignore paramtypes if we have static inject\n                dependencies = cloneArrayWithPossibleProps(inject);\n            }\n            dependencyLookup.set(Type, dependencies);\n        }\n        return dependencies;\n    },\n    /**\n     * Defines a property on a web component class. The value of this property will\n     * be resolved from the dependency injection container responsible for the element\n     * instance, based on where it is connected in the DOM.\n     * @param target - The target to define the property on.\n     * @param propertyName - The name of the property to define.\n     * @param key - The dependency injection key.\n     * @param respectConnection - Indicates whether or not to update the property value if the\n     * hosting component is disconnected and then re-connected at a different location in the DOM.\n     * @remarks\n     * The respectConnection option is only applicable to elements that descend from FASTElement.\n     */\n    defineProperty(target, propertyName, key, respectConnection = false) {\n        const diPropertyKey = `$di_${propertyName}`;\n        Reflect.defineProperty(target, propertyName, {\n            get: function () {\n                let value = this[diPropertyKey];\n                if (value === void 0) {\n                    const container = this instanceof HTMLElement\n                        ? DI.findResponsibleContainer(this)\n                        : DI.getOrCreateDOMContainer();\n                    value = container.get(key);\n                    this[diPropertyKey] = value;\n                    if (respectConnection && this instanceof FASTElement) {\n                        const notifier = this.$fastController;\n                        const handleChange = () => {\n                            const newContainer = DI.findResponsibleContainer(this);\n                            const newValue = newContainer.get(key);\n                            const oldValue = this[diPropertyKey];\n                            if (newValue !== oldValue) {\n                                this[diPropertyKey] = value;\n                                notifier.notify(propertyName);\n                            }\n                        };\n                        notifier.subscribe({ handleChange }, \"isConnected\");\n                    }\n                }\n                return value;\n            },\n        });\n    },\n    /**\n     * Creates a dependency injection key.\n     * @param nameConfigOrCallback - A friendly name for the key or a lambda that configures a\n     * default resolution for the dependency.\n     * @param configuror - If a friendly name was provided for the first parameter, then an optional\n     * lambda that configures a default resolution for the dependency can be provided second.\n     * @returns The created key.\n     * @remarks\n     * The created key can be used as a property decorator or constructor parameter decorator,\n     * in addition to its standard use in an inject array or through direct container APIs.\n     */\n    createInterface(nameConfigOrCallback, configuror) {\n        const configure = typeof nameConfigOrCallback === \"function\"\n            ? nameConfigOrCallback\n            : configuror;\n        const friendlyName = typeof nameConfigOrCallback === \"string\"\n            ? nameConfigOrCallback\n            : nameConfigOrCallback && \"friendlyName\" in nameConfigOrCallback\n                ? nameConfigOrCallback.friendlyName || defaultFriendlyName\n                : defaultFriendlyName;\n        const respectConnection = typeof nameConfigOrCallback === \"string\"\n            ? false\n            : nameConfigOrCallback && \"respectConnection\" in nameConfigOrCallback\n                ? nameConfigOrCallback.respectConnection || false\n                : false;\n        const Interface = function (target, property, index) {\n            if (target == null || new.target !== undefined) {\n                throw new Error(`No registration for interface: '${Interface.friendlyName}'`);\n            }\n            if (property) {\n                DI.defineProperty(target, property, Interface, respectConnection);\n            }\n            else {\n                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);\n                annotationParamtypes[index] = Interface;\n            }\n        };\n        Interface.$isInterface = true;\n        Interface.friendlyName = friendlyName == null ? \"(anonymous)\" : friendlyName;\n        if (configure != null) {\n            Interface.register = function (container, key) {\n                return configure(new ResolverBuilder(container, key !== null && key !== void 0 ? key : Interface));\n            };\n        }\n        Interface.toString = function toString() {\n            return `InterfaceSymbol<${Interface.friendlyName}>`;\n        };\n        return Interface;\n    },\n    /**\n     * A decorator that specifies what to inject into its target.\n     * @param dependencies - The dependencies to inject.\n     * @returns The decorator to be applied to the target class.\n     * @remarks\n     * The decorator can be used to decorate a class, listing all of the classes dependencies.\n     * Or it can be used to decorate a constructor paramter, indicating what to inject for that\n     * parameter.\n     * Or it can be used for a web component property, indicating what that property should resolve to.\n     */\n    inject(...dependencies) {\n        return function (target, key, descriptor) {\n            if (typeof descriptor === \"number\") {\n                // It's a parameter decorator.\n                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);\n                const dep = dependencies[0];\n                if (dep !== void 0) {\n                    annotationParamtypes[descriptor] = dep;\n                }\n            }\n            else if (key) {\n                DI.defineProperty(target, key, dependencies[0]);\n            }\n            else {\n                const annotationParamtypes = descriptor\n                    ? DI.getOrCreateAnnotationParamTypes(descriptor.value)\n                    : DI.getOrCreateAnnotationParamTypes(target);\n                let dep;\n                for (let i = 0; i < dependencies.length; ++i) {\n                    dep = dependencies[i];\n                    if (dep !== void 0) {\n                        annotationParamtypes[i] = dep;\n                    }\n                }\n            }\n        };\n    },\n    /**\n     * Registers the `target` class as a transient dependency; each time the dependency is resolved\n     * a new instance will be created.\n     *\n     * @param target - The class / constructor function to register as transient.\n     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n     *\n     * @example\n     * On an existing class\n     * ```ts\n     * class Foo { }\n     * DI.transient(Foo);\n     * ```\n     *\n     * @example\n     * Inline declaration\n     *\n     * ```ts\n     * const Foo = DI.transient(class { });\n     * // Foo is now strongly typed with register\n     * Foo.register(container);\n     * ```\n     *\n     * @public\n     */\n    transient(target) {\n        target.register = function register(container) {\n            const registration = Registration.transient(target, target);\n            return registration.register(container);\n        };\n        target.registerInRequestor = false;\n        return target;\n    },\n    /**\n     * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n     * consecutive time the dependency is resolved, the same instance will be returned.\n     *\n     * @param target - The class / constructor function to register as a singleton.\n     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n     * @example\n     * On an existing class\n     * ```ts\n     * class Foo { }\n     * DI.singleton(Foo);\n     * ```\n     *\n     * @example\n     * Inline declaration\n     * ```ts\n     * const Foo = DI.singleton(class { });\n     * // Foo is now strongly typed with register\n     * Foo.register(container);\n     * ```\n     *\n     * @public\n     */\n    singleton(target, options = defaultSingletonOptions) {\n        target.register = function register(container) {\n            const registration = Registration.singleton(target, target);\n            return registration.register(container);\n        };\n        target.registerInRequestor = options.scoped;\n        return target;\n    },\n});\n/**\n * The interface key that resolves the dependency injection container itself.\n * @public\n */\nexport const Container = DI.createInterface(\"Container\");\n/**\n * The interface key that resolves the service locator itself.\n * @public\n */\nexport const ServiceLocator = Container;\nfunction createResolver(getter) {\n    return function (key) {\n        const resolver = function (target, property, descriptor) {\n            DI.inject(resolver)(target, property, descriptor);\n        };\n        resolver.$isResolver = true;\n        resolver.resolve = function (handler, requestor) {\n            return getter(key, handler, requestor);\n        };\n        return resolver;\n    };\n}\n/**\n * A decorator that specifies what to inject into its target.\n * @param dependencies - The dependencies to inject.\n * @returns The decorator to be applied to the target class.\n * @remarks\n * The decorator can be used to decorate a class, listing all of the classes dependencies.\n * Or it can be used to decorate a constructor paramter, indicating what to inject for that\n * parameter.\n * Or it can be used for a web component property, indicating what that property should resolve to.\n *\n * @public\n */\nexport const inject = DI.inject;\nfunction transientDecorator(target) {\n    return DI.transient(target);\n}\nexport function transient(target) {\n    return target == null ? transientDecorator : transientDecorator(target);\n}\nconst defaultSingletonOptions = { scoped: false };\nfunction singletonDecorator(target) {\n    return DI.singleton(target);\n}\n/**\n * @public\n */\nexport function singleton(targetOrOptions) {\n    if (typeof targetOrOptions === \"function\") {\n        return DI.singleton(targetOrOptions);\n    }\n    return function ($target) {\n        return DI.singleton($target, targetOrOptions);\n    };\n}\nfunction createAllResolver(getter) {\n    return function (key, searchAncestors) {\n        searchAncestors = !!searchAncestors;\n        const resolver = function (target, property, descriptor) {\n            DI.inject(resolver)(target, property, descriptor);\n        };\n        resolver.$isResolver = true;\n        resolver.resolve = function (handler, requestor) {\n            /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n            return getter(key, handler, requestor, searchAncestors);\n        };\n        return resolver;\n    };\n}\n/**\n * A decorator and DI resolver that will resolve an array of all dependencies\n * registered with the specified key.\n * @param key - The key to resolve all dependencies for.\n * @param searchAncestors - [optional] Indicates whether to search ancestor containers.\n * @public\n */\nexport const all = createAllResolver((key, handler, requestor, searchAncestors) => requestor.getAll(key, searchAncestors));\n/**\n * A decorator that lazily injects a dependency depending on whether the `Key` is present at the time of function call.\n *\n * @example\n * You need to make your argument a function that returns the type, for example\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => number )\n * }\n * const foo = container.get(Foo); // instanceof Foo\n * foo.random(); // throws\n * ```\n * would throw an exception because you haven't registered `'random'` before calling the method.\n * @example\n * This, would give you a new 'Math.random()' number each time.\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => random )\n * }\n * container.register(Registration.callback('random', Math.random ));\n * container.get(Foo).random(); // some random number\n * container.get(Foo).random(); // another random number\n * ```\n *\n * `@lazy` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a\n * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.\n *\n * @param key - The key to lazily resolve.\n * see {@link DI.createInterface} on interactions with interfaces\n *\n * @public\n */\nexport const lazy = createResolver((key, handler, requestor) => {\n    return () => requestor.get(key);\n});\n/**\n * A decorator that allows you to optionally inject a dependency depending on whether the [[`Key`]] is present, for example:\n * @example\n * ```ts\n * class Foo {\n *   constructor( @inject('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo); // throws\n * ```\n * would fail\n *\n * @example\n * ```ts\n * class Foo {\n *   constructor( @optional('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo).str // somestring\n * ```\n * if you use it without a default it will inject `undefined`, so remember to mark your input type as\n * possibly `undefined`!\n *\n * @param key - The key to optionally resolve.\n * see {@link DI.createInterface} on interactions with interfaces\n *\n * @public\n */\nexport const optional = createResolver((key, handler, requestor) => {\n    if (requestor.has(key, true)) {\n        return requestor.get(key);\n    }\n    else {\n        return undefined;\n    }\n});\n/**\n * A decorator that tells the container not to try to inject a dependency.\n *\n * @public\n */\nexport function ignore(target, property, descriptor) {\n    DI.inject(ignore)(target, property, descriptor);\n}\n// Hack: casting below used to prevent TS from generate a namespace which can't be commented\n// and results in documentation validation errors.\nignore.$isResolver = true;\nignore.resolve = () => undefined;\n/**\n * A decorator that indicates that a new instance should be injected scoped to the\n * container that requested the instance.\n * @param key - The dependency key for the new instance.\n * @remarks\n * This creates a resolver with an instance strategy pointing to the new instance, effectively\n * making this a singleton, scoped to the container or DOM's subtree.\n *\n * @public\n */\nexport const newInstanceForScope = createResolver((key, handler, requestor) => {\n    const instance = createNewInstance(key, handler);\n    const resolver = new ResolverImpl(key, 0 /* instance */, instance);\n    requestor.registerResolver(key, resolver);\n    return instance;\n});\n/**\n * A decorator that indicates that a new instance should be injected.\n * @param key - The dependency key for the new instance.\n * @remarks\n * The instance is not internally cached with a resolver as newInstanceForScope does.\n *\n * @public\n */\nexport const newInstanceOf = createResolver((key, handler, _requestor) => createNewInstance(key, handler));\nfunction createNewInstance(key, handler) {\n    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n    return handler.getFactory(key).construct(handler);\n}\n/** @internal */\nexport class ResolverImpl {\n    constructor(key, strategy, state) {\n        this.key = key;\n        this.strategy = strategy;\n        this.state = state;\n        this.resolving = false;\n    }\n    get $isResolver() {\n        return true;\n    }\n    register(container) {\n        return container.registerResolver(this.key, this);\n    }\n    resolve(handler, requestor) {\n        switch (this.strategy) {\n            case 0 /* instance */:\n                return this.state;\n            case 1 /* singleton */: {\n                if (this.resolving) {\n                    throw new Error(`Cyclic dependency found: ${this.state.name}`);\n                }\n                this.resolving = true;\n                this.state = handler\n                    .getFactory(this.state)\n                    .construct(requestor);\n                this.strategy = 0 /* instance */;\n                this.resolving = false;\n                return this.state;\n            }\n            case 2 /* transient */: {\n                // Always create transients from the requesting container\n                const factory = handler.getFactory(this.state);\n                if (factory === null) {\n                    throw new Error(`Resolver for ${String(this.key)} returned a null factory`);\n                }\n                return factory.construct(requestor);\n            }\n            case 3 /* callback */:\n                return this.state(handler, requestor, this);\n            case 4 /* array */:\n                return this.state[0].resolve(handler, requestor);\n            case 5 /* alias */:\n                return requestor.get(this.state);\n            default:\n                throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`);\n        }\n    }\n    getFactory(container) {\n        var _a, _b, _c;\n        switch (this.strategy) {\n            case 1 /* singleton */:\n            case 2 /* transient */:\n                return container.getFactory(this.state);\n            case 5 /* alias */:\n                return (_c = (_b = (_a = container.getResolver(this.state)) === null || _a === void 0 ? void 0 : _a.getFactory) === null || _b === void 0 ? void 0 : _b.call(_a, container)) !== null && _c !== void 0 ? _c : null;\n            default:\n                return null;\n        }\n    }\n}\nfunction containerGetKey(d) {\n    return this.get(d);\n}\nfunction transformInstance(inst, transform) {\n    return transform(inst);\n}\n/** @internal */\nexport class FactoryImpl {\n    constructor(Type, dependencies) {\n        this.Type = Type;\n        this.dependencies = dependencies;\n        this.transformers = null;\n    }\n    construct(container, dynamicDependencies) {\n        let instance;\n        if (dynamicDependencies === void 0) {\n            instance = new this.Type(...this.dependencies.map(containerGetKey, container));\n        }\n        else {\n            instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies);\n        }\n        if (this.transformers == null) {\n            return instance;\n        }\n        return this.transformers.reduce(transformInstance, instance);\n    }\n    registerTransformer(transformer) {\n        (this.transformers || (this.transformers = [])).push(transformer);\n    }\n}\nconst containerResolver = {\n    $isResolver: true,\n    resolve(handler, requestor) {\n        return requestor;\n    },\n};\nfunction isRegistry(obj) {\n    return typeof obj.register === \"function\";\n}\nfunction isSelfRegistry(obj) {\n    return isRegistry(obj) && typeof obj.registerInRequestor === \"boolean\";\n}\nfunction isRegisterInRequester(obj) {\n    return isSelfRegistry(obj) && obj.registerInRequestor;\n}\nfunction isClass(obj) {\n    return obj.prototype !== void 0;\n}\nconst InstrinsicTypeNames = new Set([\n    \"Array\",\n    \"ArrayBuffer\",\n    \"Boolean\",\n    \"DataView\",\n    \"Date\",\n    \"Error\",\n    \"EvalError\",\n    \"Float32Array\",\n    \"Float64Array\",\n    \"Function\",\n    \"Int8Array\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Map\",\n    \"Number\",\n    \"Object\",\n    \"Promise\",\n    \"RangeError\",\n    \"ReferenceError\",\n    \"RegExp\",\n    \"Set\",\n    \"SharedArrayBuffer\",\n    \"String\",\n    \"SyntaxError\",\n    \"TypeError\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"URIError\",\n    \"WeakMap\",\n    \"WeakSet\",\n]);\nconst DILocateParentEventType = \"__DI_LOCATE_PARENT__\";\nconst factories = new Map();\n/**\n * @internal\n */\nexport class ContainerImpl {\n    constructor(owner, config) {\n        this.owner = owner;\n        this.config = config;\n        this._parent = void 0;\n        this.registerDepth = 0;\n        this.context = null;\n        if (owner !== null) {\n            owner.$$container$$ = this;\n        }\n        this.resolvers = new Map();\n        this.resolvers.set(Container, containerResolver);\n        if (owner instanceof Node) {\n            owner.addEventListener(DILocateParentEventType, (e) => {\n                if (e.composedPath()[0] !== this.owner) {\n                    e.detail.container = this;\n                    e.stopImmediatePropagation();\n                }\n            });\n        }\n    }\n    get parent() {\n        if (this._parent === void 0) {\n            this._parent = this.config.parentLocator(this.owner);\n        }\n        return this._parent;\n    }\n    get depth() {\n        return this.parent === null ? 0 : this.parent.depth + 1;\n    }\n    get responsibleForOwnerRequests() {\n        return this.config.responsibleForOwnerRequests;\n    }\n    registerWithContext(context, ...params) {\n        this.context = context;\n        this.register(...params);\n        this.context = null;\n        return this;\n    }\n    register(...params) {\n        if (++this.registerDepth === 100) {\n            throw new Error(\"Unable to autoregister dependency\");\n            // Most likely cause is trying to register a plain object that does not have a\n            // register method and is not a class constructor\n        }\n        let current;\n        let keys;\n        let value;\n        let j;\n        let jj;\n        const context = this.context;\n        for (let i = 0, ii = params.length; i < ii; ++i) {\n            current = params[i];\n            if (!isObject(current)) {\n                continue;\n            }\n            if (isRegistry(current)) {\n                current.register(this, context);\n            }\n            else if (isClass(current)) {\n                Registration.singleton(current, current).register(this);\n            }\n            else {\n                keys = Object.keys(current);\n                j = 0;\n                jj = keys.length;\n                for (; j < jj; ++j) {\n                    value = current[keys[j]];\n                    if (!isObject(value)) {\n                        continue;\n                    }\n                    // note: we could remove this if-branch and call this.register directly\n                    // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator\n                    if (isRegistry(value)) {\n                        value.register(this, context);\n                    }\n                    else {\n                        this.register(value);\n                    }\n                }\n            }\n        }\n        --this.registerDepth;\n        return this;\n    }\n    registerResolver(key, resolver) {\n        validateKey(key);\n        const resolvers = this.resolvers;\n        const result = resolvers.get(key);\n        if (result == null) {\n            resolvers.set(key, resolver);\n        }\n        else if (result instanceof ResolverImpl &&\n            result.strategy === 4 /* array */) {\n            result.state.push(resolver);\n        }\n        else {\n            resolvers.set(key, new ResolverImpl(key, 4 /* array */, [result, resolver]));\n        }\n        return resolver;\n    }\n    registerTransformer(key, transformer) {\n        const resolver = this.getResolver(key);\n        if (resolver == null) {\n            return false;\n        }\n        if (resolver.getFactory) {\n            const factory = resolver.getFactory(this);\n            if (factory == null) {\n                return false;\n            }\n            // This type cast is a bit of a hacky one, necessary due to the duplicity of IResolverLike.\n            // Problem is that that interface's type arg can be of type Key, but the getFactory method only works on\n            // type Constructable. So the return type of that optional method has this additional constraint, which\n            // seems to confuse the type checker.\n            factory.registerTransformer(transformer);\n            return true;\n        }\n        return false;\n    }\n    getResolver(key, autoRegister = true) {\n        validateKey(key);\n        if (key.resolve !== void 0) {\n            return key;\n        }\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n        let current = this;\n        let resolver;\n        while (current != null) {\n            resolver = current.resolvers.get(key);\n            if (resolver == null) {\n                if (current.parent == null) {\n                    const handler = isRegisterInRequester(key)\n                        ? this\n                        : current;\n                    return autoRegister ? this.jitRegister(key, handler) : null;\n                }\n                current = current.parent;\n            }\n            else {\n                return resolver;\n            }\n        }\n        return null;\n    }\n    has(key, searchAncestors = false) {\n        return this.resolvers.has(key)\n            ? true\n            : searchAncestors && this.parent != null\n                ? this.parent.has(key, true)\n                : false;\n    }\n    get(key) {\n        validateKey(key);\n        if (key.$isResolver) {\n            return key.resolve(this, this);\n        }\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n        let current = this;\n        let resolver;\n        while (current != null) {\n            resolver = current.resolvers.get(key);\n            if (resolver == null) {\n                if (current.parent == null) {\n                    const handler = isRegisterInRequester(key)\n                        ? this\n                        : current;\n                    resolver = this.jitRegister(key, handler);\n                    return resolver.resolve(current, this);\n                }\n                current = current.parent;\n            }\n            else {\n                return resolver.resolve(current, this);\n            }\n        }\n        throw new Error(`Unable to resolve key: ${key}`);\n    }\n    getAll(key, searchAncestors = false) {\n        validateKey(key);\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n        const requestor = this;\n        let current = requestor;\n        let resolver;\n        if (searchAncestors) {\n            let resolutions = emptyArray;\n            while (current != null) {\n                resolver = current.resolvers.get(key);\n                if (resolver != null) {\n                    resolutions = resolutions.concat(\n                    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n                    buildAllResponse(resolver, current, requestor));\n                }\n                current = current.parent;\n            }\n            return resolutions;\n        }\n        else {\n            while (current != null) {\n                resolver = current.resolvers.get(key);\n                if (resolver == null) {\n                    current = current.parent;\n                    if (current == null) {\n                        return emptyArray;\n                    }\n                }\n                else {\n                    return buildAllResponse(resolver, current, requestor);\n                }\n            }\n        }\n        return emptyArray;\n    }\n    getFactory(Type) {\n        let factory = factories.get(Type);\n        if (factory === void 0) {\n            if (isNativeFunction(Type)) {\n                throw new Error(`${Type.name} is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`);\n            }\n            factories.set(Type, (factory = new FactoryImpl(Type, DI.getDependencies(Type))));\n        }\n        return factory;\n    }\n    registerFactory(key, factory) {\n        factories.set(key, factory);\n    }\n    createChild(config) {\n        return new ContainerImpl(null, Object.assign({}, this.config, config, { parentLocator: () => this }));\n    }\n    jitRegister(keyAsValue, handler) {\n        if (typeof keyAsValue !== \"function\") {\n            throw new Error(`Attempted to jitRegister something that is not a constructor: '${keyAsValue}'. Did you forget to register this dependency?`);\n        }\n        if (InstrinsicTypeNames.has(keyAsValue.name)) {\n            throw new Error(`Attempted to jitRegister an intrinsic type: ${keyAsValue.name}. Did you forget to add @inject(Key)`);\n        }\n        if (isRegistry(keyAsValue)) {\n            const registrationResolver = keyAsValue.register(handler);\n            if (!(registrationResolver instanceof Object) ||\n                registrationResolver.resolve == null) {\n                const newResolver = handler.resolvers.get(keyAsValue);\n                if (newResolver != void 0) {\n                    return newResolver;\n                }\n                throw new Error(\"A valid resolver was not returned from the static register method\");\n            }\n            return registrationResolver;\n        }\n        else if (keyAsValue.$isInterface) {\n            throw new Error(`Attempted to jitRegister an interface: ${keyAsValue.friendlyName}`);\n        }\n        else {\n            const resolver = this.config.defaultResolver(keyAsValue, handler);\n            handler.resolvers.set(keyAsValue, resolver);\n            return resolver;\n        }\n    }\n}\nconst cache = new WeakMap();\nfunction cacheCallbackResult(fun) {\n    return function (handler, requestor, resolver) {\n        if (cache.has(resolver)) {\n            return cache.get(resolver);\n        }\n        const t = fun(handler, requestor, resolver);\n        cache.set(resolver, t);\n        return t;\n    };\n}\n/**\n * You can use the resulting Registration of any of the factory methods\n * to register with the container.\n *\n * @example\n * ```\n * class Foo {}\n * const container = DI.createContainer();\n * container.register(Registration.instance(Foo, new Foo()));\n * container.get(Foo);\n * ```\n *\n * @public\n */\nexport const Registration = Object.freeze({\n    /**\n     * Allows you to pass an instance.\n     * Every time you request this {@link Key} you will get this instance back.\n     *\n     * @example\n     * ```\n     * Registration.instance(Foo, new Foo()));\n     * ```\n     *\n     * @param key - The key to register the instance under.\n     * @param value - The instance to return when the key is requested.\n     */\n    instance(key, value) {\n        return new ResolverImpl(key, 0 /* instance */, value);\n    },\n    /**\n     * Creates an instance from the class.\n     * Every time you request this {@link Key} you will get the same one back.\n     *\n     * @example\n     * ```\n     * Registration.singleton(Foo, Foo);\n     * ```\n     *\n     * @param key - The key to register the singleton under.\n     * @param value - The class to instantiate as a singleton when first requested.\n     */\n    singleton(key, value) {\n        return new ResolverImpl(key, 1 /* singleton */, value);\n    },\n    /**\n     * Creates an instance from a class.\n     * Every time you request this {@link Key} you will get a new instance.\n     *\n     * @example\n     * ```\n     * Registration.instance(Foo, Foo);\n     * ```\n     *\n     * @param key - The key to register the instance type under.\n     * @param value - The class to instantiate each time the key is requested.\n     */\n    transient(key, value) {\n        return new ResolverImpl(key, 2 /* transient */, value);\n    },\n    /**\n     * Delegates to a callback function to provide the dependency.\n     * Every time you request this {@link Key} the callback will be invoked to provide\n     * the dependency.\n     *\n     * @example\n     * ```\n     * Registration.callback(Foo, () => new Foo());\n     * Registration.callback(Bar, (c: Container) => new Bar(c.get(Foo)));\n     * ```\n     *\n     * @param key - The key to register the callback for.\n     * @param callback - The function that is expected to return the dependency.\n     */\n    callback(key, callback) {\n        return new ResolverImpl(key, 3 /* callback */, callback);\n    },\n    /**\n     * Delegates to a callback function to provide the dependency and then caches the\n     * dependency for future requests.\n     *\n     * @example\n     * ```\n     * Registration.cachedCallback(Foo, () => new Foo());\n     * Registration.cachedCallback(Bar, (c: Container) => new Bar(c.get(Foo)));\n     * ```\n     *\n     * @param key - The key to register the callback for.\n     * @param callback - The function that is expected to return the dependency.\n     * @remarks\n     * If you pass the same Registration to another container, the same cached value will be used.\n     * Should all references to the resolver returned be removed, the cache will expire.\n     */\n    cachedCallback(key, callback) {\n        return new ResolverImpl(key, 3 /* callback */, cacheCallbackResult(callback));\n    },\n    /**\n     * Creates an alternate {@link Key} to retrieve an instance by.\n     *\n     * @example\n     * ```\n     * Register.singleton(Foo, Foo)\n     * Register.aliasTo(Foo, MyFoos);\n     *\n     * container.getAll(MyFoos) // contains an instance of Foo\n     * ```\n     *\n     * @param originalKey - The original key that has been registered.\n     * @param aliasKey - The alias to the original key.\n     */\n    aliasTo(originalKey, aliasKey) {\n        return new ResolverImpl(aliasKey, 5 /* alias */, originalKey);\n    },\n});\n/** @internal */\nexport function validateKey(key) {\n    if (key === null || key === void 0) {\n        throw new Error(\"key/value cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?\");\n    }\n}\nfunction buildAllResponse(resolver, handler, requestor) {\n    if (resolver instanceof ResolverImpl &&\n        resolver.strategy === 4 /* array */) {\n        const state = resolver.state;\n        let i = state.length;\n        const results = new Array(i);\n        while (i--) {\n            results[i] = state[i].resolve(handler, requestor);\n        }\n        return results;\n    }\n    return [resolver.resolve(handler, requestor)];\n}\nconst defaultFriendlyName = \"(anonymous)\";\nfunction isObject(value) {\n    return (typeof value === \"object\" && value !== null) || typeof value === \"function\";\n}\n/**\n * Determine whether the value is a native function.\n *\n * @param fn - The function to check.\n * @returns `true` is the function is a native function, otherwise `false`\n */\nconst isNativeFunction = (function () {\n    const lookup = new WeakMap();\n    let isNative = false;\n    let sourceText = \"\";\n    let i = 0;\n    return function (fn) {\n        isNative = lookup.get(fn);\n        if (isNative === void 0) {\n            sourceText = fn.toString();\n            i = sourceText.length;\n            // http://www.ecma-international.org/ecma-262/#prod-NativeFunction\n            isNative =\n                // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string\n                i >= 29 &&\n                    // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.\n                    i <= 100 &&\n                    // This whole heuristic *could* be tricked by a comment. Do we need to care about that?\n                    sourceText.charCodeAt(i - 1) === 0x7d && // }\n                    // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.\n                    sourceText.charCodeAt(i - 2) <= 0x20 && // whitespace\n                    sourceText.charCodeAt(i - 3) === 0x5d && // ]\n                    sourceText.charCodeAt(i - 4) === 0x65 && // e\n                    sourceText.charCodeAt(i - 5) === 0x64 && // d\n                    sourceText.charCodeAt(i - 6) === 0x6f && // o\n                    sourceText.charCodeAt(i - 7) === 0x63 && // c\n                    sourceText.charCodeAt(i - 8) === 0x20 && //\n                    sourceText.charCodeAt(i - 9) === 0x65 && // e\n                    sourceText.charCodeAt(i - 10) === 0x76 && // v\n                    sourceText.charCodeAt(i - 11) === 0x69 && // i\n                    sourceText.charCodeAt(i - 12) === 0x74 && // t\n                    sourceText.charCodeAt(i - 13) === 0x61 && // a\n                    sourceText.charCodeAt(i - 14) === 0x6e && // n\n                    sourceText.charCodeAt(i - 15) === 0x58; // [\n            lookup.set(fn, isNative);\n        }\n        return isNative;\n    };\n})();\nconst isNumericLookup = {};\nfunction isArrayIndex(value) {\n    switch (typeof value) {\n        case \"number\":\n            return value >= 0 && (value | 0) === value;\n        case \"string\": {\n            const result = isNumericLookup[value];\n            if (result !== void 0) {\n                return result;\n            }\n            const length = value.length;\n            if (length === 0) {\n                return (isNumericLookup[value] = false);\n            }\n            let ch = 0;\n            for (let i = 0; i < length; ++i) {\n                ch = value.charCodeAt(i);\n                if ((i === 0 && ch === 0x30 && length > 1) /* must not start with 0 */ ||\n                    ch < 0x30 /* 0 */ ||\n                    ch > 0x39 /* 9 */) {\n                    return (isNumericLookup[value] = false);\n                }\n            }\n            return (isNumericLookup[value] = true);\n        }\n        default:\n            return false;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}